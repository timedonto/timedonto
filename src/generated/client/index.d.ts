
/**
 * Client
**/

import * as runtime from './runtime/binary.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Clinic
 * 
 */
export type Clinic = $Result.DefaultSelection<Prisma.$ClinicPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Dentist
 * 
 */
export type Dentist = $Result.DefaultSelection<Prisma.$DentistPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Record
 * 
 */
export type Record = $Result.DefaultSelection<Prisma.$RecordPayload>
/**
 * Model TreatmentPlan
 * 
 */
export type TreatmentPlan = $Result.DefaultSelection<Prisma.$TreatmentPlanPayload>
/**
 * Model TreatmentItem
 * 
 */
export type TreatmentItem = $Result.DefaultSelection<Prisma.$TreatmentItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PaymentTreatmentPlan
 * 
 */
export type PaymentTreatmentPlan = $Result.DefaultSelection<Prisma.$PaymentTreatmentPlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model InventoryMovement
 * 
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model Specialty
 * 
 */
export type Specialty = $Result.DefaultSelection<Prisma.$SpecialtyPayload>
/**
 * Model CID
 * 
 */
export type CID = $Result.DefaultSelection<Prisma.$CIDPayload>
/**
 * Model Procedure
 * 
 */
export type Procedure = $Result.DefaultSelection<Prisma.$ProcedurePayload>
/**
 * Model DentistProcedure
 * 
 */
export type DentistProcedure = $Result.DefaultSelection<Prisma.$DentistProcedurePayload>
/**
 * Model DentistSpecialty
 * 
 */
export type DentistSpecialty = $Result.DefaultSelection<Prisma.$DentistSpecialtyPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model AttendanceCID
 * 
 */
export type AttendanceCID = $Result.DefaultSelection<Prisma.$AttendanceCIDPayload>
/**
 * Model AttendanceProcedure
 * 
 */
export type AttendanceProcedure = $Result.DefaultSelection<Prisma.$AttendanceProcedurePayload>
/**
 * Model AttendanceOdontogram
 * 
 */
export type AttendanceOdontogram = $Result.DefaultSelection<Prisma.$AttendanceOdontogramPayload>
/**
 * Model ClinicalDocument
 * 
 */
export type ClinicalDocument = $Result.DefaultSelection<Prisma.$ClinicalDocumentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  DENTIST: 'DENTIST',
  RECEPTIONIST: 'RECEPTIONIST'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  CONFIRMED: 'CONFIRMED',
  CANCELED: 'CANCELED',
  RESCHEDULED: 'RESCHEDULED',
  NO_SHOW: 'NO_SHOW',
  DONE: 'DONE'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const TreatmentPlanStatus: {
  OPEN: 'OPEN',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type TreatmentPlanStatus = (typeof TreatmentPlanStatus)[keyof typeof TreatmentPlanStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  PIX: 'PIX',
  CARD: 'CARD'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  CANCELED: 'CANCELED',
  PAST_DUE: 'PAST_DUE'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const InventoryMovementType: {
  IN: 'IN',
  OUT: 'OUT'
};

export type InventoryMovementType = (typeof InventoryMovementType)[keyof typeof InventoryMovementType]


export const AttendanceStatus: {
  CHECKED_IN: 'CHECKED_IN',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE',
  CANCELED: 'CANCELED',
  NO_SHOW: 'NO_SHOW'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const ClinicalDocumentType: {
  ATESTADO: 'ATESTADO',
  PRESCRICAO: 'PRESCRICAO',
  EXAME: 'EXAME',
  ENCAMINHAMENTO: 'ENCAMINHAMENTO'
};

export type ClinicalDocumentType = (typeof ClinicalDocumentType)[keyof typeof ClinicalDocumentType]


export const DiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED: 'FIXED'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type TreatmentPlanStatus = $Enums.TreatmentPlanStatus

export const TreatmentPlanStatus: typeof $Enums.TreatmentPlanStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type InventoryMovementType = $Enums.InventoryMovementType

export const InventoryMovementType: typeof $Enums.InventoryMovementType

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type ClinicalDocumentType = $Enums.ClinicalDocumentType

export const ClinicalDocumentType: typeof $Enums.ClinicalDocumentType

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clinics
 * const clinics = await prisma.clinic.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clinics
   * const clinics = await prisma.clinic.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => $Utils.JsPromise<void> : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.clinic`: Exposes CRUD operations for the **Clinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinics
    * const clinics = await prisma.clinic.findMany()
    * ```
    */
  get clinic(): Prisma.ClinicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dentist`: Exposes CRUD operations for the **Dentist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dentists
    * const dentists = await prisma.dentist.findMany()
    * ```
    */
  get dentist(): Prisma.DentistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.record`: Exposes CRUD operations for the **Record** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Records
    * const records = await prisma.record.findMany()
    * ```
    */
  get record(): Prisma.RecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treatmentPlan`: Exposes CRUD operations for the **TreatmentPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TreatmentPlans
    * const treatmentPlans = await prisma.treatmentPlan.findMany()
    * ```
    */
  get treatmentPlan(): Prisma.TreatmentPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treatmentItem`: Exposes CRUD operations for the **TreatmentItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TreatmentItems
    * const treatmentItems = await prisma.treatmentItem.findMany()
    * ```
    */
  get treatmentItem(): Prisma.TreatmentItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentTreatmentPlan`: Exposes CRUD operations for the **PaymentTreatmentPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTreatmentPlans
    * const paymentTreatmentPlans = await prisma.paymentTreatmentPlan.findMany()
    * ```
    */
  get paymentTreatmentPlan(): Prisma.PaymentTreatmentPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specialty`: Exposes CRUD operations for the **Specialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialties
    * const specialties = await prisma.specialty.findMany()
    * ```
    */
  get specialty(): Prisma.SpecialtyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cID`: Exposes CRUD operations for the **CID** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CIDS
    * const cIDS = await prisma.cID.findMany()
    * ```
    */
  get cID(): Prisma.CIDDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.procedure`: Exposes CRUD operations for the **Procedure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedures
    * const procedures = await prisma.procedure.findMany()
    * ```
    */
  get procedure(): Prisma.ProcedureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dentistProcedure`: Exposes CRUD operations for the **DentistProcedure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DentistProcedures
    * const dentistProcedures = await prisma.dentistProcedure.findMany()
    * ```
    */
  get dentistProcedure(): Prisma.DentistProcedureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dentistSpecialty`: Exposes CRUD operations for the **DentistSpecialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DentistSpecialties
    * const dentistSpecialties = await prisma.dentistSpecialty.findMany()
    * ```
    */
  get dentistSpecialty(): Prisma.DentistSpecialtyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceCID`: Exposes CRUD operations for the **AttendanceCID** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceCIDS
    * const attendanceCIDS = await prisma.attendanceCID.findMany()
    * ```
    */
  get attendanceCID(): Prisma.AttendanceCIDDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceProcedure`: Exposes CRUD operations for the **AttendanceProcedure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceProcedures
    * const attendanceProcedures = await prisma.attendanceProcedure.findMany()
    * ```
    */
  get attendanceProcedure(): Prisma.AttendanceProcedureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceOdontogram`: Exposes CRUD operations for the **AttendanceOdontogram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceOdontograms
    * const attendanceOdontograms = await prisma.attendanceOdontogram.findMany()
    * ```
    */
  get attendanceOdontogram(): Prisma.AttendanceOdontogramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicalDocument`: Exposes CRUD operations for the **ClinicalDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicalDocuments
    * const clinicalDocuments = await prisma.clinicalDocument.findMany()
    * ```
    */
  get clinicalDocument(): Prisma.ClinicalDocumentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Clinic: 'Clinic',
    User: 'User',
    Dentist: 'Dentist',
    Patient: 'Patient',
    Appointment: 'Appointment',
    Record: 'Record',
    TreatmentPlan: 'TreatmentPlan',
    TreatmentItem: 'TreatmentItem',
    Payment: 'Payment',
    PaymentTreatmentPlan: 'PaymentTreatmentPlan',
    Subscription: 'Subscription',
    AuditLog: 'AuditLog',
    InventoryItem: 'InventoryItem',
    InventoryMovement: 'InventoryMovement',
    Specialty: 'Specialty',
    CID: 'CID',
    Procedure: 'Procedure',
    DentistProcedure: 'DentistProcedure',
    DentistSpecialty: 'DentistSpecialty',
    Attendance: 'Attendance',
    AttendanceCID: 'AttendanceCID',
    AttendanceProcedure: 'AttendanceProcedure',
    AttendanceOdontogram: 'AttendanceOdontogram',
    ClinicalDocument: 'ClinicalDocument'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "clinic" | "user" | "dentist" | "patient" | "appointment" | "record" | "treatmentPlan" | "treatmentItem" | "payment" | "paymentTreatmentPlan" | "subscription" | "auditLog" | "inventoryItem" | "inventoryMovement" | "specialty" | "cID" | "procedure" | "dentistProcedure" | "dentistSpecialty" | "attendance" | "attendanceCID" | "attendanceProcedure" | "attendanceOdontogram" | "clinicalDocument"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Clinic: {
        payload: Prisma.$ClinicPayload<ExtArgs>
        fields: Prisma.ClinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findFirst: {
            args: Prisma.ClinicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findMany: {
            args: Prisma.ClinicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          create: {
            args: Prisma.ClinicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          createMany: {
            args: Prisma.ClinicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          delete: {
            args: Prisma.ClinicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          update: {
            args: Prisma.ClinicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          deleteMany: {
            args: Prisma.ClinicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          upsert: {
            args: Prisma.ClinicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          aggregate: {
            args: Prisma.ClinicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic>
          }
          groupBy: {
            args: Prisma.ClinicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Dentist: {
        payload: Prisma.$DentistPayload<ExtArgs>
        fields: Prisma.DentistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DentistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DentistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>
          }
          findFirst: {
            args: Prisma.DentistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DentistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>
          }
          findMany: {
            args: Prisma.DentistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>[]
          }
          create: {
            args: Prisma.DentistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>
          }
          createMany: {
            args: Prisma.DentistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DentistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>[]
          }
          delete: {
            args: Prisma.DentistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>
          }
          update: {
            args: Prisma.DentistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>
          }
          deleteMany: {
            args: Prisma.DentistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DentistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DentistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>[]
          }
          upsert: {
            args: Prisma.DentistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistPayload>
          }
          aggregate: {
            args: Prisma.DentistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDentist>
          }
          groupBy: {
            args: Prisma.DentistGroupByArgs<ExtArgs>
            result: $Utils.Optional<DentistGroupByOutputType>[]
          }
          count: {
            args: Prisma.DentistCountArgs<ExtArgs>
            result: $Utils.Optional<DentistCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Record: {
        payload: Prisma.$RecordPayload<ExtArgs>
        fields: Prisma.RecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>
          }
          findFirst: {
            args: Prisma.RecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>
          }
          findMany: {
            args: Prisma.RecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>[]
          }
          create: {
            args: Prisma.RecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>
          }
          createMany: {
            args: Prisma.RecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>[]
          }
          delete: {
            args: Prisma.RecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>
          }
          update: {
            args: Prisma.RecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>
          }
          deleteMany: {
            args: Prisma.RecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>[]
          }
          upsert: {
            args: Prisma.RecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecordPayload>
          }
          aggregate: {
            args: Prisma.RecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecord>
          }
          groupBy: {
            args: Prisma.RecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecordCountArgs<ExtArgs>
            result: $Utils.Optional<RecordCountAggregateOutputType> | number
          }
        }
      }
      TreatmentPlan: {
        payload: Prisma.$TreatmentPlanPayload<ExtArgs>
        fields: Prisma.TreatmentPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreatmentPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreatmentPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
          }
          findFirst: {
            args: Prisma.TreatmentPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreatmentPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
          }
          findMany: {
            args: Prisma.TreatmentPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>[]
          }
          create: {
            args: Prisma.TreatmentPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
          }
          createMany: {
            args: Prisma.TreatmentPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreatmentPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>[]
          }
          delete: {
            args: Prisma.TreatmentPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
          }
          update: {
            args: Prisma.TreatmentPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
          }
          deleteMany: {
            args: Prisma.TreatmentPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreatmentPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TreatmentPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>[]
          }
          upsert: {
            args: Prisma.TreatmentPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
          }
          aggregate: {
            args: Prisma.TreatmentPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreatmentPlan>
          }
          groupBy: {
            args: Prisma.TreatmentPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreatmentPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreatmentPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TreatmentPlanCountAggregateOutputType> | number
          }
        }
      }
      TreatmentItem: {
        payload: Prisma.$TreatmentItemPayload<ExtArgs>
        fields: Prisma.TreatmentItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreatmentItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreatmentItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>
          }
          findFirst: {
            args: Prisma.TreatmentItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreatmentItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>
          }
          findMany: {
            args: Prisma.TreatmentItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>[]
          }
          create: {
            args: Prisma.TreatmentItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>
          }
          createMany: {
            args: Prisma.TreatmentItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreatmentItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>[]
          }
          delete: {
            args: Prisma.TreatmentItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>
          }
          update: {
            args: Prisma.TreatmentItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>
          }
          deleteMany: {
            args: Prisma.TreatmentItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreatmentItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TreatmentItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>[]
          }
          upsert: {
            args: Prisma.TreatmentItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentItemPayload>
          }
          aggregate: {
            args: Prisma.TreatmentItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreatmentItem>
          }
          groupBy: {
            args: Prisma.TreatmentItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreatmentItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreatmentItemCountArgs<ExtArgs>
            result: $Utils.Optional<TreatmentItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentTreatmentPlan: {
        payload: Prisma.$PaymentTreatmentPlanPayload<ExtArgs>
        fields: Prisma.PaymentTreatmentPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentTreatmentPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTreatmentPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>
          }
          findFirst: {
            args: Prisma.PaymentTreatmentPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTreatmentPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>
          }
          findMany: {
            args: Prisma.PaymentTreatmentPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>[]
          }
          create: {
            args: Prisma.PaymentTreatmentPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>
          }
          createMany: {
            args: Prisma.PaymentTreatmentPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentTreatmentPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>[]
          }
          delete: {
            args: Prisma.PaymentTreatmentPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>
          }
          update: {
            args: Prisma.PaymentTreatmentPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>
          }
          deleteMany: {
            args: Prisma.PaymentTreatmentPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTreatmentPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentTreatmentPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>[]
          }
          upsert: {
            args: Prisma.PaymentTreatmentPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTreatmentPlanPayload>
          }
          aggregate: {
            args: Prisma.PaymentTreatmentPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentTreatmentPlan>
          }
          groupBy: {
            args: Prisma.PaymentTreatmentPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentTreatmentPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTreatmentPlanCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentTreatmentPlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      Specialty: {
        payload: Prisma.$SpecialtyPayload<ExtArgs>
        fields: Prisma.SpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findFirst: {
            args: Prisma.SpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findMany: {
            args: Prisma.SpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          create: {
            args: Prisma.SpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          createMany: {
            args: Prisma.SpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          delete: {
            args: Prisma.SpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          update: {
            args: Prisma.SpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.SpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecialtyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          upsert: {
            args: Prisma.SpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          aggregate: {
            args: Prisma.SpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialty>
          }
          groupBy: {
            args: Prisma.SpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyCountAggregateOutputType> | number
          }
        }
      }
      CID: {
        payload: Prisma.$CIDPayload<ExtArgs>
        fields: Prisma.CIDFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CIDFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CIDFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>
          }
          findFirst: {
            args: Prisma.CIDFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CIDFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>
          }
          findMany: {
            args: Prisma.CIDFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>[]
          }
          create: {
            args: Prisma.CIDCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>
          }
          createMany: {
            args: Prisma.CIDCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CIDCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>[]
          }
          delete: {
            args: Prisma.CIDDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>
          }
          update: {
            args: Prisma.CIDUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>
          }
          deleteMany: {
            args: Prisma.CIDDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CIDUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CIDUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>[]
          }
          upsert: {
            args: Prisma.CIDUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIDPayload>
          }
          aggregate: {
            args: Prisma.CIDAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCID>
          }
          groupBy: {
            args: Prisma.CIDGroupByArgs<ExtArgs>
            result: $Utils.Optional<CIDGroupByOutputType>[]
          }
          count: {
            args: Prisma.CIDCountArgs<ExtArgs>
            result: $Utils.Optional<CIDCountAggregateOutputType> | number
          }
        }
      }
      Procedure: {
        payload: Prisma.$ProcedurePayload<ExtArgs>
        fields: Prisma.ProcedureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findFirst: {
            args: Prisma.ProcedureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findMany: {
            args: Prisma.ProcedureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          create: {
            args: Prisma.ProcedureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          createMany: {
            args: Prisma.ProcedureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcedureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          delete: {
            args: Prisma.ProcedureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          update: {
            args: Prisma.ProcedureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          deleteMany: {
            args: Prisma.ProcedureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcedureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          upsert: {
            args: Prisma.ProcedureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          aggregate: {
            args: Prisma.ProcedureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedure>
          }
          groupBy: {
            args: Prisma.ProcedureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedureCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedureCountAggregateOutputType> | number
          }
        }
      }
      DentistProcedure: {
        payload: Prisma.$DentistProcedurePayload<ExtArgs>
        fields: Prisma.DentistProcedureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DentistProcedureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DentistProcedureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>
          }
          findFirst: {
            args: Prisma.DentistProcedureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DentistProcedureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>
          }
          findMany: {
            args: Prisma.DentistProcedureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>[]
          }
          create: {
            args: Prisma.DentistProcedureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>
          }
          createMany: {
            args: Prisma.DentistProcedureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DentistProcedureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>[]
          }
          delete: {
            args: Prisma.DentistProcedureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>
          }
          update: {
            args: Prisma.DentistProcedureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>
          }
          deleteMany: {
            args: Prisma.DentistProcedureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DentistProcedureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DentistProcedureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>[]
          }
          upsert: {
            args: Prisma.DentistProcedureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistProcedurePayload>
          }
          aggregate: {
            args: Prisma.DentistProcedureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDentistProcedure>
          }
          groupBy: {
            args: Prisma.DentistProcedureGroupByArgs<ExtArgs>
            result: $Utils.Optional<DentistProcedureGroupByOutputType>[]
          }
          count: {
            args: Prisma.DentistProcedureCountArgs<ExtArgs>
            result: $Utils.Optional<DentistProcedureCountAggregateOutputType> | number
          }
        }
      }
      DentistSpecialty: {
        payload: Prisma.$DentistSpecialtyPayload<ExtArgs>
        fields: Prisma.DentistSpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DentistSpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DentistSpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>
          }
          findFirst: {
            args: Prisma.DentistSpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DentistSpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>
          }
          findMany: {
            args: Prisma.DentistSpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>[]
          }
          create: {
            args: Prisma.DentistSpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>
          }
          createMany: {
            args: Prisma.DentistSpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DentistSpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>[]
          }
          delete: {
            args: Prisma.DentistSpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>
          }
          update: {
            args: Prisma.DentistSpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.DentistSpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DentistSpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DentistSpecialtyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>[]
          }
          upsert: {
            args: Prisma.DentistSpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DentistSpecialtyPayload>
          }
          aggregate: {
            args: Prisma.DentistSpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDentistSpecialty>
          }
          groupBy: {
            args: Prisma.DentistSpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DentistSpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DentistSpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<DentistSpecialtyCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      AttendanceCID: {
        payload: Prisma.$AttendanceCIDPayload<ExtArgs>
        fields: Prisma.AttendanceCIDFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceCIDFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceCIDFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>
          }
          findFirst: {
            args: Prisma.AttendanceCIDFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceCIDFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>
          }
          findMany: {
            args: Prisma.AttendanceCIDFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>[]
          }
          create: {
            args: Prisma.AttendanceCIDCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>
          }
          createMany: {
            args: Prisma.AttendanceCIDCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCIDCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>[]
          }
          delete: {
            args: Prisma.AttendanceCIDDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>
          }
          update: {
            args: Prisma.AttendanceCIDUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceCIDDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceCIDUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceCIDUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceCIDUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceCIDPayload>
          }
          aggregate: {
            args: Prisma.AttendanceCIDAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceCID>
          }
          groupBy: {
            args: Prisma.AttendanceCIDGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCIDGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCIDCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCIDCountAggregateOutputType> | number
          }
        }
      }
      AttendanceProcedure: {
        payload: Prisma.$AttendanceProcedurePayload<ExtArgs>
        fields: Prisma.AttendanceProcedureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceProcedureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceProcedureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>
          }
          findFirst: {
            args: Prisma.AttendanceProcedureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceProcedureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>
          }
          findMany: {
            args: Prisma.AttendanceProcedureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>[]
          }
          create: {
            args: Prisma.AttendanceProcedureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>
          }
          createMany: {
            args: Prisma.AttendanceProcedureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceProcedureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>[]
          }
          delete: {
            args: Prisma.AttendanceProcedureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>
          }
          update: {
            args: Prisma.AttendanceProcedureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceProcedureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceProcedureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceProcedureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceProcedureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceProcedurePayload>
          }
          aggregate: {
            args: Prisma.AttendanceProcedureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceProcedure>
          }
          groupBy: {
            args: Prisma.AttendanceProcedureGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceProcedureGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceProcedureCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceProcedureCountAggregateOutputType> | number
          }
        }
      }
      AttendanceOdontogram: {
        payload: Prisma.$AttendanceOdontogramPayload<ExtArgs>
        fields: Prisma.AttendanceOdontogramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceOdontogramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceOdontogramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>
          }
          findFirst: {
            args: Prisma.AttendanceOdontogramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceOdontogramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>
          }
          findMany: {
            args: Prisma.AttendanceOdontogramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>[]
          }
          create: {
            args: Prisma.AttendanceOdontogramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>
          }
          createMany: {
            args: Prisma.AttendanceOdontogramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceOdontogramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>[]
          }
          delete: {
            args: Prisma.AttendanceOdontogramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>
          }
          update: {
            args: Prisma.AttendanceOdontogramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceOdontogramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceOdontogramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceOdontogramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceOdontogramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceOdontogramPayload>
          }
          aggregate: {
            args: Prisma.AttendanceOdontogramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceOdontogram>
          }
          groupBy: {
            args: Prisma.AttendanceOdontogramGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceOdontogramGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceOdontogramCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceOdontogramCountAggregateOutputType> | number
          }
        }
      }
      ClinicalDocument: {
        payload: Prisma.$ClinicalDocumentPayload<ExtArgs>
        fields: Prisma.ClinicalDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicalDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicalDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>
          }
          findFirst: {
            args: Prisma.ClinicalDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicalDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>
          }
          findMany: {
            args: Prisma.ClinicalDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>[]
          }
          create: {
            args: Prisma.ClinicalDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>
          }
          createMany: {
            args: Prisma.ClinicalDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicalDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>[]
          }
          delete: {
            args: Prisma.ClinicalDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>
          }
          update: {
            args: Prisma.ClinicalDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ClinicalDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicalDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicalDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>[]
          }
          upsert: {
            args: Prisma.ClinicalDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalDocumentPayload>
          }
          aggregate: {
            args: Prisma.ClinicalDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicalDocument>
          }
          groupBy: {
            args: Prisma.ClinicalDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicalDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicalDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicalDocumentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    clinic?: ClinicOmit
    user?: UserOmit
    dentist?: DentistOmit
    patient?: PatientOmit
    appointment?: AppointmentOmit
    record?: RecordOmit
    treatmentPlan?: TreatmentPlanOmit
    treatmentItem?: TreatmentItemOmit
    payment?: PaymentOmit
    paymentTreatmentPlan?: PaymentTreatmentPlanOmit
    subscription?: SubscriptionOmit
    auditLog?: AuditLogOmit
    inventoryItem?: InventoryItemOmit
    inventoryMovement?: InventoryMovementOmit
    specialty?: SpecialtyOmit
    cID?: CIDOmit
    procedure?: ProcedureOmit
    dentistProcedure?: DentistProcedureOmit
    dentistSpecialty?: DentistSpecialtyOmit
    attendance?: AttendanceOmit
    attendanceCID?: AttendanceCIDOmit
    attendanceProcedure?: AttendanceProcedureOmit
    attendanceOdontogram?: AttendanceOdontogramOmit
    clinicalDocument?: ClinicalDocumentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClinicCountOutputType
   */

  export type ClinicCountOutputType = {
    users: number
    dentists: number
    patients: number
    appointments: number
    records: number
    treatmentPlans: number
    payments: number
    auditLogs: number
    inventoryItems: number
    inventoryMovements: number
    procedures: number
    attendances: number
  }

  export type ClinicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ClinicCountOutputTypeCountUsersArgs
    dentists?: boolean | ClinicCountOutputTypeCountDentistsArgs
    patients?: boolean | ClinicCountOutputTypeCountPatientsArgs
    appointments?: boolean | ClinicCountOutputTypeCountAppointmentsArgs
    records?: boolean | ClinicCountOutputTypeCountRecordsArgs
    treatmentPlans?: boolean | ClinicCountOutputTypeCountTreatmentPlansArgs
    payments?: boolean | ClinicCountOutputTypeCountPaymentsArgs
    auditLogs?: boolean | ClinicCountOutputTypeCountAuditLogsArgs
    inventoryItems?: boolean | ClinicCountOutputTypeCountInventoryItemsArgs
    inventoryMovements?: boolean | ClinicCountOutputTypeCountInventoryMovementsArgs
    procedures?: boolean | ClinicCountOutputTypeCountProceduresArgs
    attendances?: boolean | ClinicCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicCountOutputType
     */
    select?: ClinicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountDentistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DentistWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecordWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountTreatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentPlanWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
    inventoryMovements: number
    attendances: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    inventoryMovements?: boolean | UserCountOutputTypeCountInventoryMovementsArgs
    attendances?: boolean | UserCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type DentistCountOutputType
   */

  export type DentistCountOutputType = {
    appointments: number
    records: number
    treatmentPlans: number
    dentistProcedures: number
    dentistSpecialties: number
    attendances: number
    attendanceCids: number
    attendanceProcedures: number
  }

  export type DentistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | DentistCountOutputTypeCountAppointmentsArgs
    records?: boolean | DentistCountOutputTypeCountRecordsArgs
    treatmentPlans?: boolean | DentistCountOutputTypeCountTreatmentPlansArgs
    dentistProcedures?: boolean | DentistCountOutputTypeCountDentistProceduresArgs
    dentistSpecialties?: boolean | DentistCountOutputTypeCountDentistSpecialtiesArgs
    attendances?: boolean | DentistCountOutputTypeCountAttendancesArgs
    attendanceCids?: boolean | DentistCountOutputTypeCountAttendanceCidsArgs
    attendanceProcedures?: boolean | DentistCountOutputTypeCountAttendanceProceduresArgs
  }

  // Custom InputTypes
  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistCountOutputType
     */
    select?: DentistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecordWhereInput
  }

  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeCountTreatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentPlanWhereInput
  }

  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeCountDentistProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DentistProcedureWhereInput
  }

  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeCountDentistSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DentistSpecialtyWhereInput
  }

  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeCountAttendanceCidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceCIDWhereInput
  }

  /**
   * DentistCountOutputType without action
   */
  export type DentistCountOutputTypeCountAttendanceProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceProcedureWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    records: number
    treatmentPlans: number
    payments: number
    attendances: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    records?: boolean | PatientCountOutputTypeCountRecordsArgs
    treatmentPlans?: boolean | PatientCountOutputTypeCountTreatmentPlansArgs
    payments?: boolean | PatientCountOutputTypeCountPaymentsArgs
    attendances?: boolean | PatientCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecordWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTreatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentPlanWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    inventoryMovements: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryMovements?: boolean | AppointmentCountOutputTypeCountInventoryMovementsArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type TreatmentPlanCountOutputType
   */

  export type TreatmentPlanCountOutputType = {
    items: number
    paymentTreatmentPlans: number
  }

  export type TreatmentPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TreatmentPlanCountOutputTypeCountItemsArgs
    paymentTreatmentPlans?: boolean | TreatmentPlanCountOutputTypeCountPaymentTreatmentPlansArgs
  }

  // Custom InputTypes
  /**
   * TreatmentPlanCountOutputType without action
   */
  export type TreatmentPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlanCountOutputType
     */
    select?: TreatmentPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TreatmentPlanCountOutputType without action
   */
  export type TreatmentPlanCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentItemWhereInput
  }

  /**
   * TreatmentPlanCountOutputType without action
   */
  export type TreatmentPlanCountOutputTypeCountPaymentTreatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTreatmentPlanWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    paymentTreatmentPlans: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentTreatmentPlans?: boolean | PaymentCountOutputTypeCountPaymentTreatmentPlansArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountPaymentTreatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTreatmentPlanWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    movements: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | InventoryItemCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type SpecialtyCountOutputType
   */

  export type SpecialtyCountOutputType = {
    procedures: number
    dentistSpecialties: number
  }

  export type SpecialtyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedures?: boolean | SpecialtyCountOutputTypeCountProceduresArgs
    dentistSpecialties?: boolean | SpecialtyCountOutputTypeCountDentistSpecialtiesArgs
  }

  // Custom InputTypes
  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialtyCountOutputType
     */
    select?: SpecialtyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeCountProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
  }

  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeCountDentistSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DentistSpecialtyWhereInput
  }


  /**
   * Count Type ProcedureCountOutputType
   */

  export type ProcedureCountOutputType = {
    dentistProcedures: number
    appointments: number
    attendanceProcedures: number
    treatmentItems: number
  }

  export type ProcedureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dentistProcedures?: boolean | ProcedureCountOutputTypeCountDentistProceduresArgs
    appointments?: boolean | ProcedureCountOutputTypeCountAppointmentsArgs
    attendanceProcedures?: boolean | ProcedureCountOutputTypeCountAttendanceProceduresArgs
    treatmentItems?: boolean | ProcedureCountOutputTypeCountTreatmentItemsArgs
  }

  // Custom InputTypes
  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureCountOutputType
     */
    select?: ProcedureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeCountDentistProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DentistProcedureWhereInput
  }

  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeCountAttendanceProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceProcedureWhereInput
  }

  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeCountTreatmentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentItemWhereInput
  }


  /**
   * Count Type AttendanceCountOutputType
   */

  export type AttendanceCountOutputType = {
    cids: number
    procedures: number
    documents: number
  }

  export type AttendanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cids?: boolean | AttendanceCountOutputTypeCountCidsArgs
    procedures?: boolean | AttendanceCountOutputTypeCountProceduresArgs
    documents?: boolean | AttendanceCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCountOutputType
     */
    select?: AttendanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeCountCidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceCIDWhereInput
  }

  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeCountProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceProcedureWhereInput
  }

  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalDocumentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Clinic
   */

  export type AggregateClinic = {
    _count: ClinicCountAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  export type ClinicMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinic to aggregate.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clinics
    **/
    _count?: true | ClinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicMaxAggregateInputType
  }

  export type GetClinicAggregateType<T extends ClinicAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic[P]>
      : GetScalarType<T[P], AggregateClinic[P]>
  }




  export type ClinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicWhereInput
    orderBy?: ClinicOrderByWithAggregationInput | ClinicOrderByWithAggregationInput[]
    by: ClinicScalarFieldEnum[] | ClinicScalarFieldEnum
    having?: ClinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicCountAggregateInputType | true
    _min?: ClinicMinAggregateInputType
    _max?: ClinicMaxAggregateInputType
  }

  export type ClinicGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClinicCountAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  type GetClinicGroupByPayload<T extends ClinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicGroupByOutputType[P]>
        }
      >
    >


  export type ClinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Clinic$usersArgs<ExtArgs>
    dentists?: boolean | Clinic$dentistsArgs<ExtArgs>
    patients?: boolean | Clinic$patientsArgs<ExtArgs>
    appointments?: boolean | Clinic$appointmentsArgs<ExtArgs>
    records?: boolean | Clinic$recordsArgs<ExtArgs>
    treatmentPlans?: boolean | Clinic$treatmentPlansArgs<ExtArgs>
    payments?: boolean | Clinic$paymentsArgs<ExtArgs>
    subscription?: boolean | Clinic$subscriptionArgs<ExtArgs>
    auditLogs?: boolean | Clinic$auditLogsArgs<ExtArgs>
    inventoryItems?: boolean | Clinic$inventoryItemsArgs<ExtArgs>
    inventoryMovements?: boolean | Clinic$inventoryMovementsArgs<ExtArgs>
    procedures?: boolean | Clinic$proceduresArgs<ExtArgs>
    attendances?: boolean | Clinic$attendancesArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["clinic"]>
  export type ClinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Clinic$usersArgs<ExtArgs>
    dentists?: boolean | Clinic$dentistsArgs<ExtArgs>
    patients?: boolean | Clinic$patientsArgs<ExtArgs>
    appointments?: boolean | Clinic$appointmentsArgs<ExtArgs>
    records?: boolean | Clinic$recordsArgs<ExtArgs>
    treatmentPlans?: boolean | Clinic$treatmentPlansArgs<ExtArgs>
    payments?: boolean | Clinic$paymentsArgs<ExtArgs>
    subscription?: boolean | Clinic$subscriptionArgs<ExtArgs>
    auditLogs?: boolean | Clinic$auditLogsArgs<ExtArgs>
    inventoryItems?: boolean | Clinic$inventoryItemsArgs<ExtArgs>
    inventoryMovements?: boolean | Clinic$inventoryMovementsArgs<ExtArgs>
    procedures?: boolean | Clinic$proceduresArgs<ExtArgs>
    attendances?: boolean | Clinic$attendancesArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClinicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinic"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      dentists: Prisma.$DentistPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      records: Prisma.$RecordPayload<ExtArgs>[]
      treatmentPlans: Prisma.$TreatmentPlanPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      procedures: Prisma.$ProcedurePayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinic"]>
    composites: {}
  }

  type ClinicGetPayload<S extends boolean | null | undefined | ClinicDefaultArgs> = $Result.GetResult<Prisma.$ClinicPayload, S>

  type ClinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicCountAggregateInputType | true
    }

  export interface ClinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clinic'], meta: { name: 'Clinic' } }
    /**
     * Find zero or one Clinic that matches the filter.
     * @param {ClinicFindUniqueArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicFindUniqueArgs>(args: SelectSubset<T, ClinicFindUniqueArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clinic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicFindUniqueOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicFindFirstArgs>(args?: SelectSubset<T, ClinicFindFirstArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinics
     * const clinics = await prisma.clinic.findMany()
     * 
     * // Get first 10 Clinics
     * const clinics = await prisma.clinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicWithIdOnly = await prisma.clinic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicFindManyArgs>(args?: SelectSubset<T, ClinicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clinic.
     * @param {ClinicCreateArgs} args - Arguments to create a Clinic.
     * @example
     * // Create one Clinic
     * const Clinic = await prisma.clinic.create({
     *   data: {
     *     // ... data to create a Clinic
     *   }
     * })
     * 
     */
    create<T extends ClinicCreateArgs>(args: SelectSubset<T, ClinicCreateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clinics.
     * @param {ClinicCreateManyArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicCreateManyArgs>(args?: SelectSubset<T, ClinicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinics and returns the data saved in the database.
     * @param {ClinicCreateManyAndReturnArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clinic.
     * @param {ClinicDeleteArgs} args - Arguments to delete one Clinic.
     * @example
     * // Delete one Clinic
     * const Clinic = await prisma.clinic.delete({
     *   where: {
     *     // ... filter to delete one Clinic
     *   }
     * })
     * 
     */
    delete<T extends ClinicDeleteArgs>(args: SelectSubset<T, ClinicDeleteArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clinic.
     * @param {ClinicUpdateArgs} args - Arguments to update one Clinic.
     * @example
     * // Update one Clinic
     * const clinic = await prisma.clinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicUpdateArgs>(args: SelectSubset<T, ClinicUpdateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clinics.
     * @param {ClinicDeleteManyArgs} args - Arguments to filter Clinics to delete.
     * @example
     * // Delete a few Clinics
     * const { count } = await prisma.clinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicDeleteManyArgs>(args?: SelectSubset<T, ClinicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicUpdateManyArgs>(args: SelectSubset<T, ClinicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics and returns the data updated in the database.
     * @param {ClinicUpdateManyAndReturnArgs} args - Arguments to update many Clinics.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clinic.
     * @param {ClinicUpsertArgs} args - Arguments to update or create a Clinic.
     * @example
     * // Update or create a Clinic
     * const clinic = await prisma.clinic.upsert({
     *   create: {
     *     // ... data to create a Clinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic we want to update
     *   }
     * })
     */
    upsert<T extends ClinicUpsertArgs>(args: SelectSubset<T, ClinicUpsertArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicCountArgs} args - Arguments to filter Clinics to count.
     * @example
     * // Count the number of Clinics
     * const count = await prisma.clinic.count({
     *   where: {
     *     // ... the filter for the Clinics we want to count
     *   }
     * })
    **/
    count<T extends ClinicCountArgs>(
      args?: Subset<T, ClinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAggregateArgs>(args: Subset<T, ClinicAggregateArgs>): Prisma.PrismaPromise<GetClinicAggregateType<T>>

    /**
     * Group by Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicGroupByArgs['orderBy'] }
        : { orderBy?: ClinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clinic model
   */
  readonly fields: ClinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Clinic$usersArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dentists<T extends Clinic$dentistsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$dentistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patients<T extends Clinic$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Clinic$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    records<T extends Clinic$recordsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treatmentPlans<T extends Clinic$treatmentPlansArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$treatmentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Clinic$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Clinic$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditLogs<T extends Clinic$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Clinic$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryMovements<T extends Clinic$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    procedures<T extends Clinic$proceduresArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$proceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Clinic$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clinic model
   */
  interface ClinicFieldRefs {
    readonly id: FieldRef<"Clinic", 'String'>
    readonly name: FieldRef<"Clinic", 'String'>
    readonly email: FieldRef<"Clinic", 'String'>
    readonly phone: FieldRef<"Clinic", 'String'>
    readonly address: FieldRef<"Clinic", 'String'>
    readonly createdAt: FieldRef<"Clinic", 'DateTime'>
    readonly updatedAt: FieldRef<"Clinic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Clinic findUnique
   */
  export type ClinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findUniqueOrThrow
   */
  export type ClinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findFirst
   */
  export type ClinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findFirstOrThrow
   */
  export type ClinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findMany
   */
  export type ClinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinics to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic create
   */
  export type ClinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to create a Clinic.
     */
    data: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
  }

  /**
   * Clinic createMany
   */
  export type ClinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinic createManyAndReturn
   */
  export type ClinicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinic update
   */
  export type ClinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to update a Clinic.
     */
    data: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
    /**
     * Choose, which Clinic to update.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic updateMany
   */
  export type ClinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to update.
     */
    limit?: number
  }

  /**
   * Clinic updateManyAndReturn
   */
  export type ClinicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to update.
     */
    limit?: number
  }

  /**
   * Clinic upsert
   */
  export type ClinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The filter to search for the Clinic to update in case it exists.
     */
    where: ClinicWhereUniqueInput
    /**
     * In case the Clinic found by the `where` argument doesn't exist, create a new Clinic with this data.
     */
    create: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
    /**
     * In case the Clinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
  }

  /**
   * Clinic delete
   */
  export type ClinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter which Clinic to delete.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic deleteMany
   */
  export type ClinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinics to delete
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to delete.
     */
    limit?: number
  }

  /**
   * Clinic.users
   */
  export type Clinic$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Clinic.dentists
   */
  export type Clinic$dentistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    where?: DentistWhereInput
    orderBy?: DentistOrderByWithRelationInput | DentistOrderByWithRelationInput[]
    cursor?: DentistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DentistScalarFieldEnum | DentistScalarFieldEnum[]
  }

  /**
   * Clinic.patients
   */
  export type Clinic$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Clinic.appointments
   */
  export type Clinic$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Clinic.records
   */
  export type Clinic$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    where?: RecordWhereInput
    orderBy?: RecordOrderByWithRelationInput | RecordOrderByWithRelationInput[]
    cursor?: RecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordScalarFieldEnum | RecordScalarFieldEnum[]
  }

  /**
   * Clinic.treatmentPlans
   */
  export type Clinic$treatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    where?: TreatmentPlanWhereInput
    orderBy?: TreatmentPlanOrderByWithRelationInput | TreatmentPlanOrderByWithRelationInput[]
    cursor?: TreatmentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentPlanScalarFieldEnum | TreatmentPlanScalarFieldEnum[]
  }

  /**
   * Clinic.payments
   */
  export type Clinic$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Clinic.subscription
   */
  export type Clinic$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Clinic.auditLogs
   */
  export type Clinic$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Clinic.inventoryItems
   */
  export type Clinic$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Clinic.inventoryMovements
   */
  export type Clinic$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Clinic.procedures
   */
  export type Clinic$proceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    cursor?: ProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Clinic.attendances
   */
  export type Clinic$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Clinic without action
   */
  export type ClinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    clinicId: number
    name: number
    email: number
    passwordHash: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    clinicId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    dentist?: boolean | User$dentistArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    clinicId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "name" | "email" | "passwordHash" | "role" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    dentist?: boolean | User$dentistArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      dentist: Prisma.$DentistPayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      name: string
      email: string
      passwordHash: string
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dentist<T extends User$dentistArgs<ExtArgs> = {}>(args?: Subset<T, User$dentistArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryMovements<T extends User$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends User$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly clinicId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.dentist
   */
  export type User$dentistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    where?: DentistWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.inventoryMovements
   */
  export type User$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * User.attendances
   */
  export type User$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Dentist
   */

  export type AggregateDentist = {
    _count: DentistCountAggregateOutputType | null
    _avg: DentistAvgAggregateOutputType | null
    _sum: DentistSumAggregateOutputType | null
    _min: DentistMinAggregateOutputType | null
    _max: DentistMaxAggregateOutputType | null
  }

  export type DentistAvgAggregateOutputType = {
    commission: Decimal | null
  }

  export type DentistSumAggregateOutputType = {
    commission: Decimal | null
  }

  export type DentistMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    userId: string | null
    cro: string | null
    specialty: string | null
    commission: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DentistMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    userId: string | null
    cro: string | null
    specialty: string | null
    commission: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DentistCountAggregateOutputType = {
    id: number
    clinicId: number
    userId: number
    cro: number
    specialty: number
    workingHours: number
    bankInfo: number
    contactInfo: number
    personalInfo: number
    commission: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DentistAvgAggregateInputType = {
    commission?: true
  }

  export type DentistSumAggregateInputType = {
    commission?: true
  }

  export type DentistMinAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    cro?: true
    specialty?: true
    commission?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DentistMaxAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    cro?: true
    specialty?: true
    commission?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DentistCountAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    cro?: true
    specialty?: true
    workingHours?: true
    bankInfo?: true
    contactInfo?: true
    personalInfo?: true
    commission?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DentistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dentist to aggregate.
     */
    where?: DentistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dentists to fetch.
     */
    orderBy?: DentistOrderByWithRelationInput | DentistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DentistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dentists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dentists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dentists
    **/
    _count?: true | DentistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DentistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DentistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DentistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DentistMaxAggregateInputType
  }

  export type GetDentistAggregateType<T extends DentistAggregateArgs> = {
        [P in keyof T & keyof AggregateDentist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDentist[P]>
      : GetScalarType<T[P], AggregateDentist[P]>
  }




  export type DentistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DentistWhereInput
    orderBy?: DentistOrderByWithAggregationInput | DentistOrderByWithAggregationInput[]
    by: DentistScalarFieldEnum[] | DentistScalarFieldEnum
    having?: DentistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DentistCountAggregateInputType | true
    _avg?: DentistAvgAggregateInputType
    _sum?: DentistSumAggregateInputType
    _min?: DentistMinAggregateInputType
    _max?: DentistMaxAggregateInputType
  }

  export type DentistGroupByOutputType = {
    id: string
    clinicId: string
    userId: string
    cro: string
    specialty: string | null
    workingHours: JsonValue | null
    bankInfo: JsonValue | null
    contactInfo: JsonValue | null
    personalInfo: JsonValue | null
    commission: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: DentistCountAggregateOutputType | null
    _avg: DentistAvgAggregateOutputType | null
    _sum: DentistSumAggregateOutputType | null
    _min: DentistMinAggregateOutputType | null
    _max: DentistMaxAggregateOutputType | null
  }

  type GetDentistGroupByPayload<T extends DentistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DentistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DentistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DentistGroupByOutputType[P]>
            : GetScalarType<T[P], DentistGroupByOutputType[P]>
        }
      >
    >


  export type DentistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    cro?: boolean
    specialty?: boolean
    workingHours?: boolean
    bankInfo?: boolean
    contactInfo?: boolean
    personalInfo?: boolean
    commission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointments?: boolean | Dentist$appointmentsArgs<ExtArgs>
    records?: boolean | Dentist$recordsArgs<ExtArgs>
    treatmentPlans?: boolean | Dentist$treatmentPlansArgs<ExtArgs>
    dentistProcedures?: boolean | Dentist$dentistProceduresArgs<ExtArgs>
    dentistSpecialties?: boolean | Dentist$dentistSpecialtiesArgs<ExtArgs>
    attendances?: boolean | Dentist$attendancesArgs<ExtArgs>
    attendanceCids?: boolean | Dentist$attendanceCidsArgs<ExtArgs>
    attendanceProcedures?: boolean | Dentist$attendanceProceduresArgs<ExtArgs>
    _count?: boolean | DentistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentist"]>

  export type DentistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    cro?: boolean
    specialty?: boolean
    workingHours?: boolean
    bankInfo?: boolean
    contactInfo?: boolean
    personalInfo?: boolean
    commission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentist"]>

  export type DentistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    cro?: boolean
    specialty?: boolean
    workingHours?: boolean
    bankInfo?: boolean
    contactInfo?: boolean
    personalInfo?: boolean
    commission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentist"]>

  export type DentistSelectScalar = {
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    cro?: boolean
    specialty?: boolean
    workingHours?: boolean
    bankInfo?: boolean
    contactInfo?: boolean
    personalInfo?: boolean
    commission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DentistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "userId" | "cro" | "specialty" | "workingHours" | "bankInfo" | "contactInfo" | "personalInfo" | "commission" | "createdAt" | "updatedAt", ExtArgs["result"]["dentist"]>
  export type DentistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointments?: boolean | Dentist$appointmentsArgs<ExtArgs>
    records?: boolean | Dentist$recordsArgs<ExtArgs>
    treatmentPlans?: boolean | Dentist$treatmentPlansArgs<ExtArgs>
    dentistProcedures?: boolean | Dentist$dentistProceduresArgs<ExtArgs>
    dentistSpecialties?: boolean | Dentist$dentistSpecialtiesArgs<ExtArgs>
    attendances?: boolean | Dentist$attendancesArgs<ExtArgs>
    attendanceCids?: boolean | Dentist$attendanceCidsArgs<ExtArgs>
    attendanceProcedures?: boolean | Dentist$attendanceProceduresArgs<ExtArgs>
    _count?: boolean | DentistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DentistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DentistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DentistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dentist"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      records: Prisma.$RecordPayload<ExtArgs>[]
      treatmentPlans: Prisma.$TreatmentPlanPayload<ExtArgs>[]
      dentistProcedures: Prisma.$DentistProcedurePayload<ExtArgs>[]
      dentistSpecialties: Prisma.$DentistSpecialtyPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      attendanceCids: Prisma.$AttendanceCIDPayload<ExtArgs>[]
      attendanceProcedures: Prisma.$AttendanceProcedurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      userId: string
      cro: string
      specialty: string | null
      workingHours: Prisma.JsonValue | null
      bankInfo: Prisma.JsonValue | null
      contactInfo: Prisma.JsonValue | null
      personalInfo: Prisma.JsonValue | null
      commission: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dentist"]>
    composites: {}
  }

  type DentistGetPayload<S extends boolean | null | undefined | DentistDefaultArgs> = $Result.GetResult<Prisma.$DentistPayload, S>

  type DentistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DentistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DentistCountAggregateInputType | true
    }

  export interface DentistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dentist'], meta: { name: 'Dentist' } }
    /**
     * Find zero or one Dentist that matches the filter.
     * @param {DentistFindUniqueArgs} args - Arguments to find a Dentist
     * @example
     * // Get one Dentist
     * const dentist = await prisma.dentist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DentistFindUniqueArgs>(args: SelectSubset<T, DentistFindUniqueArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dentist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DentistFindUniqueOrThrowArgs} args - Arguments to find a Dentist
     * @example
     * // Get one Dentist
     * const dentist = await prisma.dentist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DentistFindUniqueOrThrowArgs>(args: SelectSubset<T, DentistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dentist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistFindFirstArgs} args - Arguments to find a Dentist
     * @example
     * // Get one Dentist
     * const dentist = await prisma.dentist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DentistFindFirstArgs>(args?: SelectSubset<T, DentistFindFirstArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dentist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistFindFirstOrThrowArgs} args - Arguments to find a Dentist
     * @example
     * // Get one Dentist
     * const dentist = await prisma.dentist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DentistFindFirstOrThrowArgs>(args?: SelectSubset<T, DentistFindFirstOrThrowArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dentists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dentists
     * const dentists = await prisma.dentist.findMany()
     * 
     * // Get first 10 Dentists
     * const dentists = await prisma.dentist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dentistWithIdOnly = await prisma.dentist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DentistFindManyArgs>(args?: SelectSubset<T, DentistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dentist.
     * @param {DentistCreateArgs} args - Arguments to create a Dentist.
     * @example
     * // Create one Dentist
     * const Dentist = await prisma.dentist.create({
     *   data: {
     *     // ... data to create a Dentist
     *   }
     * })
     * 
     */
    create<T extends DentistCreateArgs>(args: SelectSubset<T, DentistCreateArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dentists.
     * @param {DentistCreateManyArgs} args - Arguments to create many Dentists.
     * @example
     * // Create many Dentists
     * const dentist = await prisma.dentist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DentistCreateManyArgs>(args?: SelectSubset<T, DentistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dentists and returns the data saved in the database.
     * @param {DentistCreateManyAndReturnArgs} args - Arguments to create many Dentists.
     * @example
     * // Create many Dentists
     * const dentist = await prisma.dentist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dentists and only return the `id`
     * const dentistWithIdOnly = await prisma.dentist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DentistCreateManyAndReturnArgs>(args?: SelectSubset<T, DentistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dentist.
     * @param {DentistDeleteArgs} args - Arguments to delete one Dentist.
     * @example
     * // Delete one Dentist
     * const Dentist = await prisma.dentist.delete({
     *   where: {
     *     // ... filter to delete one Dentist
     *   }
     * })
     * 
     */
    delete<T extends DentistDeleteArgs>(args: SelectSubset<T, DentistDeleteArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dentist.
     * @param {DentistUpdateArgs} args - Arguments to update one Dentist.
     * @example
     * // Update one Dentist
     * const dentist = await prisma.dentist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DentistUpdateArgs>(args: SelectSubset<T, DentistUpdateArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dentists.
     * @param {DentistDeleteManyArgs} args - Arguments to filter Dentists to delete.
     * @example
     * // Delete a few Dentists
     * const { count } = await prisma.dentist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DentistDeleteManyArgs>(args?: SelectSubset<T, DentistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dentists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dentists
     * const dentist = await prisma.dentist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DentistUpdateManyArgs>(args: SelectSubset<T, DentistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dentists and returns the data updated in the database.
     * @param {DentistUpdateManyAndReturnArgs} args - Arguments to update many Dentists.
     * @example
     * // Update many Dentists
     * const dentist = await prisma.dentist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dentists and only return the `id`
     * const dentistWithIdOnly = await prisma.dentist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DentistUpdateManyAndReturnArgs>(args: SelectSubset<T, DentistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dentist.
     * @param {DentistUpsertArgs} args - Arguments to update or create a Dentist.
     * @example
     * // Update or create a Dentist
     * const dentist = await prisma.dentist.upsert({
     *   create: {
     *     // ... data to create a Dentist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dentist we want to update
     *   }
     * })
     */
    upsert<T extends DentistUpsertArgs>(args: SelectSubset<T, DentistUpsertArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dentists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistCountArgs} args - Arguments to filter Dentists to count.
     * @example
     * // Count the number of Dentists
     * const count = await prisma.dentist.count({
     *   where: {
     *     // ... the filter for the Dentists we want to count
     *   }
     * })
    **/
    count<T extends DentistCountArgs>(
      args?: Subset<T, DentistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DentistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dentist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DentistAggregateArgs>(args: Subset<T, DentistAggregateArgs>): Prisma.PrismaPromise<GetDentistAggregateType<T>>

    /**
     * Group by Dentist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DentistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DentistGroupByArgs['orderBy'] }
        : { orderBy?: DentistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DentistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDentistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dentist model
   */
  readonly fields: DentistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dentist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DentistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Dentist$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Dentist$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    records<T extends Dentist$recordsArgs<ExtArgs> = {}>(args?: Subset<T, Dentist$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treatmentPlans<T extends Dentist$treatmentPlansArgs<ExtArgs> = {}>(args?: Subset<T, Dentist$treatmentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dentistProcedures<T extends Dentist$dentistProceduresArgs<ExtArgs> = {}>(args?: Subset<T, Dentist$dentistProceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dentistSpecialties<T extends Dentist$dentistSpecialtiesArgs<ExtArgs> = {}>(args?: Subset<T, Dentist$dentistSpecialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Dentist$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Dentist$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceCids<T extends Dentist$attendanceCidsArgs<ExtArgs> = {}>(args?: Subset<T, Dentist$attendanceCidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceProcedures<T extends Dentist$attendanceProceduresArgs<ExtArgs> = {}>(args?: Subset<T, Dentist$attendanceProceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dentist model
   */
  interface DentistFieldRefs {
    readonly id: FieldRef<"Dentist", 'String'>
    readonly clinicId: FieldRef<"Dentist", 'String'>
    readonly userId: FieldRef<"Dentist", 'String'>
    readonly cro: FieldRef<"Dentist", 'String'>
    readonly specialty: FieldRef<"Dentist", 'String'>
    readonly workingHours: FieldRef<"Dentist", 'Json'>
    readonly bankInfo: FieldRef<"Dentist", 'Json'>
    readonly contactInfo: FieldRef<"Dentist", 'Json'>
    readonly personalInfo: FieldRef<"Dentist", 'Json'>
    readonly commission: FieldRef<"Dentist", 'Decimal'>
    readonly createdAt: FieldRef<"Dentist", 'DateTime'>
    readonly updatedAt: FieldRef<"Dentist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dentist findUnique
   */
  export type DentistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * Filter, which Dentist to fetch.
     */
    where: DentistWhereUniqueInput
  }

  /**
   * Dentist findUniqueOrThrow
   */
  export type DentistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * Filter, which Dentist to fetch.
     */
    where: DentistWhereUniqueInput
  }

  /**
   * Dentist findFirst
   */
  export type DentistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * Filter, which Dentist to fetch.
     */
    where?: DentistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dentists to fetch.
     */
    orderBy?: DentistOrderByWithRelationInput | DentistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dentists.
     */
    cursor?: DentistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dentists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dentists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dentists.
     */
    distinct?: DentistScalarFieldEnum | DentistScalarFieldEnum[]
  }

  /**
   * Dentist findFirstOrThrow
   */
  export type DentistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * Filter, which Dentist to fetch.
     */
    where?: DentistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dentists to fetch.
     */
    orderBy?: DentistOrderByWithRelationInput | DentistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dentists.
     */
    cursor?: DentistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dentists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dentists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dentists.
     */
    distinct?: DentistScalarFieldEnum | DentistScalarFieldEnum[]
  }

  /**
   * Dentist findMany
   */
  export type DentistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * Filter, which Dentists to fetch.
     */
    where?: DentistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dentists to fetch.
     */
    orderBy?: DentistOrderByWithRelationInput | DentistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dentists.
     */
    cursor?: DentistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dentists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dentists.
     */
    skip?: number
    distinct?: DentistScalarFieldEnum | DentistScalarFieldEnum[]
  }

  /**
   * Dentist create
   */
  export type DentistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * The data needed to create a Dentist.
     */
    data: XOR<DentistCreateInput, DentistUncheckedCreateInput>
  }

  /**
   * Dentist createMany
   */
  export type DentistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dentists.
     */
    data: DentistCreateManyInput | DentistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dentist createManyAndReturn
   */
  export type DentistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * The data used to create many Dentists.
     */
    data: DentistCreateManyInput | DentistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dentist update
   */
  export type DentistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * The data needed to update a Dentist.
     */
    data: XOR<DentistUpdateInput, DentistUncheckedUpdateInput>
    /**
     * Choose, which Dentist to update.
     */
    where: DentistWhereUniqueInput
  }

  /**
   * Dentist updateMany
   */
  export type DentistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dentists.
     */
    data: XOR<DentistUpdateManyMutationInput, DentistUncheckedUpdateManyInput>
    /**
     * Filter which Dentists to update
     */
    where?: DentistWhereInput
    /**
     * Limit how many Dentists to update.
     */
    limit?: number
  }

  /**
   * Dentist updateManyAndReturn
   */
  export type DentistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * The data used to update Dentists.
     */
    data: XOR<DentistUpdateManyMutationInput, DentistUncheckedUpdateManyInput>
    /**
     * Filter which Dentists to update
     */
    where?: DentistWhereInput
    /**
     * Limit how many Dentists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dentist upsert
   */
  export type DentistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * The filter to search for the Dentist to update in case it exists.
     */
    where: DentistWhereUniqueInput
    /**
     * In case the Dentist found by the `where` argument doesn't exist, create a new Dentist with this data.
     */
    create: XOR<DentistCreateInput, DentistUncheckedCreateInput>
    /**
     * In case the Dentist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DentistUpdateInput, DentistUncheckedUpdateInput>
  }

  /**
   * Dentist delete
   */
  export type DentistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    /**
     * Filter which Dentist to delete.
     */
    where: DentistWhereUniqueInput
  }

  /**
   * Dentist deleteMany
   */
  export type DentistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dentists to delete
     */
    where?: DentistWhereInput
    /**
     * Limit how many Dentists to delete.
     */
    limit?: number
  }

  /**
   * Dentist.appointments
   */
  export type Dentist$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Dentist.records
   */
  export type Dentist$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    where?: RecordWhereInput
    orderBy?: RecordOrderByWithRelationInput | RecordOrderByWithRelationInput[]
    cursor?: RecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordScalarFieldEnum | RecordScalarFieldEnum[]
  }

  /**
   * Dentist.treatmentPlans
   */
  export type Dentist$treatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    where?: TreatmentPlanWhereInput
    orderBy?: TreatmentPlanOrderByWithRelationInput | TreatmentPlanOrderByWithRelationInput[]
    cursor?: TreatmentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentPlanScalarFieldEnum | TreatmentPlanScalarFieldEnum[]
  }

  /**
   * Dentist.dentistProcedures
   */
  export type Dentist$dentistProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    where?: DentistProcedureWhereInput
    orderBy?: DentistProcedureOrderByWithRelationInput | DentistProcedureOrderByWithRelationInput[]
    cursor?: DentistProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DentistProcedureScalarFieldEnum | DentistProcedureScalarFieldEnum[]
  }

  /**
   * Dentist.dentistSpecialties
   */
  export type Dentist$dentistSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    where?: DentistSpecialtyWhereInput
    orderBy?: DentistSpecialtyOrderByWithRelationInput | DentistSpecialtyOrderByWithRelationInput[]
    cursor?: DentistSpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DentistSpecialtyScalarFieldEnum | DentistSpecialtyScalarFieldEnum[]
  }

  /**
   * Dentist.attendances
   */
  export type Dentist$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Dentist.attendanceCids
   */
  export type Dentist$attendanceCidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    where?: AttendanceCIDWhereInput
    orderBy?: AttendanceCIDOrderByWithRelationInput | AttendanceCIDOrderByWithRelationInput[]
    cursor?: AttendanceCIDWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceCIDScalarFieldEnum | AttendanceCIDScalarFieldEnum[]
  }

  /**
   * Dentist.attendanceProcedures
   */
  export type Dentist$attendanceProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    where?: AttendanceProcedureWhereInput
    orderBy?: AttendanceProcedureOrderByWithRelationInput | AttendanceProcedureOrderByWithRelationInput[]
    cursor?: AttendanceProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceProcedureScalarFieldEnum | AttendanceProcedureScalarFieldEnum[]
  }

  /**
   * Dentist without action
   */
  export type DentistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    email: string | null
    phone: string | null
    cpf: string | null
    birthDate: Date | null
    address: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    email: string | null
    phone: string | null
    cpf: string | null
    birthDate: Date | null
    address: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    clinicId: number
    name: number
    email: number
    phone: number
    cpf: number
    birthDate: number
    address: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    email?: true
    phone?: true
    cpf?: true
    birthDate?: true
    address?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    email?: true
    phone?: true
    cpf?: true
    birthDate?: true
    address?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    email?: true
    phone?: true
    cpf?: true
    birthDate?: true
    address?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    clinicId: string
    name: string
    email: string | null
    phone: string | null
    cpf: string | null
    birthDate: Date | null
    address: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    cpf?: boolean
    birthDate?: boolean
    address?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    records?: boolean | Patient$recordsArgs<ExtArgs>
    treatmentPlans?: boolean | Patient$treatmentPlansArgs<ExtArgs>
    payments?: boolean | Patient$paymentsArgs<ExtArgs>
    attendances?: boolean | Patient$attendancesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    cpf?: boolean
    birthDate?: boolean
    address?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    cpf?: boolean
    birthDate?: boolean
    address?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    clinicId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    cpf?: boolean
    birthDate?: boolean
    address?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "name" | "email" | "phone" | "cpf" | "birthDate" | "address" | "notes" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    records?: boolean | Patient$recordsArgs<ExtArgs>
    treatmentPlans?: boolean | Patient$treatmentPlansArgs<ExtArgs>
    payments?: boolean | Patient$paymentsArgs<ExtArgs>
    attendances?: boolean | Patient$attendancesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      records: Prisma.$RecordPayload<ExtArgs>[]
      treatmentPlans: Prisma.$TreatmentPlanPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      name: string
      email: string | null
      phone: string | null
      cpf: string | null
      birthDate: Date | null
      address: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    records<T extends Patient$recordsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treatmentPlans<T extends Patient$treatmentPlansArgs<ExtArgs> = {}>(args?: Subset<T, Patient$treatmentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Patient$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Patient$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly clinicId: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly cpf: FieldRef<"Patient", 'String'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly notes: FieldRef<"Patient", 'String'>
    readonly isActive: FieldRef<"Patient", 'Boolean'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.records
   */
  export type Patient$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    where?: RecordWhereInput
    orderBy?: RecordOrderByWithRelationInput | RecordOrderByWithRelationInput[]
    cursor?: RecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordScalarFieldEnum | RecordScalarFieldEnum[]
  }

  /**
   * Patient.treatmentPlans
   */
  export type Patient$treatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    where?: TreatmentPlanWhereInput
    orderBy?: TreatmentPlanOrderByWithRelationInput | TreatmentPlanOrderByWithRelationInput[]
    cursor?: TreatmentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentPlanScalarFieldEnum | TreatmentPlanScalarFieldEnum[]
  }

  /**
   * Patient.payments
   */
  export type Patient$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Patient.attendances
   */
  export type Patient$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    durationMinutes: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    durationMinutes: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    dentistId: string | null
    patientId: string | null
    date: Date | null
    durationMinutes: number | null
    status: $Enums.AppointmentStatus | null
    procedure: string | null
    procedureId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    dentistId: string | null
    patientId: string | null
    date: Date | null
    durationMinutes: number | null
    status: $Enums.AppointmentStatus | null
    procedure: string | null
    procedureId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    clinicId: number
    dentistId: number
    patientId: number
    date: number
    durationMinutes: number
    status: number
    procedure: number
    procedureId: number
    procedureSnapshot: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    durationMinutes?: true
  }

  export type AppointmentSumAggregateInputType = {
    durationMinutes?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    clinicId?: true
    dentistId?: true
    patientId?: true
    date?: true
    durationMinutes?: true
    status?: true
    procedure?: true
    procedureId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    clinicId?: true
    dentistId?: true
    patientId?: true
    date?: true
    durationMinutes?: true
    status?: true
    procedure?: true
    procedureId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    clinicId?: true
    dentistId?: true
    patientId?: true
    date?: true
    durationMinutes?: true
    status?: true
    procedure?: true
    procedureId?: true
    procedureSnapshot?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    clinicId: string
    dentistId: string
    patientId: string
    date: Date
    durationMinutes: number
    status: $Enums.AppointmentStatus
    procedure: string | null
    procedureId: string | null
    procedureSnapshot: JsonValue | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    dentistId?: boolean
    patientId?: boolean
    date?: boolean
    durationMinutes?: boolean
    status?: boolean
    procedure?: boolean
    procedureId?: boolean
    procedureSnapshot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    procedureRelation?: boolean | Appointment$procedureRelationArgs<ExtArgs>
    record?: boolean | Appointment$recordArgs<ExtArgs>
    inventoryMovements?: boolean | Appointment$inventoryMovementsArgs<ExtArgs>
    attendance?: boolean | Appointment$attendanceArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    dentistId?: boolean
    patientId?: boolean
    date?: boolean
    durationMinutes?: boolean
    status?: boolean
    procedure?: boolean
    procedureId?: boolean
    procedureSnapshot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    procedureRelation?: boolean | Appointment$procedureRelationArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    dentistId?: boolean
    patientId?: boolean
    date?: boolean
    durationMinutes?: boolean
    status?: boolean
    procedure?: boolean
    procedureId?: boolean
    procedureSnapshot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    procedureRelation?: boolean | Appointment$procedureRelationArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    clinicId?: boolean
    dentistId?: boolean
    patientId?: boolean
    date?: boolean
    durationMinutes?: boolean
    status?: boolean
    procedure?: boolean
    procedureId?: boolean
    procedureSnapshot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "dentistId" | "patientId" | "date" | "durationMinutes" | "status" | "procedure" | "procedureId" | "procedureSnapshot" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    procedureRelation?: boolean | Appointment$procedureRelationArgs<ExtArgs>
    record?: boolean | Appointment$recordArgs<ExtArgs>
    inventoryMovements?: boolean | Appointment$inventoryMovementsArgs<ExtArgs>
    attendance?: boolean | Appointment$attendanceArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    procedureRelation?: boolean | Appointment$procedureRelationArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    procedureRelation?: boolean | Appointment$procedureRelationArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      dentist: Prisma.$DentistPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      procedureRelation: Prisma.$ProcedurePayload<ExtArgs> | null
      record: Prisma.$RecordPayload<ExtArgs> | null
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      dentistId: string
      patientId: string
      date: Date
      durationMinutes: number
      status: $Enums.AppointmentStatus
      procedure: string | null
      procedureId: string | null
      procedureSnapshot: Prisma.JsonValue | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dentist<T extends DentistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DentistDefaultArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    procedureRelation<T extends Appointment$procedureRelationArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$procedureRelationArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    record<T extends Appointment$recordArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$recordArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventoryMovements<T extends Appointment$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Appointment$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$attendanceArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly clinicId: FieldRef<"Appointment", 'String'>
    readonly dentistId: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly date: FieldRef<"Appointment", 'DateTime'>
    readonly durationMinutes: FieldRef<"Appointment", 'Int'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly procedure: FieldRef<"Appointment", 'String'>
    readonly procedureId: FieldRef<"Appointment", 'String'>
    readonly procedureSnapshot: FieldRef<"Appointment", 'Json'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.procedureRelation
   */
  export type Appointment$procedureRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
  }

  /**
   * Appointment.record
   */
  export type Appointment$recordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    where?: RecordWhereInput
  }

  /**
   * Appointment.inventoryMovements
   */
  export type Appointment$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Appointment.attendance
   */
  export type Appointment$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Record
   */

  export type AggregateRecord = {
    _count: RecordCountAggregateOutputType | null
    _min: RecordMinAggregateOutputType | null
    _max: RecordMaxAggregateOutputType | null
  }

  export type RecordMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    dentistId: string | null
    appointmentId: string | null
    attendanceId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecordMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    dentistId: string | null
    appointmentId: string | null
    attendanceId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecordCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    dentistId: number
    appointmentId: number
    attendanceId: number
    description: number
    procedures: number
    odontogram: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecordMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    dentistId?: true
    appointmentId?: true
    attendanceId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecordMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    dentistId?: true
    appointmentId?: true
    attendanceId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecordCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    dentistId?: true
    appointmentId?: true
    attendanceId?: true
    description?: true
    procedures?: true
    odontogram?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Record to aggregate.
     */
    where?: RecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Records to fetch.
     */
    orderBy?: RecordOrderByWithRelationInput | RecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Records
    **/
    _count?: true | RecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecordMaxAggregateInputType
  }

  export type GetRecordAggregateType<T extends RecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecord[P]>
      : GetScalarType<T[P], AggregateRecord[P]>
  }




  export type RecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecordWhereInput
    orderBy?: RecordOrderByWithAggregationInput | RecordOrderByWithAggregationInput[]
    by: RecordScalarFieldEnum[] | RecordScalarFieldEnum
    having?: RecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecordCountAggregateInputType | true
    _min?: RecordMinAggregateInputType
    _max?: RecordMaxAggregateInputType
  }

  export type RecordGroupByOutputType = {
    id: string
    clinicId: string
    patientId: string
    dentistId: string
    appointmentId: string | null
    attendanceId: string | null
    description: string
    procedures: JsonValue | null
    odontogram: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RecordCountAggregateOutputType | null
    _min: RecordMinAggregateOutputType | null
    _max: RecordMaxAggregateOutputType | null
  }

  type GetRecordGroupByPayload<T extends RecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecordGroupByOutputType[P]>
            : GetScalarType<T[P], RecordGroupByOutputType[P]>
        }
      >
    >


  export type RecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    dentistId?: boolean
    appointmentId?: boolean
    attendanceId?: boolean
    description?: boolean
    procedures?: boolean
    odontogram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    appointment?: boolean | Record$appointmentArgs<ExtArgs>
    attendance?: boolean | Record$attendanceArgs<ExtArgs>
  }, ExtArgs["result"]["record"]>

  export type RecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    dentistId?: boolean
    appointmentId?: boolean
    attendanceId?: boolean
    description?: boolean
    procedures?: boolean
    odontogram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    appointment?: boolean | Record$appointmentArgs<ExtArgs>
    attendance?: boolean | Record$attendanceArgs<ExtArgs>
  }, ExtArgs["result"]["record"]>

  export type RecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    dentistId?: boolean
    appointmentId?: boolean
    attendanceId?: boolean
    description?: boolean
    procedures?: boolean
    odontogram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    appointment?: boolean | Record$appointmentArgs<ExtArgs>
    attendance?: boolean | Record$attendanceArgs<ExtArgs>
  }, ExtArgs["result"]["record"]>

  export type RecordSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    dentistId?: boolean
    appointmentId?: boolean
    attendanceId?: boolean
    description?: boolean
    procedures?: boolean
    odontogram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "patientId" | "dentistId" | "appointmentId" | "attendanceId" | "description" | "procedures" | "odontogram" | "createdAt" | "updatedAt", ExtArgs["result"]["record"]>
  export type RecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    appointment?: boolean | Record$appointmentArgs<ExtArgs>
    attendance?: boolean | Record$attendanceArgs<ExtArgs>
  }
  export type RecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    appointment?: boolean | Record$appointmentArgs<ExtArgs>
    attendance?: boolean | Record$attendanceArgs<ExtArgs>
  }
  export type RecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    appointment?: boolean | Record$appointmentArgs<ExtArgs>
    attendance?: boolean | Record$attendanceArgs<ExtArgs>
  }

  export type $RecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Record"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      dentist: Prisma.$DentistPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      attendance: Prisma.$AttendancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      patientId: string
      dentistId: string
      appointmentId: string | null
      attendanceId: string | null
      description: string
      procedures: Prisma.JsonValue | null
      odontogram: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["record"]>
    composites: {}
  }

  type RecordGetPayload<S extends boolean | null | undefined | RecordDefaultArgs> = $Result.GetResult<Prisma.$RecordPayload, S>

  type RecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecordCountAggregateInputType | true
    }

  export interface RecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Record'], meta: { name: 'Record' } }
    /**
     * Find zero or one Record that matches the filter.
     * @param {RecordFindUniqueArgs} args - Arguments to find a Record
     * @example
     * // Get one Record
     * const record = await prisma.record.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecordFindUniqueArgs>(args: SelectSubset<T, RecordFindUniqueArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Record that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecordFindUniqueOrThrowArgs} args - Arguments to find a Record
     * @example
     * // Get one Record
     * const record = await prisma.record.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecordFindUniqueOrThrowArgs>(args: SelectSubset<T, RecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Record that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordFindFirstArgs} args - Arguments to find a Record
     * @example
     * // Get one Record
     * const record = await prisma.record.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecordFindFirstArgs>(args?: SelectSubset<T, RecordFindFirstArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Record that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordFindFirstOrThrowArgs} args - Arguments to find a Record
     * @example
     * // Get one Record
     * const record = await prisma.record.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecordFindFirstOrThrowArgs>(args?: SelectSubset<T, RecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Records
     * const records = await prisma.record.findMany()
     * 
     * // Get first 10 Records
     * const records = await prisma.record.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recordWithIdOnly = await prisma.record.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecordFindManyArgs>(args?: SelectSubset<T, RecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Record.
     * @param {RecordCreateArgs} args - Arguments to create a Record.
     * @example
     * // Create one Record
     * const Record = await prisma.record.create({
     *   data: {
     *     // ... data to create a Record
     *   }
     * })
     * 
     */
    create<T extends RecordCreateArgs>(args: SelectSubset<T, RecordCreateArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Records.
     * @param {RecordCreateManyArgs} args - Arguments to create many Records.
     * @example
     * // Create many Records
     * const record = await prisma.record.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecordCreateManyArgs>(args?: SelectSubset<T, RecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Records and returns the data saved in the database.
     * @param {RecordCreateManyAndReturnArgs} args - Arguments to create many Records.
     * @example
     * // Create many Records
     * const record = await prisma.record.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Records and only return the `id`
     * const recordWithIdOnly = await prisma.record.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecordCreateManyAndReturnArgs>(args?: SelectSubset<T, RecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Record.
     * @param {RecordDeleteArgs} args - Arguments to delete one Record.
     * @example
     * // Delete one Record
     * const Record = await prisma.record.delete({
     *   where: {
     *     // ... filter to delete one Record
     *   }
     * })
     * 
     */
    delete<T extends RecordDeleteArgs>(args: SelectSubset<T, RecordDeleteArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Record.
     * @param {RecordUpdateArgs} args - Arguments to update one Record.
     * @example
     * // Update one Record
     * const record = await prisma.record.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecordUpdateArgs>(args: SelectSubset<T, RecordUpdateArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Records.
     * @param {RecordDeleteManyArgs} args - Arguments to filter Records to delete.
     * @example
     * // Delete a few Records
     * const { count } = await prisma.record.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecordDeleteManyArgs>(args?: SelectSubset<T, RecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Records
     * const record = await prisma.record.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecordUpdateManyArgs>(args: SelectSubset<T, RecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Records and returns the data updated in the database.
     * @param {RecordUpdateManyAndReturnArgs} args - Arguments to update many Records.
     * @example
     * // Update many Records
     * const record = await prisma.record.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Records and only return the `id`
     * const recordWithIdOnly = await prisma.record.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecordUpdateManyAndReturnArgs>(args: SelectSubset<T, RecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Record.
     * @param {RecordUpsertArgs} args - Arguments to update or create a Record.
     * @example
     * // Update or create a Record
     * const record = await prisma.record.upsert({
     *   create: {
     *     // ... data to create a Record
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Record we want to update
     *   }
     * })
     */
    upsert<T extends RecordUpsertArgs>(args: SelectSubset<T, RecordUpsertArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordCountArgs} args - Arguments to filter Records to count.
     * @example
     * // Count the number of Records
     * const count = await prisma.record.count({
     *   where: {
     *     // ... the filter for the Records we want to count
     *   }
     * })
    **/
    count<T extends RecordCountArgs>(
      args?: Subset<T, RecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Record.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecordAggregateArgs>(args: Subset<T, RecordAggregateArgs>): Prisma.PrismaPromise<GetRecordAggregateType<T>>

    /**
     * Group by Record.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecordGroupByArgs['orderBy'] }
        : { orderBy?: RecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Record model
   */
  readonly fields: RecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Record.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dentist<T extends DentistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DentistDefaultArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends Record$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Record$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendance<T extends Record$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Record$attendanceArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Record model
   */
  interface RecordFieldRefs {
    readonly id: FieldRef<"Record", 'String'>
    readonly clinicId: FieldRef<"Record", 'String'>
    readonly patientId: FieldRef<"Record", 'String'>
    readonly dentistId: FieldRef<"Record", 'String'>
    readonly appointmentId: FieldRef<"Record", 'String'>
    readonly attendanceId: FieldRef<"Record", 'String'>
    readonly description: FieldRef<"Record", 'String'>
    readonly procedures: FieldRef<"Record", 'Json'>
    readonly odontogram: FieldRef<"Record", 'Json'>
    readonly createdAt: FieldRef<"Record", 'DateTime'>
    readonly updatedAt: FieldRef<"Record", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Record findUnique
   */
  export type RecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * Filter, which Record to fetch.
     */
    where: RecordWhereUniqueInput
  }

  /**
   * Record findUniqueOrThrow
   */
  export type RecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * Filter, which Record to fetch.
     */
    where: RecordWhereUniqueInput
  }

  /**
   * Record findFirst
   */
  export type RecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * Filter, which Record to fetch.
     */
    where?: RecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Records to fetch.
     */
    orderBy?: RecordOrderByWithRelationInput | RecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Records.
     */
    cursor?: RecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Records.
     */
    distinct?: RecordScalarFieldEnum | RecordScalarFieldEnum[]
  }

  /**
   * Record findFirstOrThrow
   */
  export type RecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * Filter, which Record to fetch.
     */
    where?: RecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Records to fetch.
     */
    orderBy?: RecordOrderByWithRelationInput | RecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Records.
     */
    cursor?: RecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Records.
     */
    distinct?: RecordScalarFieldEnum | RecordScalarFieldEnum[]
  }

  /**
   * Record findMany
   */
  export type RecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * Filter, which Records to fetch.
     */
    where?: RecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Records to fetch.
     */
    orderBy?: RecordOrderByWithRelationInput | RecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Records.
     */
    cursor?: RecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Records.
     */
    skip?: number
    distinct?: RecordScalarFieldEnum | RecordScalarFieldEnum[]
  }

  /**
   * Record create
   */
  export type RecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * The data needed to create a Record.
     */
    data: XOR<RecordCreateInput, RecordUncheckedCreateInput>
  }

  /**
   * Record createMany
   */
  export type RecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Records.
     */
    data: RecordCreateManyInput | RecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Record createManyAndReturn
   */
  export type RecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * The data used to create many Records.
     */
    data: RecordCreateManyInput | RecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Record update
   */
  export type RecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * The data needed to update a Record.
     */
    data: XOR<RecordUpdateInput, RecordUncheckedUpdateInput>
    /**
     * Choose, which Record to update.
     */
    where: RecordWhereUniqueInput
  }

  /**
   * Record updateMany
   */
  export type RecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Records.
     */
    data: XOR<RecordUpdateManyMutationInput, RecordUncheckedUpdateManyInput>
    /**
     * Filter which Records to update
     */
    where?: RecordWhereInput
    /**
     * Limit how many Records to update.
     */
    limit?: number
  }

  /**
   * Record updateManyAndReturn
   */
  export type RecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * The data used to update Records.
     */
    data: XOR<RecordUpdateManyMutationInput, RecordUncheckedUpdateManyInput>
    /**
     * Filter which Records to update
     */
    where?: RecordWhereInput
    /**
     * Limit how many Records to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Record upsert
   */
  export type RecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * The filter to search for the Record to update in case it exists.
     */
    where: RecordWhereUniqueInput
    /**
     * In case the Record found by the `where` argument doesn't exist, create a new Record with this data.
     */
    create: XOR<RecordCreateInput, RecordUncheckedCreateInput>
    /**
     * In case the Record was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecordUpdateInput, RecordUncheckedUpdateInput>
  }

  /**
   * Record delete
   */
  export type RecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    /**
     * Filter which Record to delete.
     */
    where: RecordWhereUniqueInput
  }

  /**
   * Record deleteMany
   */
  export type RecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Records to delete
     */
    where?: RecordWhereInput
    /**
     * Limit how many Records to delete.
     */
    limit?: number
  }

  /**
   * Record.appointment
   */
  export type Record$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Record.attendance
   */
  export type Record$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
  }

  /**
   * Record without action
   */
  export type RecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
  }


  /**
   * Model TreatmentPlan
   */

  export type AggregateTreatmentPlan = {
    _count: TreatmentPlanCountAggregateOutputType | null
    _avg: TreatmentPlanAvgAggregateOutputType | null
    _sum: TreatmentPlanSumAggregateOutputType | null
    _min: TreatmentPlanMinAggregateOutputType | null
    _max: TreatmentPlanMaxAggregateOutputType | null
  }

  export type TreatmentPlanAvgAggregateOutputType = {
    totalAmount: Decimal | null
    discountValue: Decimal | null
    finalAmount: Decimal | null
  }

  export type TreatmentPlanSumAggregateOutputType = {
    totalAmount: Decimal | null
    discountValue: Decimal | null
    finalAmount: Decimal | null
  }

  export type TreatmentPlanMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    dentistId: string | null
    status: $Enums.TreatmentPlanStatus | null
    totalAmount: Decimal | null
    discountType: $Enums.DiscountType | null
    discountValue: Decimal | null
    finalAmount: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TreatmentPlanMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    dentistId: string | null
    status: $Enums.TreatmentPlanStatus | null
    totalAmount: Decimal | null
    discountType: $Enums.DiscountType | null
    discountValue: Decimal | null
    finalAmount: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TreatmentPlanCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    dentistId: number
    status: number
    totalAmount: number
    discountType: number
    discountValue: number
    finalAmount: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TreatmentPlanAvgAggregateInputType = {
    totalAmount?: true
    discountValue?: true
    finalAmount?: true
  }

  export type TreatmentPlanSumAggregateInputType = {
    totalAmount?: true
    discountValue?: true
    finalAmount?: true
  }

  export type TreatmentPlanMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    dentistId?: true
    status?: true
    totalAmount?: true
    discountType?: true
    discountValue?: true
    finalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TreatmentPlanMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    dentistId?: true
    status?: true
    totalAmount?: true
    discountType?: true
    discountValue?: true
    finalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TreatmentPlanCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    dentistId?: true
    status?: true
    totalAmount?: true
    discountType?: true
    discountValue?: true
    finalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TreatmentPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreatmentPlan to aggregate.
     */
    where?: TreatmentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentPlans to fetch.
     */
    orderBy?: TreatmentPlanOrderByWithRelationInput | TreatmentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreatmentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TreatmentPlans
    **/
    _count?: true | TreatmentPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreatmentPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreatmentPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreatmentPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreatmentPlanMaxAggregateInputType
  }

  export type GetTreatmentPlanAggregateType<T extends TreatmentPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTreatmentPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreatmentPlan[P]>
      : GetScalarType<T[P], AggregateTreatmentPlan[P]>
  }




  export type TreatmentPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentPlanWhereInput
    orderBy?: TreatmentPlanOrderByWithAggregationInput | TreatmentPlanOrderByWithAggregationInput[]
    by: TreatmentPlanScalarFieldEnum[] | TreatmentPlanScalarFieldEnum
    having?: TreatmentPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreatmentPlanCountAggregateInputType | true
    _avg?: TreatmentPlanAvgAggregateInputType
    _sum?: TreatmentPlanSumAggregateInputType
    _min?: TreatmentPlanMinAggregateInputType
    _max?: TreatmentPlanMaxAggregateInputType
  }

  export type TreatmentPlanGroupByOutputType = {
    id: string
    clinicId: string
    patientId: string
    dentistId: string
    status: $Enums.TreatmentPlanStatus
    totalAmount: Decimal
    discountType: $Enums.DiscountType | null
    discountValue: Decimal | null
    finalAmount: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TreatmentPlanCountAggregateOutputType | null
    _avg: TreatmentPlanAvgAggregateOutputType | null
    _sum: TreatmentPlanSumAggregateOutputType | null
    _min: TreatmentPlanMinAggregateOutputType | null
    _max: TreatmentPlanMaxAggregateOutputType | null
  }

  type GetTreatmentPlanGroupByPayload<T extends TreatmentPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreatmentPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreatmentPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreatmentPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TreatmentPlanGroupByOutputType[P]>
        }
      >
    >


  export type TreatmentPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    dentistId?: boolean
    status?: boolean
    totalAmount?: boolean
    discountType?: boolean
    discountValue?: boolean
    finalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    items?: boolean | TreatmentPlan$itemsArgs<ExtArgs>
    paymentTreatmentPlans?: boolean | TreatmentPlan$paymentTreatmentPlansArgs<ExtArgs>
    _count?: boolean | TreatmentPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatmentPlan"]>

  export type TreatmentPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    dentistId?: boolean
    status?: boolean
    totalAmount?: boolean
    discountType?: boolean
    discountValue?: boolean
    finalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatmentPlan"]>

  export type TreatmentPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    dentistId?: boolean
    status?: boolean
    totalAmount?: boolean
    discountType?: boolean
    discountValue?: boolean
    finalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatmentPlan"]>

  export type TreatmentPlanSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    dentistId?: boolean
    status?: boolean
    totalAmount?: boolean
    discountType?: boolean
    discountValue?: boolean
    finalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TreatmentPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "patientId" | "dentistId" | "status" | "totalAmount" | "discountType" | "discountValue" | "finalAmount" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["treatmentPlan"]>
  export type TreatmentPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    items?: boolean | TreatmentPlan$itemsArgs<ExtArgs>
    paymentTreatmentPlans?: boolean | TreatmentPlan$paymentTreatmentPlansArgs<ExtArgs>
    _count?: boolean | TreatmentPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TreatmentPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
  }
  export type TreatmentPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
  }

  export type $TreatmentPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TreatmentPlan"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      dentist: Prisma.$DentistPayload<ExtArgs>
      items: Prisma.$TreatmentItemPayload<ExtArgs>[]
      paymentTreatmentPlans: Prisma.$PaymentTreatmentPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      patientId: string
      dentistId: string
      status: $Enums.TreatmentPlanStatus
      totalAmount: Prisma.Decimal
      discountType: $Enums.DiscountType | null
      discountValue: Prisma.Decimal | null
      finalAmount: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["treatmentPlan"]>
    composites: {}
  }

  type TreatmentPlanGetPayload<S extends boolean | null | undefined | TreatmentPlanDefaultArgs> = $Result.GetResult<Prisma.$TreatmentPlanPayload, S>

  type TreatmentPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TreatmentPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TreatmentPlanCountAggregateInputType | true
    }

  export interface TreatmentPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TreatmentPlan'], meta: { name: 'TreatmentPlan' } }
    /**
     * Find zero or one TreatmentPlan that matches the filter.
     * @param {TreatmentPlanFindUniqueArgs} args - Arguments to find a TreatmentPlan
     * @example
     * // Get one TreatmentPlan
     * const treatmentPlan = await prisma.treatmentPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreatmentPlanFindUniqueArgs>(args: SelectSubset<T, TreatmentPlanFindUniqueArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TreatmentPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TreatmentPlanFindUniqueOrThrowArgs} args - Arguments to find a TreatmentPlan
     * @example
     * // Get one TreatmentPlan
     * const treatmentPlan = await prisma.treatmentPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreatmentPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TreatmentPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TreatmentPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentPlanFindFirstArgs} args - Arguments to find a TreatmentPlan
     * @example
     * // Get one TreatmentPlan
     * const treatmentPlan = await prisma.treatmentPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreatmentPlanFindFirstArgs>(args?: SelectSubset<T, TreatmentPlanFindFirstArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TreatmentPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentPlanFindFirstOrThrowArgs} args - Arguments to find a TreatmentPlan
     * @example
     * // Get one TreatmentPlan
     * const treatmentPlan = await prisma.treatmentPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreatmentPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TreatmentPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TreatmentPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TreatmentPlans
     * const treatmentPlans = await prisma.treatmentPlan.findMany()
     * 
     * // Get first 10 TreatmentPlans
     * const treatmentPlans = await prisma.treatmentPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treatmentPlanWithIdOnly = await prisma.treatmentPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreatmentPlanFindManyArgs>(args?: SelectSubset<T, TreatmentPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TreatmentPlan.
     * @param {TreatmentPlanCreateArgs} args - Arguments to create a TreatmentPlan.
     * @example
     * // Create one TreatmentPlan
     * const TreatmentPlan = await prisma.treatmentPlan.create({
     *   data: {
     *     // ... data to create a TreatmentPlan
     *   }
     * })
     * 
     */
    create<T extends TreatmentPlanCreateArgs>(args: SelectSubset<T, TreatmentPlanCreateArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TreatmentPlans.
     * @param {TreatmentPlanCreateManyArgs} args - Arguments to create many TreatmentPlans.
     * @example
     * // Create many TreatmentPlans
     * const treatmentPlan = await prisma.treatmentPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreatmentPlanCreateManyArgs>(args?: SelectSubset<T, TreatmentPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TreatmentPlans and returns the data saved in the database.
     * @param {TreatmentPlanCreateManyAndReturnArgs} args - Arguments to create many TreatmentPlans.
     * @example
     * // Create many TreatmentPlans
     * const treatmentPlan = await prisma.treatmentPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TreatmentPlans and only return the `id`
     * const treatmentPlanWithIdOnly = await prisma.treatmentPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreatmentPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TreatmentPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TreatmentPlan.
     * @param {TreatmentPlanDeleteArgs} args - Arguments to delete one TreatmentPlan.
     * @example
     * // Delete one TreatmentPlan
     * const TreatmentPlan = await prisma.treatmentPlan.delete({
     *   where: {
     *     // ... filter to delete one TreatmentPlan
     *   }
     * })
     * 
     */
    delete<T extends TreatmentPlanDeleteArgs>(args: SelectSubset<T, TreatmentPlanDeleteArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TreatmentPlan.
     * @param {TreatmentPlanUpdateArgs} args - Arguments to update one TreatmentPlan.
     * @example
     * // Update one TreatmentPlan
     * const treatmentPlan = await prisma.treatmentPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreatmentPlanUpdateArgs>(args: SelectSubset<T, TreatmentPlanUpdateArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TreatmentPlans.
     * @param {TreatmentPlanDeleteManyArgs} args - Arguments to filter TreatmentPlans to delete.
     * @example
     * // Delete a few TreatmentPlans
     * const { count } = await prisma.treatmentPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreatmentPlanDeleteManyArgs>(args?: SelectSubset<T, TreatmentPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreatmentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TreatmentPlans
     * const treatmentPlan = await prisma.treatmentPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreatmentPlanUpdateManyArgs>(args: SelectSubset<T, TreatmentPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreatmentPlans and returns the data updated in the database.
     * @param {TreatmentPlanUpdateManyAndReturnArgs} args - Arguments to update many TreatmentPlans.
     * @example
     * // Update many TreatmentPlans
     * const treatmentPlan = await prisma.treatmentPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TreatmentPlans and only return the `id`
     * const treatmentPlanWithIdOnly = await prisma.treatmentPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TreatmentPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, TreatmentPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TreatmentPlan.
     * @param {TreatmentPlanUpsertArgs} args - Arguments to update or create a TreatmentPlan.
     * @example
     * // Update or create a TreatmentPlan
     * const treatmentPlan = await prisma.treatmentPlan.upsert({
     *   create: {
     *     // ... data to create a TreatmentPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TreatmentPlan we want to update
     *   }
     * })
     */
    upsert<T extends TreatmentPlanUpsertArgs>(args: SelectSubset<T, TreatmentPlanUpsertArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TreatmentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentPlanCountArgs} args - Arguments to filter TreatmentPlans to count.
     * @example
     * // Count the number of TreatmentPlans
     * const count = await prisma.treatmentPlan.count({
     *   where: {
     *     // ... the filter for the TreatmentPlans we want to count
     *   }
     * })
    **/
    count<T extends TreatmentPlanCountArgs>(
      args?: Subset<T, TreatmentPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreatmentPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TreatmentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreatmentPlanAggregateArgs>(args: Subset<T, TreatmentPlanAggregateArgs>): Prisma.PrismaPromise<GetTreatmentPlanAggregateType<T>>

    /**
     * Group by TreatmentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreatmentPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreatmentPlanGroupByArgs['orderBy'] }
        : { orderBy?: TreatmentPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreatmentPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreatmentPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TreatmentPlan model
   */
  readonly fields: TreatmentPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TreatmentPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreatmentPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dentist<T extends DentistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DentistDefaultArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends TreatmentPlan$itemsArgs<ExtArgs> = {}>(args?: Subset<T, TreatmentPlan$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentTreatmentPlans<T extends TreatmentPlan$paymentTreatmentPlansArgs<ExtArgs> = {}>(args?: Subset<T, TreatmentPlan$paymentTreatmentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TreatmentPlan model
   */
  interface TreatmentPlanFieldRefs {
    readonly id: FieldRef<"TreatmentPlan", 'String'>
    readonly clinicId: FieldRef<"TreatmentPlan", 'String'>
    readonly patientId: FieldRef<"TreatmentPlan", 'String'>
    readonly dentistId: FieldRef<"TreatmentPlan", 'String'>
    readonly status: FieldRef<"TreatmentPlan", 'TreatmentPlanStatus'>
    readonly totalAmount: FieldRef<"TreatmentPlan", 'Decimal'>
    readonly discountType: FieldRef<"TreatmentPlan", 'DiscountType'>
    readonly discountValue: FieldRef<"TreatmentPlan", 'Decimal'>
    readonly finalAmount: FieldRef<"TreatmentPlan", 'Decimal'>
    readonly notes: FieldRef<"TreatmentPlan", 'String'>
    readonly createdAt: FieldRef<"TreatmentPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TreatmentPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TreatmentPlan findUnique
   */
  export type TreatmentPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentPlan to fetch.
     */
    where: TreatmentPlanWhereUniqueInput
  }

  /**
   * TreatmentPlan findUniqueOrThrow
   */
  export type TreatmentPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentPlan to fetch.
     */
    where: TreatmentPlanWhereUniqueInput
  }

  /**
   * TreatmentPlan findFirst
   */
  export type TreatmentPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentPlan to fetch.
     */
    where?: TreatmentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentPlans to fetch.
     */
    orderBy?: TreatmentPlanOrderByWithRelationInput | TreatmentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreatmentPlans.
     */
    cursor?: TreatmentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreatmentPlans.
     */
    distinct?: TreatmentPlanScalarFieldEnum | TreatmentPlanScalarFieldEnum[]
  }

  /**
   * TreatmentPlan findFirstOrThrow
   */
  export type TreatmentPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentPlan to fetch.
     */
    where?: TreatmentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentPlans to fetch.
     */
    orderBy?: TreatmentPlanOrderByWithRelationInput | TreatmentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreatmentPlans.
     */
    cursor?: TreatmentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreatmentPlans.
     */
    distinct?: TreatmentPlanScalarFieldEnum | TreatmentPlanScalarFieldEnum[]
  }

  /**
   * TreatmentPlan findMany
   */
  export type TreatmentPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentPlans to fetch.
     */
    where?: TreatmentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentPlans to fetch.
     */
    orderBy?: TreatmentPlanOrderByWithRelationInput | TreatmentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TreatmentPlans.
     */
    cursor?: TreatmentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentPlans.
     */
    skip?: number
    distinct?: TreatmentPlanScalarFieldEnum | TreatmentPlanScalarFieldEnum[]
  }

  /**
   * TreatmentPlan create
   */
  export type TreatmentPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TreatmentPlan.
     */
    data: XOR<TreatmentPlanCreateInput, TreatmentPlanUncheckedCreateInput>
  }

  /**
   * TreatmentPlan createMany
   */
  export type TreatmentPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TreatmentPlans.
     */
    data: TreatmentPlanCreateManyInput | TreatmentPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TreatmentPlan createManyAndReturn
   */
  export type TreatmentPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * The data used to create many TreatmentPlans.
     */
    data: TreatmentPlanCreateManyInput | TreatmentPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TreatmentPlan update
   */
  export type TreatmentPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TreatmentPlan.
     */
    data: XOR<TreatmentPlanUpdateInput, TreatmentPlanUncheckedUpdateInput>
    /**
     * Choose, which TreatmentPlan to update.
     */
    where: TreatmentPlanWhereUniqueInput
  }

  /**
   * TreatmentPlan updateMany
   */
  export type TreatmentPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TreatmentPlans.
     */
    data: XOR<TreatmentPlanUpdateManyMutationInput, TreatmentPlanUncheckedUpdateManyInput>
    /**
     * Filter which TreatmentPlans to update
     */
    where?: TreatmentPlanWhereInput
    /**
     * Limit how many TreatmentPlans to update.
     */
    limit?: number
  }

  /**
   * TreatmentPlan updateManyAndReturn
   */
  export type TreatmentPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * The data used to update TreatmentPlans.
     */
    data: XOR<TreatmentPlanUpdateManyMutationInput, TreatmentPlanUncheckedUpdateManyInput>
    /**
     * Filter which TreatmentPlans to update
     */
    where?: TreatmentPlanWhereInput
    /**
     * Limit how many TreatmentPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TreatmentPlan upsert
   */
  export type TreatmentPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TreatmentPlan to update in case it exists.
     */
    where: TreatmentPlanWhereUniqueInput
    /**
     * In case the TreatmentPlan found by the `where` argument doesn't exist, create a new TreatmentPlan with this data.
     */
    create: XOR<TreatmentPlanCreateInput, TreatmentPlanUncheckedCreateInput>
    /**
     * In case the TreatmentPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreatmentPlanUpdateInput, TreatmentPlanUncheckedUpdateInput>
  }

  /**
   * TreatmentPlan delete
   */
  export type TreatmentPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter which TreatmentPlan to delete.
     */
    where: TreatmentPlanWhereUniqueInput
  }

  /**
   * TreatmentPlan deleteMany
   */
  export type TreatmentPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreatmentPlans to delete
     */
    where?: TreatmentPlanWhereInput
    /**
     * Limit how many TreatmentPlans to delete.
     */
    limit?: number
  }

  /**
   * TreatmentPlan.items
   */
  export type TreatmentPlan$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    where?: TreatmentItemWhereInput
    orderBy?: TreatmentItemOrderByWithRelationInput | TreatmentItemOrderByWithRelationInput[]
    cursor?: TreatmentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentItemScalarFieldEnum | TreatmentItemScalarFieldEnum[]
  }

  /**
   * TreatmentPlan.paymentTreatmentPlans
   */
  export type TreatmentPlan$paymentTreatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    where?: PaymentTreatmentPlanWhereInput
    orderBy?: PaymentTreatmentPlanOrderByWithRelationInput | PaymentTreatmentPlanOrderByWithRelationInput[]
    cursor?: PaymentTreatmentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTreatmentPlanScalarFieldEnum | PaymentTreatmentPlanScalarFieldEnum[]
  }

  /**
   * TreatmentPlan without action
   */
  export type TreatmentPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentPlan
     */
    select?: TreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentPlan
     */
    omit?: TreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentPlanInclude<ExtArgs> | null
  }


  /**
   * Model TreatmentItem
   */

  export type AggregateTreatmentItem = {
    _count: TreatmentItemCountAggregateOutputType | null
    _avg: TreatmentItemAvgAggregateOutputType | null
    _sum: TreatmentItemSumAggregateOutputType | null
    _min: TreatmentItemMinAggregateOutputType | null
    _max: TreatmentItemMaxAggregateOutputType | null
  }

  export type TreatmentItemAvgAggregateOutputType = {
    value: Decimal | null
    quantity: number | null
  }

  export type TreatmentItemSumAggregateOutputType = {
    value: Decimal | null
    quantity: number | null
  }

  export type TreatmentItemMinAggregateOutputType = {
    id: string | null
    planId: string | null
    procedureId: string | null
    description: string | null
    tooth: string | null
    value: Decimal | null
    quantity: number | null
  }

  export type TreatmentItemMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    procedureId: string | null
    description: string | null
    tooth: string | null
    value: Decimal | null
    quantity: number | null
  }

  export type TreatmentItemCountAggregateOutputType = {
    id: number
    planId: number
    procedureId: number
    description: number
    tooth: number
    value: number
    quantity: number
    _all: number
  }


  export type TreatmentItemAvgAggregateInputType = {
    value?: true
    quantity?: true
  }

  export type TreatmentItemSumAggregateInputType = {
    value?: true
    quantity?: true
  }

  export type TreatmentItemMinAggregateInputType = {
    id?: true
    planId?: true
    procedureId?: true
    description?: true
    tooth?: true
    value?: true
    quantity?: true
  }

  export type TreatmentItemMaxAggregateInputType = {
    id?: true
    planId?: true
    procedureId?: true
    description?: true
    tooth?: true
    value?: true
    quantity?: true
  }

  export type TreatmentItemCountAggregateInputType = {
    id?: true
    planId?: true
    procedureId?: true
    description?: true
    tooth?: true
    value?: true
    quantity?: true
    _all?: true
  }

  export type TreatmentItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreatmentItem to aggregate.
     */
    where?: TreatmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentItems to fetch.
     */
    orderBy?: TreatmentItemOrderByWithRelationInput | TreatmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreatmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TreatmentItems
    **/
    _count?: true | TreatmentItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreatmentItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreatmentItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreatmentItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreatmentItemMaxAggregateInputType
  }

  export type GetTreatmentItemAggregateType<T extends TreatmentItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTreatmentItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreatmentItem[P]>
      : GetScalarType<T[P], AggregateTreatmentItem[P]>
  }




  export type TreatmentItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentItemWhereInput
    orderBy?: TreatmentItemOrderByWithAggregationInput | TreatmentItemOrderByWithAggregationInput[]
    by: TreatmentItemScalarFieldEnum[] | TreatmentItemScalarFieldEnum
    having?: TreatmentItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreatmentItemCountAggregateInputType | true
    _avg?: TreatmentItemAvgAggregateInputType
    _sum?: TreatmentItemSumAggregateInputType
    _min?: TreatmentItemMinAggregateInputType
    _max?: TreatmentItemMaxAggregateInputType
  }

  export type TreatmentItemGroupByOutputType = {
    id: string
    planId: string
    procedureId: string | null
    description: string
    tooth: string | null
    value: Decimal
    quantity: number
    _count: TreatmentItemCountAggregateOutputType | null
    _avg: TreatmentItemAvgAggregateOutputType | null
    _sum: TreatmentItemSumAggregateOutputType | null
    _min: TreatmentItemMinAggregateOutputType | null
    _max: TreatmentItemMaxAggregateOutputType | null
  }

  type GetTreatmentItemGroupByPayload<T extends TreatmentItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreatmentItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreatmentItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreatmentItemGroupByOutputType[P]>
            : GetScalarType<T[P], TreatmentItemGroupByOutputType[P]>
        }
      >
    >


  export type TreatmentItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    procedureId?: boolean
    description?: boolean
    tooth?: boolean
    value?: boolean
    quantity?: boolean
    plan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
    procedure?: boolean | TreatmentItem$procedureArgs<ExtArgs>
  }, ExtArgs["result"]["treatmentItem"]>

  export type TreatmentItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    procedureId?: boolean
    description?: boolean
    tooth?: boolean
    value?: boolean
    quantity?: boolean
    plan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
    procedure?: boolean | TreatmentItem$procedureArgs<ExtArgs>
  }, ExtArgs["result"]["treatmentItem"]>

  export type TreatmentItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    procedureId?: boolean
    description?: boolean
    tooth?: boolean
    value?: boolean
    quantity?: boolean
    plan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
    procedure?: boolean | TreatmentItem$procedureArgs<ExtArgs>
  }, ExtArgs["result"]["treatmentItem"]>

  export type TreatmentItemSelectScalar = {
    id?: boolean
    planId?: boolean
    procedureId?: boolean
    description?: boolean
    tooth?: boolean
    value?: boolean
    quantity?: boolean
  }

  export type TreatmentItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "procedureId" | "description" | "tooth" | "value" | "quantity", ExtArgs["result"]["treatmentItem"]>
  export type TreatmentItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
    procedure?: boolean | TreatmentItem$procedureArgs<ExtArgs>
  }
  export type TreatmentItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
    procedure?: boolean | TreatmentItem$procedureArgs<ExtArgs>
  }
  export type TreatmentItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
    procedure?: boolean | TreatmentItem$procedureArgs<ExtArgs>
  }

  export type $TreatmentItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TreatmentItem"
    objects: {
      plan: Prisma.$TreatmentPlanPayload<ExtArgs>
      procedure: Prisma.$ProcedurePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      procedureId: string | null
      description: string
      tooth: string | null
      value: Prisma.Decimal
      quantity: number
    }, ExtArgs["result"]["treatmentItem"]>
    composites: {}
  }

  type TreatmentItemGetPayload<S extends boolean | null | undefined | TreatmentItemDefaultArgs> = $Result.GetResult<Prisma.$TreatmentItemPayload, S>

  type TreatmentItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TreatmentItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TreatmentItemCountAggregateInputType | true
    }

  export interface TreatmentItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TreatmentItem'], meta: { name: 'TreatmentItem' } }
    /**
     * Find zero or one TreatmentItem that matches the filter.
     * @param {TreatmentItemFindUniqueArgs} args - Arguments to find a TreatmentItem
     * @example
     * // Get one TreatmentItem
     * const treatmentItem = await prisma.treatmentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreatmentItemFindUniqueArgs>(args: SelectSubset<T, TreatmentItemFindUniqueArgs<ExtArgs>>): Prisma__TreatmentItemClient<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TreatmentItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TreatmentItemFindUniqueOrThrowArgs} args - Arguments to find a TreatmentItem
     * @example
     * // Get one TreatmentItem
     * const treatmentItem = await prisma.treatmentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreatmentItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TreatmentItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreatmentItemClient<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TreatmentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentItemFindFirstArgs} args - Arguments to find a TreatmentItem
     * @example
     * // Get one TreatmentItem
     * const treatmentItem = await prisma.treatmentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreatmentItemFindFirstArgs>(args?: SelectSubset<T, TreatmentItemFindFirstArgs<ExtArgs>>): Prisma__TreatmentItemClient<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TreatmentItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentItemFindFirstOrThrowArgs} args - Arguments to find a TreatmentItem
     * @example
     * // Get one TreatmentItem
     * const treatmentItem = await prisma.treatmentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreatmentItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TreatmentItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreatmentItemClient<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TreatmentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TreatmentItems
     * const treatmentItems = await prisma.treatmentItem.findMany()
     * 
     * // Get first 10 TreatmentItems
     * const treatmentItems = await prisma.treatmentItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treatmentItemWithIdOnly = await prisma.treatmentItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreatmentItemFindManyArgs>(args?: SelectSubset<T, TreatmentItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TreatmentItem.
     * @param {TreatmentItemCreateArgs} args - Arguments to create a TreatmentItem.
     * @example
     * // Create one TreatmentItem
     * const TreatmentItem = await prisma.treatmentItem.create({
     *   data: {
     *     // ... data to create a TreatmentItem
     *   }
     * })
     * 
     */
    create<T extends TreatmentItemCreateArgs>(args: SelectSubset<T, TreatmentItemCreateArgs<ExtArgs>>): Prisma__TreatmentItemClient<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TreatmentItems.
     * @param {TreatmentItemCreateManyArgs} args - Arguments to create many TreatmentItems.
     * @example
     * // Create many TreatmentItems
     * const treatmentItem = await prisma.treatmentItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreatmentItemCreateManyArgs>(args?: SelectSubset<T, TreatmentItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TreatmentItems and returns the data saved in the database.
     * @param {TreatmentItemCreateManyAndReturnArgs} args - Arguments to create many TreatmentItems.
     * @example
     * // Create many TreatmentItems
     * const treatmentItem = await prisma.treatmentItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TreatmentItems and only return the `id`
     * const treatmentItemWithIdOnly = await prisma.treatmentItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreatmentItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TreatmentItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TreatmentItem.
     * @param {TreatmentItemDeleteArgs} args - Arguments to delete one TreatmentItem.
     * @example
     * // Delete one TreatmentItem
     * const TreatmentItem = await prisma.treatmentItem.delete({
     *   where: {
     *     // ... filter to delete one TreatmentItem
     *   }
     * })
     * 
     */
    delete<T extends TreatmentItemDeleteArgs>(args: SelectSubset<T, TreatmentItemDeleteArgs<ExtArgs>>): Prisma__TreatmentItemClient<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TreatmentItem.
     * @param {TreatmentItemUpdateArgs} args - Arguments to update one TreatmentItem.
     * @example
     * // Update one TreatmentItem
     * const treatmentItem = await prisma.treatmentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreatmentItemUpdateArgs>(args: SelectSubset<T, TreatmentItemUpdateArgs<ExtArgs>>): Prisma__TreatmentItemClient<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TreatmentItems.
     * @param {TreatmentItemDeleteManyArgs} args - Arguments to filter TreatmentItems to delete.
     * @example
     * // Delete a few TreatmentItems
     * const { count } = await prisma.treatmentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreatmentItemDeleteManyArgs>(args?: SelectSubset<T, TreatmentItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreatmentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TreatmentItems
     * const treatmentItem = await prisma.treatmentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreatmentItemUpdateManyArgs>(args: SelectSubset<T, TreatmentItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreatmentItems and returns the data updated in the database.
     * @param {TreatmentItemUpdateManyAndReturnArgs} args - Arguments to update many TreatmentItems.
     * @example
     * // Update many TreatmentItems
     * const treatmentItem = await prisma.treatmentItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TreatmentItems and only return the `id`
     * const treatmentItemWithIdOnly = await prisma.treatmentItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TreatmentItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TreatmentItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TreatmentItem.
     * @param {TreatmentItemUpsertArgs} args - Arguments to update or create a TreatmentItem.
     * @example
     * // Update or create a TreatmentItem
     * const treatmentItem = await prisma.treatmentItem.upsert({
     *   create: {
     *     // ... data to create a TreatmentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TreatmentItem we want to update
     *   }
     * })
     */
    upsert<T extends TreatmentItemUpsertArgs>(args: SelectSubset<T, TreatmentItemUpsertArgs<ExtArgs>>): Prisma__TreatmentItemClient<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TreatmentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentItemCountArgs} args - Arguments to filter TreatmentItems to count.
     * @example
     * // Count the number of TreatmentItems
     * const count = await prisma.treatmentItem.count({
     *   where: {
     *     // ... the filter for the TreatmentItems we want to count
     *   }
     * })
    **/
    count<T extends TreatmentItemCountArgs>(
      args?: Subset<T, TreatmentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreatmentItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TreatmentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreatmentItemAggregateArgs>(args: Subset<T, TreatmentItemAggregateArgs>): Prisma.PrismaPromise<GetTreatmentItemAggregateType<T>>

    /**
     * Group by TreatmentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreatmentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreatmentItemGroupByArgs['orderBy'] }
        : { orderBy?: TreatmentItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreatmentItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreatmentItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TreatmentItem model
   */
  readonly fields: TreatmentItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TreatmentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreatmentItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends TreatmentPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TreatmentPlanDefaultArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    procedure<T extends TreatmentItem$procedureArgs<ExtArgs> = {}>(args?: Subset<T, TreatmentItem$procedureArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TreatmentItem model
   */
  interface TreatmentItemFieldRefs {
    readonly id: FieldRef<"TreatmentItem", 'String'>
    readonly planId: FieldRef<"TreatmentItem", 'String'>
    readonly procedureId: FieldRef<"TreatmentItem", 'String'>
    readonly description: FieldRef<"TreatmentItem", 'String'>
    readonly tooth: FieldRef<"TreatmentItem", 'String'>
    readonly value: FieldRef<"TreatmentItem", 'Decimal'>
    readonly quantity: FieldRef<"TreatmentItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TreatmentItem findUnique
   */
  export type TreatmentItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentItem to fetch.
     */
    where: TreatmentItemWhereUniqueInput
  }

  /**
   * TreatmentItem findUniqueOrThrow
   */
  export type TreatmentItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentItem to fetch.
     */
    where: TreatmentItemWhereUniqueInput
  }

  /**
   * TreatmentItem findFirst
   */
  export type TreatmentItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentItem to fetch.
     */
    where?: TreatmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentItems to fetch.
     */
    orderBy?: TreatmentItemOrderByWithRelationInput | TreatmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreatmentItems.
     */
    cursor?: TreatmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreatmentItems.
     */
    distinct?: TreatmentItemScalarFieldEnum | TreatmentItemScalarFieldEnum[]
  }

  /**
   * TreatmentItem findFirstOrThrow
   */
  export type TreatmentItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentItem to fetch.
     */
    where?: TreatmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentItems to fetch.
     */
    orderBy?: TreatmentItemOrderByWithRelationInput | TreatmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreatmentItems.
     */
    cursor?: TreatmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreatmentItems.
     */
    distinct?: TreatmentItemScalarFieldEnum | TreatmentItemScalarFieldEnum[]
  }

  /**
   * TreatmentItem findMany
   */
  export type TreatmentItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * Filter, which TreatmentItems to fetch.
     */
    where?: TreatmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreatmentItems to fetch.
     */
    orderBy?: TreatmentItemOrderByWithRelationInput | TreatmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TreatmentItems.
     */
    cursor?: TreatmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreatmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreatmentItems.
     */
    skip?: number
    distinct?: TreatmentItemScalarFieldEnum | TreatmentItemScalarFieldEnum[]
  }

  /**
   * TreatmentItem create
   */
  export type TreatmentItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TreatmentItem.
     */
    data: XOR<TreatmentItemCreateInput, TreatmentItemUncheckedCreateInput>
  }

  /**
   * TreatmentItem createMany
   */
  export type TreatmentItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TreatmentItems.
     */
    data: TreatmentItemCreateManyInput | TreatmentItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TreatmentItem createManyAndReturn
   */
  export type TreatmentItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * The data used to create many TreatmentItems.
     */
    data: TreatmentItemCreateManyInput | TreatmentItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TreatmentItem update
   */
  export type TreatmentItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TreatmentItem.
     */
    data: XOR<TreatmentItemUpdateInput, TreatmentItemUncheckedUpdateInput>
    /**
     * Choose, which TreatmentItem to update.
     */
    where: TreatmentItemWhereUniqueInput
  }

  /**
   * TreatmentItem updateMany
   */
  export type TreatmentItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TreatmentItems.
     */
    data: XOR<TreatmentItemUpdateManyMutationInput, TreatmentItemUncheckedUpdateManyInput>
    /**
     * Filter which TreatmentItems to update
     */
    where?: TreatmentItemWhereInput
    /**
     * Limit how many TreatmentItems to update.
     */
    limit?: number
  }

  /**
   * TreatmentItem updateManyAndReturn
   */
  export type TreatmentItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * The data used to update TreatmentItems.
     */
    data: XOR<TreatmentItemUpdateManyMutationInput, TreatmentItemUncheckedUpdateManyInput>
    /**
     * Filter which TreatmentItems to update
     */
    where?: TreatmentItemWhereInput
    /**
     * Limit how many TreatmentItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TreatmentItem upsert
   */
  export type TreatmentItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TreatmentItem to update in case it exists.
     */
    where: TreatmentItemWhereUniqueInput
    /**
     * In case the TreatmentItem found by the `where` argument doesn't exist, create a new TreatmentItem with this data.
     */
    create: XOR<TreatmentItemCreateInput, TreatmentItemUncheckedCreateInput>
    /**
     * In case the TreatmentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreatmentItemUpdateInput, TreatmentItemUncheckedUpdateInput>
  }

  /**
   * TreatmentItem delete
   */
  export type TreatmentItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    /**
     * Filter which TreatmentItem to delete.
     */
    where: TreatmentItemWhereUniqueInput
  }

  /**
   * TreatmentItem deleteMany
   */
  export type TreatmentItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreatmentItems to delete
     */
    where?: TreatmentItemWhereInput
    /**
     * Limit how many TreatmentItems to delete.
     */
    limit?: number
  }

  /**
   * TreatmentItem.procedure
   */
  export type TreatmentItem$procedureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
  }

  /**
   * TreatmentItem without action
   */
  export type TreatmentItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    originalAmount: Decimal | null
    discountValue: Decimal | null
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    originalAmount: Decimal | null
    discountValue: Decimal | null
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    originalAmount: Decimal | null
    discountType: $Enums.DiscountType | null
    discountValue: Decimal | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    description: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    patientId: string | null
    originalAmount: Decimal | null
    discountType: $Enums.DiscountType | null
    discountValue: Decimal | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    description: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    originalAmount: number
    discountType: number
    discountValue: number
    amount: number
    method: number
    description: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    originalAmount?: true
    discountValue?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    originalAmount?: true
    discountValue?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    originalAmount?: true
    discountType?: true
    discountValue?: true
    amount?: true
    method?: true
    description?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    originalAmount?: true
    discountType?: true
    discountValue?: true
    amount?: true
    method?: true
    description?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    originalAmount?: true
    discountType?: true
    discountValue?: true
    amount?: true
    method?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    clinicId: string
    patientId: string | null
    originalAmount: Decimal | null
    discountType: $Enums.DiscountType | null
    discountValue: Decimal | null
    amount: Decimal
    method: $Enums.PaymentMethod
    description: string | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    originalAmount?: boolean
    discountType?: boolean
    discountValue?: boolean
    amount?: boolean
    method?: boolean
    description?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | Payment$patientArgs<ExtArgs>
    paymentTreatmentPlans?: boolean | Payment$paymentTreatmentPlansArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    originalAmount?: boolean
    discountType?: boolean
    discountValue?: boolean
    amount?: boolean
    method?: boolean
    description?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | Payment$patientArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    originalAmount?: boolean
    discountType?: boolean
    discountValue?: boolean
    amount?: boolean
    method?: boolean
    description?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | Payment$patientArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    originalAmount?: boolean
    discountType?: boolean
    discountValue?: boolean
    amount?: boolean
    method?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "patientId" | "originalAmount" | "discountType" | "discountValue" | "amount" | "method" | "description" | "createdAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | Payment$patientArgs<ExtArgs>
    paymentTreatmentPlans?: boolean | Payment$paymentTreatmentPlansArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | Payment$patientArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patient?: boolean | Payment$patientArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs> | null
      paymentTreatmentPlans: Prisma.$PaymentTreatmentPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      patientId: string | null
      originalAmount: Prisma.Decimal | null
      discountType: $Enums.DiscountType | null
      discountValue: Prisma.Decimal | null
      amount: Prisma.Decimal
      method: $Enums.PaymentMethod
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends Payment$patientArgs<ExtArgs> = {}>(args?: Subset<T, Payment$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paymentTreatmentPlans<T extends Payment$paymentTreatmentPlansArgs<ExtArgs> = {}>(args?: Subset<T, Payment$paymentTreatmentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly clinicId: FieldRef<"Payment", 'String'>
    readonly patientId: FieldRef<"Payment", 'String'>
    readonly originalAmount: FieldRef<"Payment", 'Decimal'>
    readonly discountType: FieldRef<"Payment", 'DiscountType'>
    readonly discountValue: FieldRef<"Payment", 'Decimal'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.patient
   */
  export type Payment$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Payment.paymentTreatmentPlans
   */
  export type Payment$paymentTreatmentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    where?: PaymentTreatmentPlanWhereInput
    orderBy?: PaymentTreatmentPlanOrderByWithRelationInput | PaymentTreatmentPlanOrderByWithRelationInput[]
    cursor?: PaymentTreatmentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTreatmentPlanScalarFieldEnum | PaymentTreatmentPlanScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentTreatmentPlan
   */

  export type AggregatePaymentTreatmentPlan = {
    _count: PaymentTreatmentPlanCountAggregateOutputType | null
    _min: PaymentTreatmentPlanMinAggregateOutputType | null
    _max: PaymentTreatmentPlanMaxAggregateOutputType | null
  }

  export type PaymentTreatmentPlanMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    treatmentPlanId: string | null
    createdAt: Date | null
  }

  export type PaymentTreatmentPlanMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    treatmentPlanId: string | null
    createdAt: Date | null
  }

  export type PaymentTreatmentPlanCountAggregateOutputType = {
    id: number
    paymentId: number
    treatmentPlanId: number
    createdAt: number
    _all: number
  }


  export type PaymentTreatmentPlanMinAggregateInputType = {
    id?: true
    paymentId?: true
    treatmentPlanId?: true
    createdAt?: true
  }

  export type PaymentTreatmentPlanMaxAggregateInputType = {
    id?: true
    paymentId?: true
    treatmentPlanId?: true
    createdAt?: true
  }

  export type PaymentTreatmentPlanCountAggregateInputType = {
    id?: true
    paymentId?: true
    treatmentPlanId?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentTreatmentPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTreatmentPlan to aggregate.
     */
    where?: PaymentTreatmentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTreatmentPlans to fetch.
     */
    orderBy?: PaymentTreatmentPlanOrderByWithRelationInput | PaymentTreatmentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTreatmentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTreatmentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTreatmentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTreatmentPlans
    **/
    _count?: true | PaymentTreatmentPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTreatmentPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTreatmentPlanMaxAggregateInputType
  }

  export type GetPaymentTreatmentPlanAggregateType<T extends PaymentTreatmentPlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentTreatmentPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentTreatmentPlan[P]>
      : GetScalarType<T[P], AggregatePaymentTreatmentPlan[P]>
  }




  export type PaymentTreatmentPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTreatmentPlanWhereInput
    orderBy?: PaymentTreatmentPlanOrderByWithAggregationInput | PaymentTreatmentPlanOrderByWithAggregationInput[]
    by: PaymentTreatmentPlanScalarFieldEnum[] | PaymentTreatmentPlanScalarFieldEnum
    having?: PaymentTreatmentPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTreatmentPlanCountAggregateInputType | true
    _min?: PaymentTreatmentPlanMinAggregateInputType
    _max?: PaymentTreatmentPlanMaxAggregateInputType
  }

  export type PaymentTreatmentPlanGroupByOutputType = {
    id: string
    paymentId: string
    treatmentPlanId: string
    createdAt: Date
    _count: PaymentTreatmentPlanCountAggregateOutputType | null
    _min: PaymentTreatmentPlanMinAggregateOutputType | null
    _max: PaymentTreatmentPlanMaxAggregateOutputType | null
  }

  type GetPaymentTreatmentPlanGroupByPayload<T extends PaymentTreatmentPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentTreatmentPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTreatmentPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTreatmentPlanGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTreatmentPlanGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTreatmentPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    treatmentPlanId?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    treatmentPlan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTreatmentPlan"]>

  export type PaymentTreatmentPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    treatmentPlanId?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    treatmentPlan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTreatmentPlan"]>

  export type PaymentTreatmentPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    treatmentPlanId?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    treatmentPlan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTreatmentPlan"]>

  export type PaymentTreatmentPlanSelectScalar = {
    id?: boolean
    paymentId?: boolean
    treatmentPlanId?: boolean
    createdAt?: boolean
  }

  export type PaymentTreatmentPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "treatmentPlanId" | "createdAt", ExtArgs["result"]["paymentTreatmentPlan"]>
  export type PaymentTreatmentPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    treatmentPlan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
  }
  export type PaymentTreatmentPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    treatmentPlan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
  }
  export type PaymentTreatmentPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    treatmentPlan?: boolean | TreatmentPlanDefaultArgs<ExtArgs>
  }

  export type $PaymentTreatmentPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentTreatmentPlan"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      treatmentPlan: Prisma.$TreatmentPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      treatmentPlanId: string
      createdAt: Date
    }, ExtArgs["result"]["paymentTreatmentPlan"]>
    composites: {}
  }

  type PaymentTreatmentPlanGetPayload<S extends boolean | null | undefined | PaymentTreatmentPlanDefaultArgs> = $Result.GetResult<Prisma.$PaymentTreatmentPlanPayload, S>

  type PaymentTreatmentPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentTreatmentPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentTreatmentPlanCountAggregateInputType | true
    }

  export interface PaymentTreatmentPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentTreatmentPlan'], meta: { name: 'PaymentTreatmentPlan' } }
    /**
     * Find zero or one PaymentTreatmentPlan that matches the filter.
     * @param {PaymentTreatmentPlanFindUniqueArgs} args - Arguments to find a PaymentTreatmentPlan
     * @example
     * // Get one PaymentTreatmentPlan
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentTreatmentPlanFindUniqueArgs>(args: SelectSubset<T, PaymentTreatmentPlanFindUniqueArgs<ExtArgs>>): Prisma__PaymentTreatmentPlanClient<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentTreatmentPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentTreatmentPlanFindUniqueOrThrowArgs} args - Arguments to find a PaymentTreatmentPlan
     * @example
     * // Get one PaymentTreatmentPlan
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentTreatmentPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentTreatmentPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentTreatmentPlanClient<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTreatmentPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTreatmentPlanFindFirstArgs} args - Arguments to find a PaymentTreatmentPlan
     * @example
     * // Get one PaymentTreatmentPlan
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentTreatmentPlanFindFirstArgs>(args?: SelectSubset<T, PaymentTreatmentPlanFindFirstArgs<ExtArgs>>): Prisma__PaymentTreatmentPlanClient<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTreatmentPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTreatmentPlanFindFirstOrThrowArgs} args - Arguments to find a PaymentTreatmentPlan
     * @example
     * // Get one PaymentTreatmentPlan
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentTreatmentPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentTreatmentPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentTreatmentPlanClient<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentTreatmentPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTreatmentPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTreatmentPlans
     * const paymentTreatmentPlans = await prisma.paymentTreatmentPlan.findMany()
     * 
     * // Get first 10 PaymentTreatmentPlans
     * const paymentTreatmentPlans = await prisma.paymentTreatmentPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTreatmentPlanWithIdOnly = await prisma.paymentTreatmentPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentTreatmentPlanFindManyArgs>(args?: SelectSubset<T, PaymentTreatmentPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentTreatmentPlan.
     * @param {PaymentTreatmentPlanCreateArgs} args - Arguments to create a PaymentTreatmentPlan.
     * @example
     * // Create one PaymentTreatmentPlan
     * const PaymentTreatmentPlan = await prisma.paymentTreatmentPlan.create({
     *   data: {
     *     // ... data to create a PaymentTreatmentPlan
     *   }
     * })
     * 
     */
    create<T extends PaymentTreatmentPlanCreateArgs>(args: SelectSubset<T, PaymentTreatmentPlanCreateArgs<ExtArgs>>): Prisma__PaymentTreatmentPlanClient<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentTreatmentPlans.
     * @param {PaymentTreatmentPlanCreateManyArgs} args - Arguments to create many PaymentTreatmentPlans.
     * @example
     * // Create many PaymentTreatmentPlans
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentTreatmentPlanCreateManyArgs>(args?: SelectSubset<T, PaymentTreatmentPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentTreatmentPlans and returns the data saved in the database.
     * @param {PaymentTreatmentPlanCreateManyAndReturnArgs} args - Arguments to create many PaymentTreatmentPlans.
     * @example
     * // Create many PaymentTreatmentPlans
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentTreatmentPlans and only return the `id`
     * const paymentTreatmentPlanWithIdOnly = await prisma.paymentTreatmentPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentTreatmentPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentTreatmentPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentTreatmentPlan.
     * @param {PaymentTreatmentPlanDeleteArgs} args - Arguments to delete one PaymentTreatmentPlan.
     * @example
     * // Delete one PaymentTreatmentPlan
     * const PaymentTreatmentPlan = await prisma.paymentTreatmentPlan.delete({
     *   where: {
     *     // ... filter to delete one PaymentTreatmentPlan
     *   }
     * })
     * 
     */
    delete<T extends PaymentTreatmentPlanDeleteArgs>(args: SelectSubset<T, PaymentTreatmentPlanDeleteArgs<ExtArgs>>): Prisma__PaymentTreatmentPlanClient<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentTreatmentPlan.
     * @param {PaymentTreatmentPlanUpdateArgs} args - Arguments to update one PaymentTreatmentPlan.
     * @example
     * // Update one PaymentTreatmentPlan
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentTreatmentPlanUpdateArgs>(args: SelectSubset<T, PaymentTreatmentPlanUpdateArgs<ExtArgs>>): Prisma__PaymentTreatmentPlanClient<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentTreatmentPlans.
     * @param {PaymentTreatmentPlanDeleteManyArgs} args - Arguments to filter PaymentTreatmentPlans to delete.
     * @example
     * // Delete a few PaymentTreatmentPlans
     * const { count } = await prisma.paymentTreatmentPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentTreatmentPlanDeleteManyArgs>(args?: SelectSubset<T, PaymentTreatmentPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTreatmentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTreatmentPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTreatmentPlans
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentTreatmentPlanUpdateManyArgs>(args: SelectSubset<T, PaymentTreatmentPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTreatmentPlans and returns the data updated in the database.
     * @param {PaymentTreatmentPlanUpdateManyAndReturnArgs} args - Arguments to update many PaymentTreatmentPlans.
     * @example
     * // Update many PaymentTreatmentPlans
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentTreatmentPlans and only return the `id`
     * const paymentTreatmentPlanWithIdOnly = await prisma.paymentTreatmentPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentTreatmentPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentTreatmentPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentTreatmentPlan.
     * @param {PaymentTreatmentPlanUpsertArgs} args - Arguments to update or create a PaymentTreatmentPlan.
     * @example
     * // Update or create a PaymentTreatmentPlan
     * const paymentTreatmentPlan = await prisma.paymentTreatmentPlan.upsert({
     *   create: {
     *     // ... data to create a PaymentTreatmentPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentTreatmentPlan we want to update
     *   }
     * })
     */
    upsert<T extends PaymentTreatmentPlanUpsertArgs>(args: SelectSubset<T, PaymentTreatmentPlanUpsertArgs<ExtArgs>>): Prisma__PaymentTreatmentPlanClient<$Result.GetResult<Prisma.$PaymentTreatmentPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentTreatmentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTreatmentPlanCountArgs} args - Arguments to filter PaymentTreatmentPlans to count.
     * @example
     * // Count the number of PaymentTreatmentPlans
     * const count = await prisma.paymentTreatmentPlan.count({
     *   where: {
     *     // ... the filter for the PaymentTreatmentPlans we want to count
     *   }
     * })
    **/
    count<T extends PaymentTreatmentPlanCountArgs>(
      args?: Subset<T, PaymentTreatmentPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTreatmentPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentTreatmentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTreatmentPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTreatmentPlanAggregateArgs>(args: Subset<T, PaymentTreatmentPlanAggregateArgs>): Prisma.PrismaPromise<GetPaymentTreatmentPlanAggregateType<T>>

    /**
     * Group by PaymentTreatmentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTreatmentPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTreatmentPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTreatmentPlanGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTreatmentPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTreatmentPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTreatmentPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentTreatmentPlan model
   */
  readonly fields: PaymentTreatmentPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentTreatmentPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentTreatmentPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    treatmentPlan<T extends TreatmentPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TreatmentPlanDefaultArgs<ExtArgs>>): Prisma__TreatmentPlanClient<$Result.GetResult<Prisma.$TreatmentPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentTreatmentPlan model
   */
  interface PaymentTreatmentPlanFieldRefs {
    readonly id: FieldRef<"PaymentTreatmentPlan", 'String'>
    readonly paymentId: FieldRef<"PaymentTreatmentPlan", 'String'>
    readonly treatmentPlanId: FieldRef<"PaymentTreatmentPlan", 'String'>
    readonly createdAt: FieldRef<"PaymentTreatmentPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentTreatmentPlan findUnique
   */
  export type PaymentTreatmentPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTreatmentPlan to fetch.
     */
    where: PaymentTreatmentPlanWhereUniqueInput
  }

  /**
   * PaymentTreatmentPlan findUniqueOrThrow
   */
  export type PaymentTreatmentPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTreatmentPlan to fetch.
     */
    where: PaymentTreatmentPlanWhereUniqueInput
  }

  /**
   * PaymentTreatmentPlan findFirst
   */
  export type PaymentTreatmentPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTreatmentPlan to fetch.
     */
    where?: PaymentTreatmentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTreatmentPlans to fetch.
     */
    orderBy?: PaymentTreatmentPlanOrderByWithRelationInput | PaymentTreatmentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTreatmentPlans.
     */
    cursor?: PaymentTreatmentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTreatmentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTreatmentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTreatmentPlans.
     */
    distinct?: PaymentTreatmentPlanScalarFieldEnum | PaymentTreatmentPlanScalarFieldEnum[]
  }

  /**
   * PaymentTreatmentPlan findFirstOrThrow
   */
  export type PaymentTreatmentPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTreatmentPlan to fetch.
     */
    where?: PaymentTreatmentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTreatmentPlans to fetch.
     */
    orderBy?: PaymentTreatmentPlanOrderByWithRelationInput | PaymentTreatmentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTreatmentPlans.
     */
    cursor?: PaymentTreatmentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTreatmentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTreatmentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTreatmentPlans.
     */
    distinct?: PaymentTreatmentPlanScalarFieldEnum | PaymentTreatmentPlanScalarFieldEnum[]
  }

  /**
   * PaymentTreatmentPlan findMany
   */
  export type PaymentTreatmentPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTreatmentPlans to fetch.
     */
    where?: PaymentTreatmentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTreatmentPlans to fetch.
     */
    orderBy?: PaymentTreatmentPlanOrderByWithRelationInput | PaymentTreatmentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTreatmentPlans.
     */
    cursor?: PaymentTreatmentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTreatmentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTreatmentPlans.
     */
    skip?: number
    distinct?: PaymentTreatmentPlanScalarFieldEnum | PaymentTreatmentPlanScalarFieldEnum[]
  }

  /**
   * PaymentTreatmentPlan create
   */
  export type PaymentTreatmentPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentTreatmentPlan.
     */
    data: XOR<PaymentTreatmentPlanCreateInput, PaymentTreatmentPlanUncheckedCreateInput>
  }

  /**
   * PaymentTreatmentPlan createMany
   */
  export type PaymentTreatmentPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTreatmentPlans.
     */
    data: PaymentTreatmentPlanCreateManyInput | PaymentTreatmentPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTreatmentPlan createManyAndReturn
   */
  export type PaymentTreatmentPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentTreatmentPlans.
     */
    data: PaymentTreatmentPlanCreateManyInput | PaymentTreatmentPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTreatmentPlan update
   */
  export type PaymentTreatmentPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentTreatmentPlan.
     */
    data: XOR<PaymentTreatmentPlanUpdateInput, PaymentTreatmentPlanUncheckedUpdateInput>
    /**
     * Choose, which PaymentTreatmentPlan to update.
     */
    where: PaymentTreatmentPlanWhereUniqueInput
  }

  /**
   * PaymentTreatmentPlan updateMany
   */
  export type PaymentTreatmentPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTreatmentPlans.
     */
    data: XOR<PaymentTreatmentPlanUpdateManyMutationInput, PaymentTreatmentPlanUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTreatmentPlans to update
     */
    where?: PaymentTreatmentPlanWhereInput
    /**
     * Limit how many PaymentTreatmentPlans to update.
     */
    limit?: number
  }

  /**
   * PaymentTreatmentPlan updateManyAndReturn
   */
  export type PaymentTreatmentPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * The data used to update PaymentTreatmentPlans.
     */
    data: XOR<PaymentTreatmentPlanUpdateManyMutationInput, PaymentTreatmentPlanUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTreatmentPlans to update
     */
    where?: PaymentTreatmentPlanWhereInput
    /**
     * Limit how many PaymentTreatmentPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTreatmentPlan upsert
   */
  export type PaymentTreatmentPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentTreatmentPlan to update in case it exists.
     */
    where: PaymentTreatmentPlanWhereUniqueInput
    /**
     * In case the PaymentTreatmentPlan found by the `where` argument doesn't exist, create a new PaymentTreatmentPlan with this data.
     */
    create: XOR<PaymentTreatmentPlanCreateInput, PaymentTreatmentPlanUncheckedCreateInput>
    /**
     * In case the PaymentTreatmentPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTreatmentPlanUpdateInput, PaymentTreatmentPlanUncheckedUpdateInput>
  }

  /**
   * PaymentTreatmentPlan delete
   */
  export type PaymentTreatmentPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
    /**
     * Filter which PaymentTreatmentPlan to delete.
     */
    where: PaymentTreatmentPlanWhereUniqueInput
  }

  /**
   * PaymentTreatmentPlan deleteMany
   */
  export type PaymentTreatmentPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTreatmentPlans to delete
     */
    where?: PaymentTreatmentPlanWhereInput
    /**
     * Limit how many PaymentTreatmentPlans to delete.
     */
    limit?: number
  }

  /**
   * PaymentTreatmentPlan without action
   */
  export type PaymentTreatmentPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTreatmentPlan
     */
    select?: PaymentTreatmentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTreatmentPlan
     */
    omit?: PaymentTreatmentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTreatmentPlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    clinicId: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    status: number
    currentPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    clinicId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    clinicId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    clinicId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    clinicId: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    status: $Enums.SubscriptionStatus
    currentPeriodEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    clinicId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "stripeCustomerId" | "stripeSubscriptionId" | "status" | "currentPeriodEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      stripeCustomerId: string
      stripeSubscriptionId: string
      status: $Enums.SubscriptionStatus
      currentPeriodEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly clinicId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    userId: string | null
    action: string | null
    targetId: string | null
    targetType: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    userId: string | null
    action: string | null
    targetId: string | null
    targetType: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    clinicId: number
    userId: number
    action: number
    targetId: number
    targetType: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    action?: true
    targetId?: true
    targetType?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    action?: true
    targetId?: true
    targetType?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    clinicId?: true
    userId?: true
    action?: true
    targetId?: true
    targetType?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    clinicId: string
    userId: string
    action: string
    targetId: string | null
    targetType: string | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    clinicId?: boolean
    userId?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "userId" | "action" | "targetId" | "targetType" | "metadata" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      userId: string
      action: string
      targetId: string | null
      targetType: string | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly clinicId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly targetId: FieldRef<"AuditLog", 'String'>
    readonly targetType: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    currentQuantity: number | null
    minQuantity: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    currentQuantity: number | null
    minQuantity: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    description: string | null
    unit: string | null
    currentQuantity: number | null
    minQuantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    description: string | null
    unit: string | null
    currentQuantity: number | null
    minQuantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    clinicId: number
    name: number
    description: number
    unit: number
    currentQuantity: number
    minQuantity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    currentQuantity?: true
    minQuantity?: true
  }

  export type InventoryItemSumAggregateInputType = {
    currentQuantity?: true
    minQuantity?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    description?: true
    unit?: true
    currentQuantity?: true
    minQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    description?: true
    unit?: true
    currentQuantity?: true
    minQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    description?: true
    unit?: true
    currentQuantity?: true
    minQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    clinicId: string
    name: string
    description: string | null
    unit: string
    currentQuantity: number
    minQuantity: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    currentQuantity?: boolean
    minQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    movements?: boolean | InventoryItem$movementsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    currentQuantity?: boolean
    minQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    currentQuantity?: boolean
    minQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    clinicId?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    currentQuantity?: boolean
    minQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "name" | "description" | "unit" | "currentQuantity" | "minQuantity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    movements?: boolean | InventoryItem$movementsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      movements: Prisma.$InventoryMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      name: string
      description: string | null
      unit: string
      currentQuantity: number
      minQuantity: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    movements<T extends InventoryItem$movementsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly clinicId: FieldRef<"InventoryItem", 'String'>
    readonly name: FieldRef<"InventoryItem", 'String'>
    readonly description: FieldRef<"InventoryItem", 'String'>
    readonly unit: FieldRef<"InventoryItem", 'String'>
    readonly currentQuantity: FieldRef<"InventoryItem", 'Int'>
    readonly minQuantity: FieldRef<"InventoryItem", 'Int'>
    readonly isActive: FieldRef<"InventoryItem", 'Boolean'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem.movements
   */
  export type InventoryItem$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    itemId: string | null
    type: $Enums.InventoryMovementType | null
    quantity: number | null
    appointmentId: string | null
    createdById: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    itemId: string | null
    type: $Enums.InventoryMovementType | null
    quantity: number | null
    appointmentId: string | null
    createdById: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    clinicId: number
    itemId: number
    type: number
    quantity: number
    appointmentId: number
    createdById: number
    notes: number
    createdAt: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    clinicId?: true
    itemId?: true
    type?: true
    quantity?: true
    appointmentId?: true
    createdById?: true
    notes?: true
    createdAt?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    clinicId?: true
    itemId?: true
    type?: true
    quantity?: true
    appointmentId?: true
    createdById?: true
    notes?: true
    createdAt?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    clinicId?: true
    itemId?: true
    type?: true
    quantity?: true
    appointmentId?: true
    createdById?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: string
    clinicId: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId: string | null
    createdById: string
    notes: string | null
    createdAt: Date
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    itemId?: boolean
    type?: boolean
    quantity?: boolean
    appointmentId?: boolean
    createdById?: boolean
    notes?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    appointment?: boolean | InventoryMovement$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    itemId?: boolean
    type?: boolean
    quantity?: boolean
    appointmentId?: boolean
    createdById?: boolean
    notes?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    appointment?: boolean | InventoryMovement$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    itemId?: boolean
    type?: boolean
    quantity?: boolean
    appointmentId?: boolean
    createdById?: boolean
    notes?: boolean
    createdAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    appointment?: boolean | InventoryMovement$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectScalar = {
    id?: boolean
    clinicId?: boolean
    itemId?: boolean
    type?: boolean
    quantity?: boolean
    appointmentId?: boolean
    createdById?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type InventoryMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "itemId" | "type" | "quantity" | "appointmentId" | "createdById" | "notes" | "createdAt", ExtArgs["result"]["inventoryMovement"]>
  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    appointment?: boolean | InventoryMovement$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    appointment?: boolean | InventoryMovement$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    appointment?: boolean | InventoryMovement$appointmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      item: Prisma.$InventoryItemPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      itemId: string
      type: $Enums.InventoryMovementType
      quantity: number
      appointmentId: string | null
      createdById: string
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryMovements and returns the data saved in the database.
     * @param {InventoryMovementCreateManyAndReturnArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements and returns the data updated in the database.
     * @param {InventoryMovementUpdateManyAndReturnArgs} args - Arguments to update many InventoryMovements.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends InventoryMovement$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, InventoryMovement$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'String'>
    readonly clinicId: FieldRef<"InventoryMovement", 'String'>
    readonly itemId: FieldRef<"InventoryMovement", 'String'>
    readonly type: FieldRef<"InventoryMovement", 'InventoryMovementType'>
    readonly quantity: FieldRef<"InventoryMovement", 'Int'>
    readonly appointmentId: FieldRef<"InventoryMovement", 'String'>
    readonly createdById: FieldRef<"InventoryMovement", 'String'>
    readonly notes: FieldRef<"InventoryMovement", 'String'>
    readonly createdAt: FieldRef<"InventoryMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement createManyAndReturn
   */
  export type InventoryMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
  }

  /**
   * InventoryMovement updateManyAndReturn
   */
  export type InventoryMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to delete.
     */
    limit?: number
  }

  /**
   * InventoryMovement.appointment
   */
  export type InventoryMovement$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model Specialty
   */

  export type AggregateSpecialty = {
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  export type SpecialtyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialtyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialty to aggregate.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialties
    **/
    _count?: true | SpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialtyMaxAggregateInputType
  }

  export type GetSpecialtyAggregateType<T extends SpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialty[P]>
      : GetScalarType<T[P], AggregateSpecialty[P]>
  }




  export type SpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithAggregationInput | SpecialtyOrderByWithAggregationInput[]
    by: SpecialtyScalarFieldEnum[] | SpecialtyScalarFieldEnum
    having?: SpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialtyCountAggregateInputType | true
    _min?: SpecialtyMinAggregateInputType
    _max?: SpecialtyMaxAggregateInputType
  }

  export type SpecialtyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  type GetSpecialtyGroupByPayload<T extends SpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type SpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procedures?: boolean | Specialty$proceduresArgs<ExtArgs>
    dentistSpecialties?: boolean | Specialty$dentistSpecialtiesArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialtyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["specialty"]>
  export type SpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedures?: boolean | Specialty$proceduresArgs<ExtArgs>
    dentistSpecialties?: boolean | Specialty$dentistSpecialtiesArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SpecialtyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specialty"
    objects: {
      procedures: Prisma.$ProcedurePayload<ExtArgs>[]
      dentistSpecialties: Prisma.$DentistSpecialtyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["specialty"]>
    composites: {}
  }

  type SpecialtyGetPayload<S extends boolean | null | undefined | SpecialtyDefaultArgs> = $Result.GetResult<Prisma.$SpecialtyPayload, S>

  type SpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecialtyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecialtyCountAggregateInputType | true
    }

  export interface SpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialty'], meta: { name: 'Specialty' } }
    /**
     * Find zero or one Specialty that matches the filter.
     * @param {SpecialtyFindUniqueArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialtyFindUniqueArgs>(args: SelectSubset<T, SpecialtyFindUniqueArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Specialty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecialtyFindUniqueOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialtyFindFirstArgs>(args?: SelectSubset<T, SpecialtyFindFirstArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Specialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialties
     * const specialties = await prisma.specialty.findMany()
     * 
     * // Get first 10 Specialties
     * const specialties = await prisma.specialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialtyWithIdOnly = await prisma.specialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialtyFindManyArgs>(args?: SelectSubset<T, SpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Specialty.
     * @param {SpecialtyCreateArgs} args - Arguments to create a Specialty.
     * @example
     * // Create one Specialty
     * const Specialty = await prisma.specialty.create({
     *   data: {
     *     // ... data to create a Specialty
     *   }
     * })
     * 
     */
    create<T extends SpecialtyCreateArgs>(args: SelectSubset<T, SpecialtyCreateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Specialties.
     * @param {SpecialtyCreateManyArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialtyCreateManyArgs>(args?: SelectSubset<T, SpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Specialties and returns the data saved in the database.
     * @param {SpecialtyCreateManyAndReturnArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Specialties and only return the `id`
     * const specialtyWithIdOnly = await prisma.specialty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Specialty.
     * @param {SpecialtyDeleteArgs} args - Arguments to delete one Specialty.
     * @example
     * // Delete one Specialty
     * const Specialty = await prisma.specialty.delete({
     *   where: {
     *     // ... filter to delete one Specialty
     *   }
     * })
     * 
     */
    delete<T extends SpecialtyDeleteArgs>(args: SelectSubset<T, SpecialtyDeleteArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Specialty.
     * @param {SpecialtyUpdateArgs} args - Arguments to update one Specialty.
     * @example
     * // Update one Specialty
     * const specialty = await prisma.specialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialtyUpdateArgs>(args: SelectSubset<T, SpecialtyUpdateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Specialties.
     * @param {SpecialtyDeleteManyArgs} args - Arguments to filter Specialties to delete.
     * @example
     * // Delete a few Specialties
     * const { count } = await prisma.specialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialtyDeleteManyArgs>(args?: SelectSubset<T, SpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialtyUpdateManyArgs>(args: SelectSubset<T, SpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties and returns the data updated in the database.
     * @param {SpecialtyUpdateManyAndReturnArgs} args - Arguments to update many Specialties.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Specialties and only return the `id`
     * const specialtyWithIdOnly = await prisma.specialty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecialtyUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecialtyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Specialty.
     * @param {SpecialtyUpsertArgs} args - Arguments to update or create a Specialty.
     * @example
     * // Update or create a Specialty
     * const specialty = await prisma.specialty.upsert({
     *   create: {
     *     // ... data to create a Specialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialty we want to update
     *   }
     * })
     */
    upsert<T extends SpecialtyUpsertArgs>(args: SelectSubset<T, SpecialtyUpsertArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyCountArgs} args - Arguments to filter Specialties to count.
     * @example
     * // Count the number of Specialties
     * const count = await prisma.specialty.count({
     *   where: {
     *     // ... the filter for the Specialties we want to count
     *   }
     * })
    **/
    count<T extends SpecialtyCountArgs>(
      args?: Subset<T, SpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialtyAggregateArgs>(args: Subset<T, SpecialtyAggregateArgs>): Prisma.PrismaPromise<GetSpecialtyAggregateType<T>>

    /**
     * Group by Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: SpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specialty model
   */
  readonly fields: SpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedures<T extends Specialty$proceduresArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$proceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dentistSpecialties<T extends Specialty$dentistSpecialtiesArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$dentistSpecialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Specialty model
   */
  interface SpecialtyFieldRefs {
    readonly id: FieldRef<"Specialty", 'String'>
    readonly name: FieldRef<"Specialty", 'String'>
    readonly description: FieldRef<"Specialty", 'String'>
    readonly createdAt: FieldRef<"Specialty", 'DateTime'>
    readonly updatedAt: FieldRef<"Specialty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Specialty findUnique
   */
  export type SpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findUniqueOrThrow
   */
  export type SpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findFirst
   */
  export type SpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findFirstOrThrow
   */
  export type SpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findMany
   */
  export type SpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialties to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty create
   */
  export type SpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialty.
     */
    data: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
  }

  /**
   * Specialty createMany
   */
  export type SpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialty createManyAndReturn
   */
  export type SpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialty update
   */
  export type SpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialty.
     */
    data: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
    /**
     * Choose, which Specialty to update.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty updateMany
   */
  export type SpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to update.
     */
    limit?: number
  }

  /**
   * Specialty updateManyAndReturn
   */
  export type SpecialtyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to update.
     */
    limit?: number
  }

  /**
   * Specialty upsert
   */
  export type SpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialty to update in case it exists.
     */
    where: SpecialtyWhereUniqueInput
    /**
     * In case the Specialty found by the `where` argument doesn't exist, create a new Specialty with this data.
     */
    create: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
    /**
     * In case the Specialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
  }

  /**
   * Specialty delete
   */
  export type SpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter which Specialty to delete.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty deleteMany
   */
  export type SpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialties to delete
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to delete.
     */
    limit?: number
  }

  /**
   * Specialty.procedures
   */
  export type Specialty$proceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    cursor?: ProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Specialty.dentistSpecialties
   */
  export type Specialty$dentistSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    where?: DentistSpecialtyWhereInput
    orderBy?: DentistSpecialtyOrderByWithRelationInput | DentistSpecialtyOrderByWithRelationInput[]
    cursor?: DentistSpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DentistSpecialtyScalarFieldEnum | DentistSpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty without action
   */
  export type SpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model CID
   */

  export type AggregateCID = {
    _count: CIDCountAggregateOutputType | null
    _min: CIDMinAggregateOutputType | null
    _max: CIDMaxAggregateOutputType | null
  }

  export type CIDMinAggregateOutputType = {
    id: string | null
    code: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CIDMaxAggregateOutputType = {
    id: string | null
    code: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CIDCountAggregateOutputType = {
    id: number
    code: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CIDMinAggregateInputType = {
    id?: true
    code?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CIDMaxAggregateInputType = {
    id?: true
    code?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CIDCountAggregateInputType = {
    id?: true
    code?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CIDAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CID to aggregate.
     */
    where?: CIDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CIDS to fetch.
     */
    orderBy?: CIDOrderByWithRelationInput | CIDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CIDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CIDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CIDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CIDS
    **/
    _count?: true | CIDCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CIDMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CIDMaxAggregateInputType
  }

  export type GetCIDAggregateType<T extends CIDAggregateArgs> = {
        [P in keyof T & keyof AggregateCID]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCID[P]>
      : GetScalarType<T[P], AggregateCID[P]>
  }




  export type CIDGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CIDWhereInput
    orderBy?: CIDOrderByWithAggregationInput | CIDOrderByWithAggregationInput[]
    by: CIDScalarFieldEnum[] | CIDScalarFieldEnum
    having?: CIDScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CIDCountAggregateInputType | true
    _min?: CIDMinAggregateInputType
    _max?: CIDMaxAggregateInputType
  }

  export type CIDGroupByOutputType = {
    id: string
    code: string
    category: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: CIDCountAggregateOutputType | null
    _min: CIDMinAggregateOutputType | null
    _max: CIDMaxAggregateOutputType | null
  }

  type GetCIDGroupByPayload<T extends CIDGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CIDGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CIDGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CIDGroupByOutputType[P]>
            : GetScalarType<T[P], CIDGroupByOutputType[P]>
        }
      >
    >


  export type CIDSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cID"]>

  export type CIDSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cID"]>

  export type CIDSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cID"]>

  export type CIDSelectScalar = {
    id?: boolean
    code?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CIDOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "category" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["cID"]>

  export type $CIDPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CID"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      category: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cID"]>
    composites: {}
  }

  type CIDGetPayload<S extends boolean | null | undefined | CIDDefaultArgs> = $Result.GetResult<Prisma.$CIDPayload, S>

  type CIDCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CIDFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CIDCountAggregateInputType | true
    }

  export interface CIDDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CID'], meta: { name: 'CID' } }
    /**
     * Find zero or one CID that matches the filter.
     * @param {CIDFindUniqueArgs} args - Arguments to find a CID
     * @example
     * // Get one CID
     * const cID = await prisma.cID.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CIDFindUniqueArgs>(args: SelectSubset<T, CIDFindUniqueArgs<ExtArgs>>): Prisma__CIDClient<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CID that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CIDFindUniqueOrThrowArgs} args - Arguments to find a CID
     * @example
     * // Get one CID
     * const cID = await prisma.cID.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CIDFindUniqueOrThrowArgs>(args: SelectSubset<T, CIDFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CIDClient<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CID that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIDFindFirstArgs} args - Arguments to find a CID
     * @example
     * // Get one CID
     * const cID = await prisma.cID.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CIDFindFirstArgs>(args?: SelectSubset<T, CIDFindFirstArgs<ExtArgs>>): Prisma__CIDClient<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CID that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIDFindFirstOrThrowArgs} args - Arguments to find a CID
     * @example
     * // Get one CID
     * const cID = await prisma.cID.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CIDFindFirstOrThrowArgs>(args?: SelectSubset<T, CIDFindFirstOrThrowArgs<ExtArgs>>): Prisma__CIDClient<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CIDS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIDFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CIDS
     * const cIDS = await prisma.cID.findMany()
     * 
     * // Get first 10 CIDS
     * const cIDS = await prisma.cID.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cIDWithIdOnly = await prisma.cID.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CIDFindManyArgs>(args?: SelectSubset<T, CIDFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CID.
     * @param {CIDCreateArgs} args - Arguments to create a CID.
     * @example
     * // Create one CID
     * const CID = await prisma.cID.create({
     *   data: {
     *     // ... data to create a CID
     *   }
     * })
     * 
     */
    create<T extends CIDCreateArgs>(args: SelectSubset<T, CIDCreateArgs<ExtArgs>>): Prisma__CIDClient<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CIDS.
     * @param {CIDCreateManyArgs} args - Arguments to create many CIDS.
     * @example
     * // Create many CIDS
     * const cID = await prisma.cID.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CIDCreateManyArgs>(args?: SelectSubset<T, CIDCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CIDS and returns the data saved in the database.
     * @param {CIDCreateManyAndReturnArgs} args - Arguments to create many CIDS.
     * @example
     * // Create many CIDS
     * const cID = await prisma.cID.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CIDS and only return the `id`
     * const cIDWithIdOnly = await prisma.cID.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CIDCreateManyAndReturnArgs>(args?: SelectSubset<T, CIDCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CID.
     * @param {CIDDeleteArgs} args - Arguments to delete one CID.
     * @example
     * // Delete one CID
     * const CID = await prisma.cID.delete({
     *   where: {
     *     // ... filter to delete one CID
     *   }
     * })
     * 
     */
    delete<T extends CIDDeleteArgs>(args: SelectSubset<T, CIDDeleteArgs<ExtArgs>>): Prisma__CIDClient<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CID.
     * @param {CIDUpdateArgs} args - Arguments to update one CID.
     * @example
     * // Update one CID
     * const cID = await prisma.cID.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CIDUpdateArgs>(args: SelectSubset<T, CIDUpdateArgs<ExtArgs>>): Prisma__CIDClient<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CIDS.
     * @param {CIDDeleteManyArgs} args - Arguments to filter CIDS to delete.
     * @example
     * // Delete a few CIDS
     * const { count } = await prisma.cID.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CIDDeleteManyArgs>(args?: SelectSubset<T, CIDDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CIDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIDUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CIDS
     * const cID = await prisma.cID.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CIDUpdateManyArgs>(args: SelectSubset<T, CIDUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CIDS and returns the data updated in the database.
     * @param {CIDUpdateManyAndReturnArgs} args - Arguments to update many CIDS.
     * @example
     * // Update many CIDS
     * const cID = await prisma.cID.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CIDS and only return the `id`
     * const cIDWithIdOnly = await prisma.cID.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CIDUpdateManyAndReturnArgs>(args: SelectSubset<T, CIDUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CID.
     * @param {CIDUpsertArgs} args - Arguments to update or create a CID.
     * @example
     * // Update or create a CID
     * const cID = await prisma.cID.upsert({
     *   create: {
     *     // ... data to create a CID
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CID we want to update
     *   }
     * })
     */
    upsert<T extends CIDUpsertArgs>(args: SelectSubset<T, CIDUpsertArgs<ExtArgs>>): Prisma__CIDClient<$Result.GetResult<Prisma.$CIDPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CIDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIDCountArgs} args - Arguments to filter CIDS to count.
     * @example
     * // Count the number of CIDS
     * const count = await prisma.cID.count({
     *   where: {
     *     // ... the filter for the CIDS we want to count
     *   }
     * })
    **/
    count<T extends CIDCountArgs>(
      args?: Subset<T, CIDCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CIDCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CID.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIDAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CIDAggregateArgs>(args: Subset<T, CIDAggregateArgs>): Prisma.PrismaPromise<GetCIDAggregateType<T>>

    /**
     * Group by CID.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIDGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CIDGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CIDGroupByArgs['orderBy'] }
        : { orderBy?: CIDGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CIDGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCIDGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CID model
   */
  readonly fields: CIDFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CID.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CIDClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CID model
   */
  interface CIDFieldRefs {
    readonly id: FieldRef<"CID", 'String'>
    readonly code: FieldRef<"CID", 'String'>
    readonly category: FieldRef<"CID", 'String'>
    readonly description: FieldRef<"CID", 'String'>
    readonly createdAt: FieldRef<"CID", 'DateTime'>
    readonly updatedAt: FieldRef<"CID", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CID findUnique
   */
  export type CIDFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * Filter, which CID to fetch.
     */
    where: CIDWhereUniqueInput
  }

  /**
   * CID findUniqueOrThrow
   */
  export type CIDFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * Filter, which CID to fetch.
     */
    where: CIDWhereUniqueInput
  }

  /**
   * CID findFirst
   */
  export type CIDFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * Filter, which CID to fetch.
     */
    where?: CIDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CIDS to fetch.
     */
    orderBy?: CIDOrderByWithRelationInput | CIDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CIDS.
     */
    cursor?: CIDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CIDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CIDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CIDS.
     */
    distinct?: CIDScalarFieldEnum | CIDScalarFieldEnum[]
  }

  /**
   * CID findFirstOrThrow
   */
  export type CIDFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * Filter, which CID to fetch.
     */
    where?: CIDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CIDS to fetch.
     */
    orderBy?: CIDOrderByWithRelationInput | CIDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CIDS.
     */
    cursor?: CIDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CIDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CIDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CIDS.
     */
    distinct?: CIDScalarFieldEnum | CIDScalarFieldEnum[]
  }

  /**
   * CID findMany
   */
  export type CIDFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * Filter, which CIDS to fetch.
     */
    where?: CIDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CIDS to fetch.
     */
    orderBy?: CIDOrderByWithRelationInput | CIDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CIDS.
     */
    cursor?: CIDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CIDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CIDS.
     */
    skip?: number
    distinct?: CIDScalarFieldEnum | CIDScalarFieldEnum[]
  }

  /**
   * CID create
   */
  export type CIDCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * The data needed to create a CID.
     */
    data: XOR<CIDCreateInput, CIDUncheckedCreateInput>
  }

  /**
   * CID createMany
   */
  export type CIDCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CIDS.
     */
    data: CIDCreateManyInput | CIDCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CID createManyAndReturn
   */
  export type CIDCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * The data used to create many CIDS.
     */
    data: CIDCreateManyInput | CIDCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CID update
   */
  export type CIDUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * The data needed to update a CID.
     */
    data: XOR<CIDUpdateInput, CIDUncheckedUpdateInput>
    /**
     * Choose, which CID to update.
     */
    where: CIDWhereUniqueInput
  }

  /**
   * CID updateMany
   */
  export type CIDUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CIDS.
     */
    data: XOR<CIDUpdateManyMutationInput, CIDUncheckedUpdateManyInput>
    /**
     * Filter which CIDS to update
     */
    where?: CIDWhereInput
    /**
     * Limit how many CIDS to update.
     */
    limit?: number
  }

  /**
   * CID updateManyAndReturn
   */
  export type CIDUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * The data used to update CIDS.
     */
    data: XOR<CIDUpdateManyMutationInput, CIDUncheckedUpdateManyInput>
    /**
     * Filter which CIDS to update
     */
    where?: CIDWhereInput
    /**
     * Limit how many CIDS to update.
     */
    limit?: number
  }

  /**
   * CID upsert
   */
  export type CIDUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * The filter to search for the CID to update in case it exists.
     */
    where: CIDWhereUniqueInput
    /**
     * In case the CID found by the `where` argument doesn't exist, create a new CID with this data.
     */
    create: XOR<CIDCreateInput, CIDUncheckedCreateInput>
    /**
     * In case the CID was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CIDUpdateInput, CIDUncheckedUpdateInput>
  }

  /**
   * CID delete
   */
  export type CIDDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
    /**
     * Filter which CID to delete.
     */
    where: CIDWhereUniqueInput
  }

  /**
   * CID deleteMany
   */
  export type CIDDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CIDS to delete
     */
    where?: CIDWhereInput
    /**
     * Limit how many CIDS to delete.
     */
    limit?: number
  }

  /**
   * CID without action
   */
  export type CIDDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CID
     */
    select?: CIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CID
     */
    omit?: CIDOmit<ExtArgs> | null
  }


  /**
   * Model Procedure
   */

  export type AggregateProcedure = {
    _count: ProcedureCountAggregateOutputType | null
    _avg: ProcedureAvgAggregateOutputType | null
    _sum: ProcedureSumAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  export type ProcedureAvgAggregateOutputType = {
    baseValue: Decimal | null
    commissionPercentage: Decimal | null
  }

  export type ProcedureSumAggregateOutputType = {
    baseValue: Decimal | null
    commissionPercentage: Decimal | null
  }

  export type ProcedureMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    specialtyId: string | null
    name: string | null
    description: string | null
    baseValue: Decimal | null
    commissionPercentage: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcedureMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    specialtyId: string | null
    name: string | null
    description: string | null
    baseValue: Decimal | null
    commissionPercentage: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcedureCountAggregateOutputType = {
    id: number
    clinicId: number
    specialtyId: number
    name: number
    description: number
    baseValue: number
    commissionPercentage: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcedureAvgAggregateInputType = {
    baseValue?: true
    commissionPercentage?: true
  }

  export type ProcedureSumAggregateInputType = {
    baseValue?: true
    commissionPercentage?: true
  }

  export type ProcedureMinAggregateInputType = {
    id?: true
    clinicId?: true
    specialtyId?: true
    name?: true
    description?: true
    baseValue?: true
    commissionPercentage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcedureMaxAggregateInputType = {
    id?: true
    clinicId?: true
    specialtyId?: true
    name?: true
    description?: true
    baseValue?: true
    commissionPercentage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcedureCountAggregateInputType = {
    id?: true
    clinicId?: true
    specialtyId?: true
    name?: true
    description?: true
    baseValue?: true
    commissionPercentage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcedureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedure to aggregate.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procedures
    **/
    _count?: true | ProcedureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcedureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcedureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedureMaxAggregateInputType
  }

  export type GetProcedureAggregateType<T extends ProcedureAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedure[P]>
      : GetScalarType<T[P], AggregateProcedure[P]>
  }




  export type ProcedureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithAggregationInput | ProcedureOrderByWithAggregationInput[]
    by: ProcedureScalarFieldEnum[] | ProcedureScalarFieldEnum
    having?: ProcedureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedureCountAggregateInputType | true
    _avg?: ProcedureAvgAggregateInputType
    _sum?: ProcedureSumAggregateInputType
    _min?: ProcedureMinAggregateInputType
    _max?: ProcedureMaxAggregateInputType
  }

  export type ProcedureGroupByOutputType = {
    id: string
    clinicId: string
    specialtyId: string
    name: string
    description: string | null
    baseValue: Decimal
    commissionPercentage: Decimal
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProcedureCountAggregateOutputType | null
    _avg: ProcedureAvgAggregateOutputType | null
    _sum: ProcedureSumAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  type GetProcedureGroupByPayload<T extends ProcedureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
        }
      >
    >


  export type ProcedureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    specialtyId?: boolean
    name?: boolean
    description?: boolean
    baseValue?: boolean
    commissionPercentage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
    dentistProcedures?: boolean | Procedure$dentistProceduresArgs<ExtArgs>
    appointments?: boolean | Procedure$appointmentsArgs<ExtArgs>
    attendanceProcedures?: boolean | Procedure$attendanceProceduresArgs<ExtArgs>
    treatmentItems?: boolean | Procedure$treatmentItemsArgs<ExtArgs>
    _count?: boolean | ProcedureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    specialtyId?: boolean
    name?: boolean
    description?: boolean
    baseValue?: boolean
    commissionPercentage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    specialtyId?: boolean
    name?: boolean
    description?: boolean
    baseValue?: boolean
    commissionPercentage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectScalar = {
    id?: boolean
    clinicId?: boolean
    specialtyId?: boolean
    name?: boolean
    description?: boolean
    baseValue?: boolean
    commissionPercentage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcedureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "specialtyId" | "name" | "description" | "baseValue" | "commissionPercentage" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["procedure"]>
  export type ProcedureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
    dentistProcedures?: boolean | Procedure$dentistProceduresArgs<ExtArgs>
    appointments?: boolean | Procedure$appointmentsArgs<ExtArgs>
    attendanceProcedures?: boolean | Procedure$attendanceProceduresArgs<ExtArgs>
    treatmentItems?: boolean | Procedure$treatmentItemsArgs<ExtArgs>
    _count?: boolean | ProcedureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcedureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }
  export type ProcedureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }

  export type $ProcedurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Procedure"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      specialty: Prisma.$SpecialtyPayload<ExtArgs>
      dentistProcedures: Prisma.$DentistProcedurePayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      attendanceProcedures: Prisma.$AttendanceProcedurePayload<ExtArgs>[]
      treatmentItems: Prisma.$TreatmentItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      specialtyId: string
      name: string
      description: string | null
      baseValue: Prisma.Decimal
      commissionPercentage: Prisma.Decimal
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["procedure"]>
    composites: {}
  }

  type ProcedureGetPayload<S extends boolean | null | undefined | ProcedureDefaultArgs> = $Result.GetResult<Prisma.$ProcedurePayload, S>

  type ProcedureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcedureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcedureCountAggregateInputType | true
    }

  export interface ProcedureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Procedure'], meta: { name: 'Procedure' } }
    /**
     * Find zero or one Procedure that matches the filter.
     * @param {ProcedureFindUniqueArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedureFindUniqueArgs>(args: SelectSubset<T, ProcedureFindUniqueArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Procedure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcedureFindUniqueOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedureFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Procedure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedureFindFirstArgs>(args?: SelectSubset<T, ProcedureFindFirstArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Procedure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedureFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Procedures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedures
     * const procedures = await prisma.procedure.findMany()
     * 
     * // Get first 10 Procedures
     * const procedures = await prisma.procedure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procedureWithIdOnly = await prisma.procedure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcedureFindManyArgs>(args?: SelectSubset<T, ProcedureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Procedure.
     * @param {ProcedureCreateArgs} args - Arguments to create a Procedure.
     * @example
     * // Create one Procedure
     * const Procedure = await prisma.procedure.create({
     *   data: {
     *     // ... data to create a Procedure
     *   }
     * })
     * 
     */
    create<T extends ProcedureCreateArgs>(args: SelectSubset<T, ProcedureCreateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Procedures.
     * @param {ProcedureCreateManyArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedureCreateManyArgs>(args?: SelectSubset<T, ProcedureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Procedures and returns the data saved in the database.
     * @param {ProcedureCreateManyAndReturnArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Procedures and only return the `id`
     * const procedureWithIdOnly = await prisma.procedure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcedureCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcedureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Procedure.
     * @param {ProcedureDeleteArgs} args - Arguments to delete one Procedure.
     * @example
     * // Delete one Procedure
     * const Procedure = await prisma.procedure.delete({
     *   where: {
     *     // ... filter to delete one Procedure
     *   }
     * })
     * 
     */
    delete<T extends ProcedureDeleteArgs>(args: SelectSubset<T, ProcedureDeleteArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Procedure.
     * @param {ProcedureUpdateArgs} args - Arguments to update one Procedure.
     * @example
     * // Update one Procedure
     * const procedure = await prisma.procedure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedureUpdateArgs>(args: SelectSubset<T, ProcedureUpdateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Procedures.
     * @param {ProcedureDeleteManyArgs} args - Arguments to filter Procedures to delete.
     * @example
     * // Delete a few Procedures
     * const { count } = await prisma.procedure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedureDeleteManyArgs>(args?: SelectSubset<T, ProcedureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedures
     * const procedure = await prisma.procedure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedureUpdateManyArgs>(args: SelectSubset<T, ProcedureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedures and returns the data updated in the database.
     * @param {ProcedureUpdateManyAndReturnArgs} args - Arguments to update many Procedures.
     * @example
     * // Update many Procedures
     * const procedure = await prisma.procedure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Procedures and only return the `id`
     * const procedureWithIdOnly = await prisma.procedure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcedureUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcedureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Procedure.
     * @param {ProcedureUpsertArgs} args - Arguments to update or create a Procedure.
     * @example
     * // Update or create a Procedure
     * const procedure = await prisma.procedure.upsert({
     *   create: {
     *     // ... data to create a Procedure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedure we want to update
     *   }
     * })
     */
    upsert<T extends ProcedureUpsertArgs>(args: SelectSubset<T, ProcedureUpsertArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureCountArgs} args - Arguments to filter Procedures to count.
     * @example
     * // Count the number of Procedures
     * const count = await prisma.procedure.count({
     *   where: {
     *     // ... the filter for the Procedures we want to count
     *   }
     * })
    **/
    count<T extends ProcedureCountArgs>(
      args?: Subset<T, ProcedureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedureAggregateArgs>(args: Subset<T, ProcedureAggregateArgs>): Prisma.PrismaPromise<GetProcedureAggregateType<T>>

    /**
     * Group by Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedureGroupByArgs['orderBy'] }
        : { orderBy?: ProcedureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Procedure model
   */
  readonly fields: ProcedureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Procedure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    specialty<T extends SpecialtyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyDefaultArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dentistProcedures<T extends Procedure$dentistProceduresArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$dentistProceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Procedure$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceProcedures<T extends Procedure$attendanceProceduresArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$attendanceProceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treatmentItems<T extends Procedure$treatmentItemsArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$treatmentItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Procedure model
   */
  interface ProcedureFieldRefs {
    readonly id: FieldRef<"Procedure", 'String'>
    readonly clinicId: FieldRef<"Procedure", 'String'>
    readonly specialtyId: FieldRef<"Procedure", 'String'>
    readonly name: FieldRef<"Procedure", 'String'>
    readonly description: FieldRef<"Procedure", 'String'>
    readonly baseValue: FieldRef<"Procedure", 'Decimal'>
    readonly commissionPercentage: FieldRef<"Procedure", 'Decimal'>
    readonly isActive: FieldRef<"Procedure", 'Boolean'>
    readonly createdAt: FieldRef<"Procedure", 'DateTime'>
    readonly updatedAt: FieldRef<"Procedure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Procedure findUnique
   */
  export type ProcedureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findUniqueOrThrow
   */
  export type ProcedureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findFirst
   */
  export type ProcedureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findFirstOrThrow
   */
  export type ProcedureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findMany
   */
  export type ProcedureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedures to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure create
   */
  export type ProcedureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to create a Procedure.
     */
    data: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
  }

  /**
   * Procedure createMany
   */
  export type ProcedureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedure createManyAndReturn
   */
  export type ProcedureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Procedure update
   */
  export type ProcedureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to update a Procedure.
     */
    data: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
    /**
     * Choose, which Procedure to update.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure updateMany
   */
  export type ProcedureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procedures.
     */
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyInput>
    /**
     * Filter which Procedures to update
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to update.
     */
    limit?: number
  }

  /**
   * Procedure updateManyAndReturn
   */
  export type ProcedureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * The data used to update Procedures.
     */
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyInput>
    /**
     * Filter which Procedures to update
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Procedure upsert
   */
  export type ProcedureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The filter to search for the Procedure to update in case it exists.
     */
    where: ProcedureWhereUniqueInput
    /**
     * In case the Procedure found by the `where` argument doesn't exist, create a new Procedure with this data.
     */
    create: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
    /**
     * In case the Procedure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
  }

  /**
   * Procedure delete
   */
  export type ProcedureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter which Procedure to delete.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure deleteMany
   */
  export type ProcedureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedures to delete
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to delete.
     */
    limit?: number
  }

  /**
   * Procedure.dentistProcedures
   */
  export type Procedure$dentistProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    where?: DentistProcedureWhereInput
    orderBy?: DentistProcedureOrderByWithRelationInput | DentistProcedureOrderByWithRelationInput[]
    cursor?: DentistProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DentistProcedureScalarFieldEnum | DentistProcedureScalarFieldEnum[]
  }

  /**
   * Procedure.appointments
   */
  export type Procedure$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Procedure.attendanceProcedures
   */
  export type Procedure$attendanceProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    where?: AttendanceProcedureWhereInput
    orderBy?: AttendanceProcedureOrderByWithRelationInput | AttendanceProcedureOrderByWithRelationInput[]
    cursor?: AttendanceProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceProcedureScalarFieldEnum | AttendanceProcedureScalarFieldEnum[]
  }

  /**
   * Procedure.treatmentItems
   */
  export type Procedure$treatmentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentItem
     */
    select?: TreatmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreatmentItem
     */
    omit?: TreatmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentItemInclude<ExtArgs> | null
    where?: TreatmentItemWhereInput
    orderBy?: TreatmentItemOrderByWithRelationInput | TreatmentItemOrderByWithRelationInput[]
    cursor?: TreatmentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentItemScalarFieldEnum | TreatmentItemScalarFieldEnum[]
  }

  /**
   * Procedure without action
   */
  export type ProcedureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
  }


  /**
   * Model DentistProcedure
   */

  export type AggregateDentistProcedure = {
    _count: DentistProcedureCountAggregateOutputType | null
    _min: DentistProcedureMinAggregateOutputType | null
    _max: DentistProcedureMaxAggregateOutputType | null
  }

  export type DentistProcedureMinAggregateOutputType = {
    id: string | null
    dentistId: string | null
    procedureId: string | null
    createdAt: Date | null
  }

  export type DentistProcedureMaxAggregateOutputType = {
    id: string | null
    dentistId: string | null
    procedureId: string | null
    createdAt: Date | null
  }

  export type DentistProcedureCountAggregateOutputType = {
    id: number
    dentistId: number
    procedureId: number
    createdAt: number
    _all: number
  }


  export type DentistProcedureMinAggregateInputType = {
    id?: true
    dentistId?: true
    procedureId?: true
    createdAt?: true
  }

  export type DentistProcedureMaxAggregateInputType = {
    id?: true
    dentistId?: true
    procedureId?: true
    createdAt?: true
  }

  export type DentistProcedureCountAggregateInputType = {
    id?: true
    dentistId?: true
    procedureId?: true
    createdAt?: true
    _all?: true
  }

  export type DentistProcedureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DentistProcedure to aggregate.
     */
    where?: DentistProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DentistProcedures to fetch.
     */
    orderBy?: DentistProcedureOrderByWithRelationInput | DentistProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DentistProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DentistProcedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DentistProcedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DentistProcedures
    **/
    _count?: true | DentistProcedureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DentistProcedureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DentistProcedureMaxAggregateInputType
  }

  export type GetDentistProcedureAggregateType<T extends DentistProcedureAggregateArgs> = {
        [P in keyof T & keyof AggregateDentistProcedure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDentistProcedure[P]>
      : GetScalarType<T[P], AggregateDentistProcedure[P]>
  }




  export type DentistProcedureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DentistProcedureWhereInput
    orderBy?: DentistProcedureOrderByWithAggregationInput | DentistProcedureOrderByWithAggregationInput[]
    by: DentistProcedureScalarFieldEnum[] | DentistProcedureScalarFieldEnum
    having?: DentistProcedureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DentistProcedureCountAggregateInputType | true
    _min?: DentistProcedureMinAggregateInputType
    _max?: DentistProcedureMaxAggregateInputType
  }

  export type DentistProcedureGroupByOutputType = {
    id: string
    dentistId: string
    procedureId: string
    createdAt: Date
    _count: DentistProcedureCountAggregateOutputType | null
    _min: DentistProcedureMinAggregateOutputType | null
    _max: DentistProcedureMaxAggregateOutputType | null
  }

  type GetDentistProcedureGroupByPayload<T extends DentistProcedureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DentistProcedureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DentistProcedureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DentistProcedureGroupByOutputType[P]>
            : GetScalarType<T[P], DentistProcedureGroupByOutputType[P]>
        }
      >
    >


  export type DentistProcedureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dentistId?: boolean
    procedureId?: boolean
    createdAt?: boolean
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentistProcedure"]>

  export type DentistProcedureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dentistId?: boolean
    procedureId?: boolean
    createdAt?: boolean
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentistProcedure"]>

  export type DentistProcedureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dentistId?: boolean
    procedureId?: boolean
    createdAt?: boolean
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentistProcedure"]>

  export type DentistProcedureSelectScalar = {
    id?: boolean
    dentistId?: boolean
    procedureId?: boolean
    createdAt?: boolean
  }

  export type DentistProcedureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dentistId" | "procedureId" | "createdAt", ExtArgs["result"]["dentistProcedure"]>
  export type DentistProcedureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }
  export type DentistProcedureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }
  export type DentistProcedureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }

  export type $DentistProcedurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DentistProcedure"
    objects: {
      dentist: Prisma.$DentistPayload<ExtArgs>
      procedure: Prisma.$ProcedurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dentistId: string
      procedureId: string
      createdAt: Date
    }, ExtArgs["result"]["dentistProcedure"]>
    composites: {}
  }

  type DentistProcedureGetPayload<S extends boolean | null | undefined | DentistProcedureDefaultArgs> = $Result.GetResult<Prisma.$DentistProcedurePayload, S>

  type DentistProcedureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DentistProcedureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DentistProcedureCountAggregateInputType | true
    }

  export interface DentistProcedureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DentistProcedure'], meta: { name: 'DentistProcedure' } }
    /**
     * Find zero or one DentistProcedure that matches the filter.
     * @param {DentistProcedureFindUniqueArgs} args - Arguments to find a DentistProcedure
     * @example
     * // Get one DentistProcedure
     * const dentistProcedure = await prisma.dentistProcedure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DentistProcedureFindUniqueArgs>(args: SelectSubset<T, DentistProcedureFindUniqueArgs<ExtArgs>>): Prisma__DentistProcedureClient<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DentistProcedure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DentistProcedureFindUniqueOrThrowArgs} args - Arguments to find a DentistProcedure
     * @example
     * // Get one DentistProcedure
     * const dentistProcedure = await prisma.dentistProcedure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DentistProcedureFindUniqueOrThrowArgs>(args: SelectSubset<T, DentistProcedureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DentistProcedureClient<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DentistProcedure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistProcedureFindFirstArgs} args - Arguments to find a DentistProcedure
     * @example
     * // Get one DentistProcedure
     * const dentistProcedure = await prisma.dentistProcedure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DentistProcedureFindFirstArgs>(args?: SelectSubset<T, DentistProcedureFindFirstArgs<ExtArgs>>): Prisma__DentistProcedureClient<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DentistProcedure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistProcedureFindFirstOrThrowArgs} args - Arguments to find a DentistProcedure
     * @example
     * // Get one DentistProcedure
     * const dentistProcedure = await prisma.dentistProcedure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DentistProcedureFindFirstOrThrowArgs>(args?: SelectSubset<T, DentistProcedureFindFirstOrThrowArgs<ExtArgs>>): Prisma__DentistProcedureClient<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DentistProcedures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistProcedureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DentistProcedures
     * const dentistProcedures = await prisma.dentistProcedure.findMany()
     * 
     * // Get first 10 DentistProcedures
     * const dentistProcedures = await prisma.dentistProcedure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dentistProcedureWithIdOnly = await prisma.dentistProcedure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DentistProcedureFindManyArgs>(args?: SelectSubset<T, DentistProcedureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DentistProcedure.
     * @param {DentistProcedureCreateArgs} args - Arguments to create a DentistProcedure.
     * @example
     * // Create one DentistProcedure
     * const DentistProcedure = await prisma.dentistProcedure.create({
     *   data: {
     *     // ... data to create a DentistProcedure
     *   }
     * })
     * 
     */
    create<T extends DentistProcedureCreateArgs>(args: SelectSubset<T, DentistProcedureCreateArgs<ExtArgs>>): Prisma__DentistProcedureClient<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DentistProcedures.
     * @param {DentistProcedureCreateManyArgs} args - Arguments to create many DentistProcedures.
     * @example
     * // Create many DentistProcedures
     * const dentistProcedure = await prisma.dentistProcedure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DentistProcedureCreateManyArgs>(args?: SelectSubset<T, DentistProcedureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DentistProcedures and returns the data saved in the database.
     * @param {DentistProcedureCreateManyAndReturnArgs} args - Arguments to create many DentistProcedures.
     * @example
     * // Create many DentistProcedures
     * const dentistProcedure = await prisma.dentistProcedure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DentistProcedures and only return the `id`
     * const dentistProcedureWithIdOnly = await prisma.dentistProcedure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DentistProcedureCreateManyAndReturnArgs>(args?: SelectSubset<T, DentistProcedureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DentistProcedure.
     * @param {DentistProcedureDeleteArgs} args - Arguments to delete one DentistProcedure.
     * @example
     * // Delete one DentistProcedure
     * const DentistProcedure = await prisma.dentistProcedure.delete({
     *   where: {
     *     // ... filter to delete one DentistProcedure
     *   }
     * })
     * 
     */
    delete<T extends DentistProcedureDeleteArgs>(args: SelectSubset<T, DentistProcedureDeleteArgs<ExtArgs>>): Prisma__DentistProcedureClient<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DentistProcedure.
     * @param {DentistProcedureUpdateArgs} args - Arguments to update one DentistProcedure.
     * @example
     * // Update one DentistProcedure
     * const dentistProcedure = await prisma.dentistProcedure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DentistProcedureUpdateArgs>(args: SelectSubset<T, DentistProcedureUpdateArgs<ExtArgs>>): Prisma__DentistProcedureClient<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DentistProcedures.
     * @param {DentistProcedureDeleteManyArgs} args - Arguments to filter DentistProcedures to delete.
     * @example
     * // Delete a few DentistProcedures
     * const { count } = await prisma.dentistProcedure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DentistProcedureDeleteManyArgs>(args?: SelectSubset<T, DentistProcedureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DentistProcedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistProcedureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DentistProcedures
     * const dentistProcedure = await prisma.dentistProcedure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DentistProcedureUpdateManyArgs>(args: SelectSubset<T, DentistProcedureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DentistProcedures and returns the data updated in the database.
     * @param {DentistProcedureUpdateManyAndReturnArgs} args - Arguments to update many DentistProcedures.
     * @example
     * // Update many DentistProcedures
     * const dentistProcedure = await prisma.dentistProcedure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DentistProcedures and only return the `id`
     * const dentistProcedureWithIdOnly = await prisma.dentistProcedure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DentistProcedureUpdateManyAndReturnArgs>(args: SelectSubset<T, DentistProcedureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DentistProcedure.
     * @param {DentistProcedureUpsertArgs} args - Arguments to update or create a DentistProcedure.
     * @example
     * // Update or create a DentistProcedure
     * const dentistProcedure = await prisma.dentistProcedure.upsert({
     *   create: {
     *     // ... data to create a DentistProcedure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DentistProcedure we want to update
     *   }
     * })
     */
    upsert<T extends DentistProcedureUpsertArgs>(args: SelectSubset<T, DentistProcedureUpsertArgs<ExtArgs>>): Prisma__DentistProcedureClient<$Result.GetResult<Prisma.$DentistProcedurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DentistProcedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistProcedureCountArgs} args - Arguments to filter DentistProcedures to count.
     * @example
     * // Count the number of DentistProcedures
     * const count = await prisma.dentistProcedure.count({
     *   where: {
     *     // ... the filter for the DentistProcedures we want to count
     *   }
     * })
    **/
    count<T extends DentistProcedureCountArgs>(
      args?: Subset<T, DentistProcedureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DentistProcedureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DentistProcedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistProcedureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DentistProcedureAggregateArgs>(args: Subset<T, DentistProcedureAggregateArgs>): Prisma.PrismaPromise<GetDentistProcedureAggregateType<T>>

    /**
     * Group by DentistProcedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistProcedureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DentistProcedureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DentistProcedureGroupByArgs['orderBy'] }
        : { orderBy?: DentistProcedureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DentistProcedureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDentistProcedureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DentistProcedure model
   */
  readonly fields: DentistProcedureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DentistProcedure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DentistProcedureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dentist<T extends DentistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DentistDefaultArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    procedure<T extends ProcedureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcedureDefaultArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DentistProcedure model
   */
  interface DentistProcedureFieldRefs {
    readonly id: FieldRef<"DentistProcedure", 'String'>
    readonly dentistId: FieldRef<"DentistProcedure", 'String'>
    readonly procedureId: FieldRef<"DentistProcedure", 'String'>
    readonly createdAt: FieldRef<"DentistProcedure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DentistProcedure findUnique
   */
  export type DentistProcedureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * Filter, which DentistProcedure to fetch.
     */
    where: DentistProcedureWhereUniqueInput
  }

  /**
   * DentistProcedure findUniqueOrThrow
   */
  export type DentistProcedureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * Filter, which DentistProcedure to fetch.
     */
    where: DentistProcedureWhereUniqueInput
  }

  /**
   * DentistProcedure findFirst
   */
  export type DentistProcedureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * Filter, which DentistProcedure to fetch.
     */
    where?: DentistProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DentistProcedures to fetch.
     */
    orderBy?: DentistProcedureOrderByWithRelationInput | DentistProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DentistProcedures.
     */
    cursor?: DentistProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DentistProcedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DentistProcedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DentistProcedures.
     */
    distinct?: DentistProcedureScalarFieldEnum | DentistProcedureScalarFieldEnum[]
  }

  /**
   * DentistProcedure findFirstOrThrow
   */
  export type DentistProcedureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * Filter, which DentistProcedure to fetch.
     */
    where?: DentistProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DentistProcedures to fetch.
     */
    orderBy?: DentistProcedureOrderByWithRelationInput | DentistProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DentistProcedures.
     */
    cursor?: DentistProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DentistProcedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DentistProcedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DentistProcedures.
     */
    distinct?: DentistProcedureScalarFieldEnum | DentistProcedureScalarFieldEnum[]
  }

  /**
   * DentistProcedure findMany
   */
  export type DentistProcedureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * Filter, which DentistProcedures to fetch.
     */
    where?: DentistProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DentistProcedures to fetch.
     */
    orderBy?: DentistProcedureOrderByWithRelationInput | DentistProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DentistProcedures.
     */
    cursor?: DentistProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DentistProcedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DentistProcedures.
     */
    skip?: number
    distinct?: DentistProcedureScalarFieldEnum | DentistProcedureScalarFieldEnum[]
  }

  /**
   * DentistProcedure create
   */
  export type DentistProcedureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * The data needed to create a DentistProcedure.
     */
    data: XOR<DentistProcedureCreateInput, DentistProcedureUncheckedCreateInput>
  }

  /**
   * DentistProcedure createMany
   */
  export type DentistProcedureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DentistProcedures.
     */
    data: DentistProcedureCreateManyInput | DentistProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DentistProcedure createManyAndReturn
   */
  export type DentistProcedureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * The data used to create many DentistProcedures.
     */
    data: DentistProcedureCreateManyInput | DentistProcedureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DentistProcedure update
   */
  export type DentistProcedureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * The data needed to update a DentistProcedure.
     */
    data: XOR<DentistProcedureUpdateInput, DentistProcedureUncheckedUpdateInput>
    /**
     * Choose, which DentistProcedure to update.
     */
    where: DentistProcedureWhereUniqueInput
  }

  /**
   * DentistProcedure updateMany
   */
  export type DentistProcedureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DentistProcedures.
     */
    data: XOR<DentistProcedureUpdateManyMutationInput, DentistProcedureUncheckedUpdateManyInput>
    /**
     * Filter which DentistProcedures to update
     */
    where?: DentistProcedureWhereInput
    /**
     * Limit how many DentistProcedures to update.
     */
    limit?: number
  }

  /**
   * DentistProcedure updateManyAndReturn
   */
  export type DentistProcedureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * The data used to update DentistProcedures.
     */
    data: XOR<DentistProcedureUpdateManyMutationInput, DentistProcedureUncheckedUpdateManyInput>
    /**
     * Filter which DentistProcedures to update
     */
    where?: DentistProcedureWhereInput
    /**
     * Limit how many DentistProcedures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DentistProcedure upsert
   */
  export type DentistProcedureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * The filter to search for the DentistProcedure to update in case it exists.
     */
    where: DentistProcedureWhereUniqueInput
    /**
     * In case the DentistProcedure found by the `where` argument doesn't exist, create a new DentistProcedure with this data.
     */
    create: XOR<DentistProcedureCreateInput, DentistProcedureUncheckedCreateInput>
    /**
     * In case the DentistProcedure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DentistProcedureUpdateInput, DentistProcedureUncheckedUpdateInput>
  }

  /**
   * DentistProcedure delete
   */
  export type DentistProcedureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
    /**
     * Filter which DentistProcedure to delete.
     */
    where: DentistProcedureWhereUniqueInput
  }

  /**
   * DentistProcedure deleteMany
   */
  export type DentistProcedureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DentistProcedures to delete
     */
    where?: DentistProcedureWhereInput
    /**
     * Limit how many DentistProcedures to delete.
     */
    limit?: number
  }

  /**
   * DentistProcedure without action
   */
  export type DentistProcedureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistProcedure
     */
    select?: DentistProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistProcedure
     */
    omit?: DentistProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistProcedureInclude<ExtArgs> | null
  }


  /**
   * Model DentistSpecialty
   */

  export type AggregateDentistSpecialty = {
    _count: DentistSpecialtyCountAggregateOutputType | null
    _min: DentistSpecialtyMinAggregateOutputType | null
    _max: DentistSpecialtyMaxAggregateOutputType | null
  }

  export type DentistSpecialtyMinAggregateOutputType = {
    id: string | null
    dentistId: string | null
    specialtyId: string | null
    createdAt: Date | null
  }

  export type DentistSpecialtyMaxAggregateOutputType = {
    id: string | null
    dentistId: string | null
    specialtyId: string | null
    createdAt: Date | null
  }

  export type DentistSpecialtyCountAggregateOutputType = {
    id: number
    dentistId: number
    specialtyId: number
    createdAt: number
    _all: number
  }


  export type DentistSpecialtyMinAggregateInputType = {
    id?: true
    dentistId?: true
    specialtyId?: true
    createdAt?: true
  }

  export type DentistSpecialtyMaxAggregateInputType = {
    id?: true
    dentistId?: true
    specialtyId?: true
    createdAt?: true
  }

  export type DentistSpecialtyCountAggregateInputType = {
    id?: true
    dentistId?: true
    specialtyId?: true
    createdAt?: true
    _all?: true
  }

  export type DentistSpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DentistSpecialty to aggregate.
     */
    where?: DentistSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DentistSpecialties to fetch.
     */
    orderBy?: DentistSpecialtyOrderByWithRelationInput | DentistSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DentistSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DentistSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DentistSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DentistSpecialties
    **/
    _count?: true | DentistSpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DentistSpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DentistSpecialtyMaxAggregateInputType
  }

  export type GetDentistSpecialtyAggregateType<T extends DentistSpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateDentistSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDentistSpecialty[P]>
      : GetScalarType<T[P], AggregateDentistSpecialty[P]>
  }




  export type DentistSpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DentistSpecialtyWhereInput
    orderBy?: DentistSpecialtyOrderByWithAggregationInput | DentistSpecialtyOrderByWithAggregationInput[]
    by: DentistSpecialtyScalarFieldEnum[] | DentistSpecialtyScalarFieldEnum
    having?: DentistSpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DentistSpecialtyCountAggregateInputType | true
    _min?: DentistSpecialtyMinAggregateInputType
    _max?: DentistSpecialtyMaxAggregateInputType
  }

  export type DentistSpecialtyGroupByOutputType = {
    id: string
    dentistId: string
    specialtyId: string
    createdAt: Date
    _count: DentistSpecialtyCountAggregateOutputType | null
    _min: DentistSpecialtyMinAggregateOutputType | null
    _max: DentistSpecialtyMaxAggregateOutputType | null
  }

  type GetDentistSpecialtyGroupByPayload<T extends DentistSpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DentistSpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DentistSpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DentistSpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], DentistSpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type DentistSpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dentistId?: boolean
    specialtyId?: boolean
    createdAt?: boolean
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentistSpecialty"]>

  export type DentistSpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dentistId?: boolean
    specialtyId?: boolean
    createdAt?: boolean
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentistSpecialty"]>

  export type DentistSpecialtySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dentistId?: boolean
    specialtyId?: boolean
    createdAt?: boolean
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dentistSpecialty"]>

  export type DentistSpecialtySelectScalar = {
    id?: boolean
    dentistId?: boolean
    specialtyId?: boolean
    createdAt?: boolean
  }

  export type DentistSpecialtyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dentistId" | "specialtyId" | "createdAt", ExtArgs["result"]["dentistSpecialty"]>
  export type DentistSpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }
  export type DentistSpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }
  export type DentistSpecialtyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dentist?: boolean | DentistDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }

  export type $DentistSpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DentistSpecialty"
    objects: {
      dentist: Prisma.$DentistPayload<ExtArgs>
      specialty: Prisma.$SpecialtyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dentistId: string
      specialtyId: string
      createdAt: Date
    }, ExtArgs["result"]["dentistSpecialty"]>
    composites: {}
  }

  type DentistSpecialtyGetPayload<S extends boolean | null | undefined | DentistSpecialtyDefaultArgs> = $Result.GetResult<Prisma.$DentistSpecialtyPayload, S>

  type DentistSpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DentistSpecialtyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DentistSpecialtyCountAggregateInputType | true
    }

  export interface DentistSpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DentistSpecialty'], meta: { name: 'DentistSpecialty' } }
    /**
     * Find zero or one DentistSpecialty that matches the filter.
     * @param {DentistSpecialtyFindUniqueArgs} args - Arguments to find a DentistSpecialty
     * @example
     * // Get one DentistSpecialty
     * const dentistSpecialty = await prisma.dentistSpecialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DentistSpecialtyFindUniqueArgs>(args: SelectSubset<T, DentistSpecialtyFindUniqueArgs<ExtArgs>>): Prisma__DentistSpecialtyClient<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DentistSpecialty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DentistSpecialtyFindUniqueOrThrowArgs} args - Arguments to find a DentistSpecialty
     * @example
     * // Get one DentistSpecialty
     * const dentistSpecialty = await prisma.dentistSpecialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DentistSpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, DentistSpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DentistSpecialtyClient<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DentistSpecialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistSpecialtyFindFirstArgs} args - Arguments to find a DentistSpecialty
     * @example
     * // Get one DentistSpecialty
     * const dentistSpecialty = await prisma.dentistSpecialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DentistSpecialtyFindFirstArgs>(args?: SelectSubset<T, DentistSpecialtyFindFirstArgs<ExtArgs>>): Prisma__DentistSpecialtyClient<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DentistSpecialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistSpecialtyFindFirstOrThrowArgs} args - Arguments to find a DentistSpecialty
     * @example
     * // Get one DentistSpecialty
     * const dentistSpecialty = await prisma.dentistSpecialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DentistSpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, DentistSpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DentistSpecialtyClient<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DentistSpecialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistSpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DentistSpecialties
     * const dentistSpecialties = await prisma.dentistSpecialty.findMany()
     * 
     * // Get first 10 DentistSpecialties
     * const dentistSpecialties = await prisma.dentistSpecialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dentistSpecialtyWithIdOnly = await prisma.dentistSpecialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DentistSpecialtyFindManyArgs>(args?: SelectSubset<T, DentistSpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DentistSpecialty.
     * @param {DentistSpecialtyCreateArgs} args - Arguments to create a DentistSpecialty.
     * @example
     * // Create one DentistSpecialty
     * const DentistSpecialty = await prisma.dentistSpecialty.create({
     *   data: {
     *     // ... data to create a DentistSpecialty
     *   }
     * })
     * 
     */
    create<T extends DentistSpecialtyCreateArgs>(args: SelectSubset<T, DentistSpecialtyCreateArgs<ExtArgs>>): Prisma__DentistSpecialtyClient<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DentistSpecialties.
     * @param {DentistSpecialtyCreateManyArgs} args - Arguments to create many DentistSpecialties.
     * @example
     * // Create many DentistSpecialties
     * const dentistSpecialty = await prisma.dentistSpecialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DentistSpecialtyCreateManyArgs>(args?: SelectSubset<T, DentistSpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DentistSpecialties and returns the data saved in the database.
     * @param {DentistSpecialtyCreateManyAndReturnArgs} args - Arguments to create many DentistSpecialties.
     * @example
     * // Create many DentistSpecialties
     * const dentistSpecialty = await prisma.dentistSpecialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DentistSpecialties and only return the `id`
     * const dentistSpecialtyWithIdOnly = await prisma.dentistSpecialty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DentistSpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, DentistSpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DentistSpecialty.
     * @param {DentistSpecialtyDeleteArgs} args - Arguments to delete one DentistSpecialty.
     * @example
     * // Delete one DentistSpecialty
     * const DentistSpecialty = await prisma.dentistSpecialty.delete({
     *   where: {
     *     // ... filter to delete one DentistSpecialty
     *   }
     * })
     * 
     */
    delete<T extends DentistSpecialtyDeleteArgs>(args: SelectSubset<T, DentistSpecialtyDeleteArgs<ExtArgs>>): Prisma__DentistSpecialtyClient<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DentistSpecialty.
     * @param {DentistSpecialtyUpdateArgs} args - Arguments to update one DentistSpecialty.
     * @example
     * // Update one DentistSpecialty
     * const dentistSpecialty = await prisma.dentistSpecialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DentistSpecialtyUpdateArgs>(args: SelectSubset<T, DentistSpecialtyUpdateArgs<ExtArgs>>): Prisma__DentistSpecialtyClient<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DentistSpecialties.
     * @param {DentistSpecialtyDeleteManyArgs} args - Arguments to filter DentistSpecialties to delete.
     * @example
     * // Delete a few DentistSpecialties
     * const { count } = await prisma.dentistSpecialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DentistSpecialtyDeleteManyArgs>(args?: SelectSubset<T, DentistSpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DentistSpecialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistSpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DentistSpecialties
     * const dentistSpecialty = await prisma.dentistSpecialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DentistSpecialtyUpdateManyArgs>(args: SelectSubset<T, DentistSpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DentistSpecialties and returns the data updated in the database.
     * @param {DentistSpecialtyUpdateManyAndReturnArgs} args - Arguments to update many DentistSpecialties.
     * @example
     * // Update many DentistSpecialties
     * const dentistSpecialty = await prisma.dentistSpecialty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DentistSpecialties and only return the `id`
     * const dentistSpecialtyWithIdOnly = await prisma.dentistSpecialty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DentistSpecialtyUpdateManyAndReturnArgs>(args: SelectSubset<T, DentistSpecialtyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DentistSpecialty.
     * @param {DentistSpecialtyUpsertArgs} args - Arguments to update or create a DentistSpecialty.
     * @example
     * // Update or create a DentistSpecialty
     * const dentistSpecialty = await prisma.dentistSpecialty.upsert({
     *   create: {
     *     // ... data to create a DentistSpecialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DentistSpecialty we want to update
     *   }
     * })
     */
    upsert<T extends DentistSpecialtyUpsertArgs>(args: SelectSubset<T, DentistSpecialtyUpsertArgs<ExtArgs>>): Prisma__DentistSpecialtyClient<$Result.GetResult<Prisma.$DentistSpecialtyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DentistSpecialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistSpecialtyCountArgs} args - Arguments to filter DentistSpecialties to count.
     * @example
     * // Count the number of DentistSpecialties
     * const count = await prisma.dentistSpecialty.count({
     *   where: {
     *     // ... the filter for the DentistSpecialties we want to count
     *   }
     * })
    **/
    count<T extends DentistSpecialtyCountArgs>(
      args?: Subset<T, DentistSpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DentistSpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DentistSpecialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistSpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DentistSpecialtyAggregateArgs>(args: Subset<T, DentistSpecialtyAggregateArgs>): Prisma.PrismaPromise<GetDentistSpecialtyAggregateType<T>>

    /**
     * Group by DentistSpecialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DentistSpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DentistSpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DentistSpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: DentistSpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DentistSpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDentistSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DentistSpecialty model
   */
  readonly fields: DentistSpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DentistSpecialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DentistSpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dentist<T extends DentistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DentistDefaultArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    specialty<T extends SpecialtyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyDefaultArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DentistSpecialty model
   */
  interface DentistSpecialtyFieldRefs {
    readonly id: FieldRef<"DentistSpecialty", 'String'>
    readonly dentistId: FieldRef<"DentistSpecialty", 'String'>
    readonly specialtyId: FieldRef<"DentistSpecialty", 'String'>
    readonly createdAt: FieldRef<"DentistSpecialty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DentistSpecialty findUnique
   */
  export type DentistSpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DentistSpecialty to fetch.
     */
    where: DentistSpecialtyWhereUniqueInput
  }

  /**
   * DentistSpecialty findUniqueOrThrow
   */
  export type DentistSpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DentistSpecialty to fetch.
     */
    where: DentistSpecialtyWhereUniqueInput
  }

  /**
   * DentistSpecialty findFirst
   */
  export type DentistSpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DentistSpecialty to fetch.
     */
    where?: DentistSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DentistSpecialties to fetch.
     */
    orderBy?: DentistSpecialtyOrderByWithRelationInput | DentistSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DentistSpecialties.
     */
    cursor?: DentistSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DentistSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DentistSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DentistSpecialties.
     */
    distinct?: DentistSpecialtyScalarFieldEnum | DentistSpecialtyScalarFieldEnum[]
  }

  /**
   * DentistSpecialty findFirstOrThrow
   */
  export type DentistSpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DentistSpecialty to fetch.
     */
    where?: DentistSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DentistSpecialties to fetch.
     */
    orderBy?: DentistSpecialtyOrderByWithRelationInput | DentistSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DentistSpecialties.
     */
    cursor?: DentistSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DentistSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DentistSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DentistSpecialties.
     */
    distinct?: DentistSpecialtyScalarFieldEnum | DentistSpecialtyScalarFieldEnum[]
  }

  /**
   * DentistSpecialty findMany
   */
  export type DentistSpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DentistSpecialties to fetch.
     */
    where?: DentistSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DentistSpecialties to fetch.
     */
    orderBy?: DentistSpecialtyOrderByWithRelationInput | DentistSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DentistSpecialties.
     */
    cursor?: DentistSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DentistSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DentistSpecialties.
     */
    skip?: number
    distinct?: DentistSpecialtyScalarFieldEnum | DentistSpecialtyScalarFieldEnum[]
  }

  /**
   * DentistSpecialty create
   */
  export type DentistSpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a DentistSpecialty.
     */
    data: XOR<DentistSpecialtyCreateInput, DentistSpecialtyUncheckedCreateInput>
  }

  /**
   * DentistSpecialty createMany
   */
  export type DentistSpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DentistSpecialties.
     */
    data: DentistSpecialtyCreateManyInput | DentistSpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DentistSpecialty createManyAndReturn
   */
  export type DentistSpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * The data used to create many DentistSpecialties.
     */
    data: DentistSpecialtyCreateManyInput | DentistSpecialtyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DentistSpecialty update
   */
  export type DentistSpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a DentistSpecialty.
     */
    data: XOR<DentistSpecialtyUpdateInput, DentistSpecialtyUncheckedUpdateInput>
    /**
     * Choose, which DentistSpecialty to update.
     */
    where: DentistSpecialtyWhereUniqueInput
  }

  /**
   * DentistSpecialty updateMany
   */
  export type DentistSpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DentistSpecialties.
     */
    data: XOR<DentistSpecialtyUpdateManyMutationInput, DentistSpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which DentistSpecialties to update
     */
    where?: DentistSpecialtyWhereInput
    /**
     * Limit how many DentistSpecialties to update.
     */
    limit?: number
  }

  /**
   * DentistSpecialty updateManyAndReturn
   */
  export type DentistSpecialtyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * The data used to update DentistSpecialties.
     */
    data: XOR<DentistSpecialtyUpdateManyMutationInput, DentistSpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which DentistSpecialties to update
     */
    where?: DentistSpecialtyWhereInput
    /**
     * Limit how many DentistSpecialties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DentistSpecialty upsert
   */
  export type DentistSpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the DentistSpecialty to update in case it exists.
     */
    where: DentistSpecialtyWhereUniqueInput
    /**
     * In case the DentistSpecialty found by the `where` argument doesn't exist, create a new DentistSpecialty with this data.
     */
    create: XOR<DentistSpecialtyCreateInput, DentistSpecialtyUncheckedCreateInput>
    /**
     * In case the DentistSpecialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DentistSpecialtyUpdateInput, DentistSpecialtyUncheckedUpdateInput>
  }

  /**
   * DentistSpecialty delete
   */
  export type DentistSpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
    /**
     * Filter which DentistSpecialty to delete.
     */
    where: DentistSpecialtyWhereUniqueInput
  }

  /**
   * DentistSpecialty deleteMany
   */
  export type DentistSpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DentistSpecialties to delete
     */
    where?: DentistSpecialtyWhereInput
    /**
     * Limit how many DentistSpecialties to delete.
     */
    limit?: number
  }

  /**
   * DentistSpecialty without action
   */
  export type DentistSpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DentistSpecialty
     */
    select?: DentistSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DentistSpecialty
     */
    omit?: DentistSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistSpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    appointmentId: string | null
    patientId: string | null
    dentistId: string | null
    status: $Enums.AttendanceStatus | null
    arrivalAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    createdByRole: $Enums.UserRole | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    appointmentId: string | null
    patientId: string | null
    dentistId: string | null
    status: $Enums.AttendanceStatus | null
    arrivalAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    createdByRole: $Enums.UserRole | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    clinicId: number
    appointmentId: number
    patientId: number
    dentistId: number
    status: number
    arrivalAt: number
    startedAt: number
    finishedAt: number
    createdByRole: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    clinicId?: true
    appointmentId?: true
    patientId?: true
    dentistId?: true
    status?: true
    arrivalAt?: true
    startedAt?: true
    finishedAt?: true
    createdByRole?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    clinicId?: true
    appointmentId?: true
    patientId?: true
    dentistId?: true
    status?: true
    arrivalAt?: true
    startedAt?: true
    finishedAt?: true
    createdByRole?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    clinicId?: true
    appointmentId?: true
    patientId?: true
    dentistId?: true
    status?: true
    arrivalAt?: true
    startedAt?: true
    finishedAt?: true
    createdByRole?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    clinicId: string
    appointmentId: string | null
    patientId: string
    dentistId: string | null
    status: $Enums.AttendanceStatus
    arrivalAt: Date
    startedAt: Date | null
    finishedAt: Date | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    appointmentId?: boolean
    patientId?: boolean
    dentistId?: boolean
    status?: boolean
    arrivalAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByRole?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    appointment?: boolean | Attendance$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | Attendance$dentistArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    cids?: boolean | Attendance$cidsArgs<ExtArgs>
    procedures?: boolean | Attendance$proceduresArgs<ExtArgs>
    odontogram?: boolean | Attendance$odontogramArgs<ExtArgs>
    documents?: boolean | Attendance$documentsArgs<ExtArgs>
    record?: boolean | Attendance$recordArgs<ExtArgs>
    _count?: boolean | AttendanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    appointmentId?: boolean
    patientId?: boolean
    dentistId?: boolean
    status?: boolean
    arrivalAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByRole?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    appointment?: boolean | Attendance$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | Attendance$dentistArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    appointmentId?: boolean
    patientId?: boolean
    dentistId?: boolean
    status?: boolean
    arrivalAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByRole?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    appointment?: boolean | Attendance$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | Attendance$dentistArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    clinicId?: boolean
    appointmentId?: boolean
    patientId?: boolean
    dentistId?: boolean
    status?: boolean
    arrivalAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByRole?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clinicId" | "appointmentId" | "patientId" | "dentistId" | "status" | "arrivalAt" | "startedAt" | "finishedAt" | "createdByRole" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    appointment?: boolean | Attendance$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | Attendance$dentistArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    cids?: boolean | Attendance$cidsArgs<ExtArgs>
    procedures?: boolean | Attendance$proceduresArgs<ExtArgs>
    odontogram?: boolean | Attendance$odontogramArgs<ExtArgs>
    documents?: boolean | Attendance$documentsArgs<ExtArgs>
    record?: boolean | Attendance$recordArgs<ExtArgs>
    _count?: boolean | AttendanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    appointment?: boolean | Attendance$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | Attendance$dentistArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    appointment?: boolean | Attendance$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    dentist?: boolean | Attendance$dentistArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs>
      dentist: Prisma.$DentistPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      cids: Prisma.$AttendanceCIDPayload<ExtArgs>[]
      procedures: Prisma.$AttendanceProcedurePayload<ExtArgs>[]
      odontogram: Prisma.$AttendanceOdontogramPayload<ExtArgs> | null
      documents: Prisma.$ClinicalDocumentPayload<ExtArgs>[]
      record: Prisma.$RecordPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      appointmentId: string | null
      patientId: string
      dentistId: string | null
      status: $Enums.AttendanceStatus
      arrivalAt: Date
      startedAt: Date | null
      finishedAt: Date | null
      createdByRole: $Enums.UserRole
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends Attendance$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dentist<T extends Attendance$dentistArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$dentistArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cids<T extends Attendance$cidsArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$cidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    procedures<T extends Attendance$proceduresArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$proceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    odontogram<T extends Attendance$odontogramArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$odontogramArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends Attendance$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    record<T extends Attendance$recordArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$recordArgs<ExtArgs>>): Prisma__RecordClient<$Result.GetResult<Prisma.$RecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly clinicId: FieldRef<"Attendance", 'String'>
    readonly appointmentId: FieldRef<"Attendance", 'String'>
    readonly patientId: FieldRef<"Attendance", 'String'>
    readonly dentistId: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly arrivalAt: FieldRef<"Attendance", 'DateTime'>
    readonly startedAt: FieldRef<"Attendance", 'DateTime'>
    readonly finishedAt: FieldRef<"Attendance", 'DateTime'>
    readonly createdByRole: FieldRef<"Attendance", 'UserRole'>
    readonly createdById: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance.appointment
   */
  export type Attendance$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Attendance.dentist
   */
  export type Attendance$dentistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    where?: DentistWhereInput
  }

  /**
   * Attendance.cids
   */
  export type Attendance$cidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    where?: AttendanceCIDWhereInput
    orderBy?: AttendanceCIDOrderByWithRelationInput | AttendanceCIDOrderByWithRelationInput[]
    cursor?: AttendanceCIDWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceCIDScalarFieldEnum | AttendanceCIDScalarFieldEnum[]
  }

  /**
   * Attendance.procedures
   */
  export type Attendance$proceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    where?: AttendanceProcedureWhereInput
    orderBy?: AttendanceProcedureOrderByWithRelationInput | AttendanceProcedureOrderByWithRelationInput[]
    cursor?: AttendanceProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceProcedureScalarFieldEnum | AttendanceProcedureScalarFieldEnum[]
  }

  /**
   * Attendance.odontogram
   */
  export type Attendance$odontogramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    where?: AttendanceOdontogramWhereInput
  }

  /**
   * Attendance.documents
   */
  export type Attendance$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    where?: ClinicalDocumentWhereInput
    orderBy?: ClinicalDocumentOrderByWithRelationInput | ClinicalDocumentOrderByWithRelationInput[]
    cursor?: ClinicalDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalDocumentScalarFieldEnum | ClinicalDocumentScalarFieldEnum[]
  }

  /**
   * Attendance.record
   */
  export type Attendance$recordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Record
     */
    select?: RecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Record
     */
    omit?: RecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecordInclude<ExtArgs> | null
    where?: RecordWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceCID
   */

  export type AggregateAttendanceCID = {
    _count: AttendanceCIDCountAggregateOutputType | null
    _min: AttendanceCIDMinAggregateOutputType | null
    _max: AttendanceCIDMaxAggregateOutputType | null
  }

  export type AttendanceCIDMinAggregateOutputType = {
    id: string | null
    attendanceId: string | null
    cidCode: string | null
    description: string | null
    observation: string | null
    createdByDentistId: string | null
  }

  export type AttendanceCIDMaxAggregateOutputType = {
    id: string | null
    attendanceId: string | null
    cidCode: string | null
    description: string | null
    observation: string | null
    createdByDentistId: string | null
  }

  export type AttendanceCIDCountAggregateOutputType = {
    id: number
    attendanceId: number
    cidCode: number
    description: number
    observation: number
    createdByDentistId: number
    _all: number
  }


  export type AttendanceCIDMinAggregateInputType = {
    id?: true
    attendanceId?: true
    cidCode?: true
    description?: true
    observation?: true
    createdByDentistId?: true
  }

  export type AttendanceCIDMaxAggregateInputType = {
    id?: true
    attendanceId?: true
    cidCode?: true
    description?: true
    observation?: true
    createdByDentistId?: true
  }

  export type AttendanceCIDCountAggregateInputType = {
    id?: true
    attendanceId?: true
    cidCode?: true
    description?: true
    observation?: true
    createdByDentistId?: true
    _all?: true
  }

  export type AttendanceCIDAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceCID to aggregate.
     */
    where?: AttendanceCIDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceCIDS to fetch.
     */
    orderBy?: AttendanceCIDOrderByWithRelationInput | AttendanceCIDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceCIDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceCIDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceCIDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceCIDS
    **/
    _count?: true | AttendanceCIDCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceCIDMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceCIDMaxAggregateInputType
  }

  export type GetAttendanceCIDAggregateType<T extends AttendanceCIDAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceCID]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceCID[P]>
      : GetScalarType<T[P], AggregateAttendanceCID[P]>
  }




  export type AttendanceCIDGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceCIDWhereInput
    orderBy?: AttendanceCIDOrderByWithAggregationInput | AttendanceCIDOrderByWithAggregationInput[]
    by: AttendanceCIDScalarFieldEnum[] | AttendanceCIDScalarFieldEnum
    having?: AttendanceCIDScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCIDCountAggregateInputType | true
    _min?: AttendanceCIDMinAggregateInputType
    _max?: AttendanceCIDMaxAggregateInputType
  }

  export type AttendanceCIDGroupByOutputType = {
    id: string
    attendanceId: string
    cidCode: string
    description: string
    observation: string | null
    createdByDentistId: string
    _count: AttendanceCIDCountAggregateOutputType | null
    _min: AttendanceCIDMinAggregateOutputType | null
    _max: AttendanceCIDMaxAggregateOutputType | null
  }

  type GetAttendanceCIDGroupByPayload<T extends AttendanceCIDGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceCIDGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceCIDGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceCIDGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceCIDGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceCIDSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    cidCode?: boolean
    description?: boolean
    observation?: boolean
    createdByDentistId?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    createdBy?: boolean | DentistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceCID"]>

  export type AttendanceCIDSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    cidCode?: boolean
    description?: boolean
    observation?: boolean
    createdByDentistId?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    createdBy?: boolean | DentistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceCID"]>

  export type AttendanceCIDSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    cidCode?: boolean
    description?: boolean
    observation?: boolean
    createdByDentistId?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    createdBy?: boolean | DentistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceCID"]>

  export type AttendanceCIDSelectScalar = {
    id?: boolean
    attendanceId?: boolean
    cidCode?: boolean
    description?: boolean
    observation?: boolean
    createdByDentistId?: boolean
  }

  export type AttendanceCIDOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attendanceId" | "cidCode" | "description" | "observation" | "createdByDentistId", ExtArgs["result"]["attendanceCID"]>
  export type AttendanceCIDInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    createdBy?: boolean | DentistDefaultArgs<ExtArgs>
  }
  export type AttendanceCIDIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    createdBy?: boolean | DentistDefaultArgs<ExtArgs>
  }
  export type AttendanceCIDIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    createdBy?: boolean | DentistDefaultArgs<ExtArgs>
  }

  export type $AttendanceCIDPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceCID"
    objects: {
      attendance: Prisma.$AttendancePayload<ExtArgs>
      createdBy: Prisma.$DentistPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attendanceId: string
      cidCode: string
      description: string
      observation: string | null
      createdByDentistId: string
    }, ExtArgs["result"]["attendanceCID"]>
    composites: {}
  }

  type AttendanceCIDGetPayload<S extends boolean | null | undefined | AttendanceCIDDefaultArgs> = $Result.GetResult<Prisma.$AttendanceCIDPayload, S>

  type AttendanceCIDCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceCIDFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCIDCountAggregateInputType | true
    }

  export interface AttendanceCIDDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceCID'], meta: { name: 'AttendanceCID' } }
    /**
     * Find zero or one AttendanceCID that matches the filter.
     * @param {AttendanceCIDFindUniqueArgs} args - Arguments to find a AttendanceCID
     * @example
     * // Get one AttendanceCID
     * const attendanceCID = await prisma.attendanceCID.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceCIDFindUniqueArgs>(args: SelectSubset<T, AttendanceCIDFindUniqueArgs<ExtArgs>>): Prisma__AttendanceCIDClient<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceCID that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceCIDFindUniqueOrThrowArgs} args - Arguments to find a AttendanceCID
     * @example
     * // Get one AttendanceCID
     * const attendanceCID = await prisma.attendanceCID.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceCIDFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceCIDFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceCIDClient<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceCID that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCIDFindFirstArgs} args - Arguments to find a AttendanceCID
     * @example
     * // Get one AttendanceCID
     * const attendanceCID = await prisma.attendanceCID.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceCIDFindFirstArgs>(args?: SelectSubset<T, AttendanceCIDFindFirstArgs<ExtArgs>>): Prisma__AttendanceCIDClient<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceCID that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCIDFindFirstOrThrowArgs} args - Arguments to find a AttendanceCID
     * @example
     * // Get one AttendanceCID
     * const attendanceCID = await prisma.attendanceCID.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceCIDFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceCIDFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceCIDClient<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceCIDS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCIDFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceCIDS
     * const attendanceCIDS = await prisma.attendanceCID.findMany()
     * 
     * // Get first 10 AttendanceCIDS
     * const attendanceCIDS = await prisma.attendanceCID.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceCIDWithIdOnly = await prisma.attendanceCID.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceCIDFindManyArgs>(args?: SelectSubset<T, AttendanceCIDFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceCID.
     * @param {AttendanceCIDCreateArgs} args - Arguments to create a AttendanceCID.
     * @example
     * // Create one AttendanceCID
     * const AttendanceCID = await prisma.attendanceCID.create({
     *   data: {
     *     // ... data to create a AttendanceCID
     *   }
     * })
     * 
     */
    create<T extends AttendanceCIDCreateArgs>(args: SelectSubset<T, AttendanceCIDCreateArgs<ExtArgs>>): Prisma__AttendanceCIDClient<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceCIDS.
     * @param {AttendanceCIDCreateManyArgs} args - Arguments to create many AttendanceCIDS.
     * @example
     * // Create many AttendanceCIDS
     * const attendanceCID = await prisma.attendanceCID.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCIDCreateManyArgs>(args?: SelectSubset<T, AttendanceCIDCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceCIDS and returns the data saved in the database.
     * @param {AttendanceCIDCreateManyAndReturnArgs} args - Arguments to create many AttendanceCIDS.
     * @example
     * // Create many AttendanceCIDS
     * const attendanceCID = await prisma.attendanceCID.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceCIDS and only return the `id`
     * const attendanceCIDWithIdOnly = await prisma.attendanceCID.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCIDCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCIDCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceCID.
     * @param {AttendanceCIDDeleteArgs} args - Arguments to delete one AttendanceCID.
     * @example
     * // Delete one AttendanceCID
     * const AttendanceCID = await prisma.attendanceCID.delete({
     *   where: {
     *     // ... filter to delete one AttendanceCID
     *   }
     * })
     * 
     */
    delete<T extends AttendanceCIDDeleteArgs>(args: SelectSubset<T, AttendanceCIDDeleteArgs<ExtArgs>>): Prisma__AttendanceCIDClient<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceCID.
     * @param {AttendanceCIDUpdateArgs} args - Arguments to update one AttendanceCID.
     * @example
     * // Update one AttendanceCID
     * const attendanceCID = await prisma.attendanceCID.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceCIDUpdateArgs>(args: SelectSubset<T, AttendanceCIDUpdateArgs<ExtArgs>>): Prisma__AttendanceCIDClient<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceCIDS.
     * @param {AttendanceCIDDeleteManyArgs} args - Arguments to filter AttendanceCIDS to delete.
     * @example
     * // Delete a few AttendanceCIDS
     * const { count } = await prisma.attendanceCID.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceCIDDeleteManyArgs>(args?: SelectSubset<T, AttendanceCIDDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceCIDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCIDUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceCIDS
     * const attendanceCID = await prisma.attendanceCID.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceCIDUpdateManyArgs>(args: SelectSubset<T, AttendanceCIDUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceCIDS and returns the data updated in the database.
     * @param {AttendanceCIDUpdateManyAndReturnArgs} args - Arguments to update many AttendanceCIDS.
     * @example
     * // Update many AttendanceCIDS
     * const attendanceCID = await prisma.attendanceCID.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceCIDS and only return the `id`
     * const attendanceCIDWithIdOnly = await prisma.attendanceCID.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceCIDUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceCIDUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceCID.
     * @param {AttendanceCIDUpsertArgs} args - Arguments to update or create a AttendanceCID.
     * @example
     * // Update or create a AttendanceCID
     * const attendanceCID = await prisma.attendanceCID.upsert({
     *   create: {
     *     // ... data to create a AttendanceCID
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceCID we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceCIDUpsertArgs>(args: SelectSubset<T, AttendanceCIDUpsertArgs<ExtArgs>>): Prisma__AttendanceCIDClient<$Result.GetResult<Prisma.$AttendanceCIDPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceCIDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCIDCountArgs} args - Arguments to filter AttendanceCIDS to count.
     * @example
     * // Count the number of AttendanceCIDS
     * const count = await prisma.attendanceCID.count({
     *   where: {
     *     // ... the filter for the AttendanceCIDS we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCIDCountArgs>(
      args?: Subset<T, AttendanceCIDCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCIDCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceCID.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCIDAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceCIDAggregateArgs>(args: Subset<T, AttendanceCIDAggregateArgs>): Prisma.PrismaPromise<GetAttendanceCIDAggregateType<T>>

    /**
     * Group by AttendanceCID.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCIDGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceCIDGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceCIDGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceCIDGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceCIDGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceCIDGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceCID model
   */
  readonly fields: AttendanceCIDFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceCID.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceCIDClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends AttendanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDefaultArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends DentistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DentistDefaultArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceCID model
   */
  interface AttendanceCIDFieldRefs {
    readonly id: FieldRef<"AttendanceCID", 'String'>
    readonly attendanceId: FieldRef<"AttendanceCID", 'String'>
    readonly cidCode: FieldRef<"AttendanceCID", 'String'>
    readonly description: FieldRef<"AttendanceCID", 'String'>
    readonly observation: FieldRef<"AttendanceCID", 'String'>
    readonly createdByDentistId: FieldRef<"AttendanceCID", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceCID findUnique
   */
  export type AttendanceCIDFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCID to fetch.
     */
    where: AttendanceCIDWhereUniqueInput
  }

  /**
   * AttendanceCID findUniqueOrThrow
   */
  export type AttendanceCIDFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCID to fetch.
     */
    where: AttendanceCIDWhereUniqueInput
  }

  /**
   * AttendanceCID findFirst
   */
  export type AttendanceCIDFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCID to fetch.
     */
    where?: AttendanceCIDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceCIDS to fetch.
     */
    orderBy?: AttendanceCIDOrderByWithRelationInput | AttendanceCIDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceCIDS.
     */
    cursor?: AttendanceCIDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceCIDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceCIDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceCIDS.
     */
    distinct?: AttendanceCIDScalarFieldEnum | AttendanceCIDScalarFieldEnum[]
  }

  /**
   * AttendanceCID findFirstOrThrow
   */
  export type AttendanceCIDFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCID to fetch.
     */
    where?: AttendanceCIDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceCIDS to fetch.
     */
    orderBy?: AttendanceCIDOrderByWithRelationInput | AttendanceCIDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceCIDS.
     */
    cursor?: AttendanceCIDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceCIDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceCIDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceCIDS.
     */
    distinct?: AttendanceCIDScalarFieldEnum | AttendanceCIDScalarFieldEnum[]
  }

  /**
   * AttendanceCID findMany
   */
  export type AttendanceCIDFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceCIDS to fetch.
     */
    where?: AttendanceCIDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceCIDS to fetch.
     */
    orderBy?: AttendanceCIDOrderByWithRelationInput | AttendanceCIDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceCIDS.
     */
    cursor?: AttendanceCIDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceCIDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceCIDS.
     */
    skip?: number
    distinct?: AttendanceCIDScalarFieldEnum | AttendanceCIDScalarFieldEnum[]
  }

  /**
   * AttendanceCID create
   */
  export type AttendanceCIDCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceCID.
     */
    data: XOR<AttendanceCIDCreateInput, AttendanceCIDUncheckedCreateInput>
  }

  /**
   * AttendanceCID createMany
   */
  export type AttendanceCIDCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceCIDS.
     */
    data: AttendanceCIDCreateManyInput | AttendanceCIDCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceCID createManyAndReturn
   */
  export type AttendanceCIDCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceCIDS.
     */
    data: AttendanceCIDCreateManyInput | AttendanceCIDCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceCID update
   */
  export type AttendanceCIDUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceCID.
     */
    data: XOR<AttendanceCIDUpdateInput, AttendanceCIDUncheckedUpdateInput>
    /**
     * Choose, which AttendanceCID to update.
     */
    where: AttendanceCIDWhereUniqueInput
  }

  /**
   * AttendanceCID updateMany
   */
  export type AttendanceCIDUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceCIDS.
     */
    data: XOR<AttendanceCIDUpdateManyMutationInput, AttendanceCIDUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceCIDS to update
     */
    where?: AttendanceCIDWhereInput
    /**
     * Limit how many AttendanceCIDS to update.
     */
    limit?: number
  }

  /**
   * AttendanceCID updateManyAndReturn
   */
  export type AttendanceCIDUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceCIDS.
     */
    data: XOR<AttendanceCIDUpdateManyMutationInput, AttendanceCIDUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceCIDS to update
     */
    where?: AttendanceCIDWhereInput
    /**
     * Limit how many AttendanceCIDS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceCID upsert
   */
  export type AttendanceCIDUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceCID to update in case it exists.
     */
    where: AttendanceCIDWhereUniqueInput
    /**
     * In case the AttendanceCID found by the `where` argument doesn't exist, create a new AttendanceCID with this data.
     */
    create: XOR<AttendanceCIDCreateInput, AttendanceCIDUncheckedCreateInput>
    /**
     * In case the AttendanceCID was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceCIDUpdateInput, AttendanceCIDUncheckedUpdateInput>
  }

  /**
   * AttendanceCID delete
   */
  export type AttendanceCIDDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
    /**
     * Filter which AttendanceCID to delete.
     */
    where: AttendanceCIDWhereUniqueInput
  }

  /**
   * AttendanceCID deleteMany
   */
  export type AttendanceCIDDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceCIDS to delete
     */
    where?: AttendanceCIDWhereInput
    /**
     * Limit how many AttendanceCIDS to delete.
     */
    limit?: number
  }

  /**
   * AttendanceCID without action
   */
  export type AttendanceCIDDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCID
     */
    select?: AttendanceCIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceCID
     */
    omit?: AttendanceCIDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceCIDInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceProcedure
   */

  export type AggregateAttendanceProcedure = {
    _count: AttendanceProcedureCountAggregateOutputType | null
    _avg: AttendanceProcedureAvgAggregateOutputType | null
    _sum: AttendanceProcedureSumAggregateOutputType | null
    _min: AttendanceProcedureMinAggregateOutputType | null
    _max: AttendanceProcedureMaxAggregateOutputType | null
  }

  export type AttendanceProcedureAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type AttendanceProcedureSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type AttendanceProcedureMinAggregateOutputType = {
    id: string | null
    attendanceId: string | null
    procedureId: string | null
    procedureCode: string | null
    description: string | null
    tooth: string | null
    surface: string | null
    quantity: number | null
    clinicalStatus: string | null
    price: Decimal | null
    dentistId: string | null
    observations: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceProcedureMaxAggregateOutputType = {
    id: string | null
    attendanceId: string | null
    procedureId: string | null
    procedureCode: string | null
    description: string | null
    tooth: string | null
    surface: string | null
    quantity: number | null
    clinicalStatus: string | null
    price: Decimal | null
    dentistId: string | null
    observations: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceProcedureCountAggregateOutputType = {
    id: number
    attendanceId: number
    procedureId: number
    procedureCode: number
    description: number
    tooth: number
    surface: number
    faces: number
    quantity: number
    clinicalStatus: number
    price: number
    dentistId: number
    observations: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceProcedureAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type AttendanceProcedureSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type AttendanceProcedureMinAggregateInputType = {
    id?: true
    attendanceId?: true
    procedureId?: true
    procedureCode?: true
    description?: true
    tooth?: true
    surface?: true
    quantity?: true
    clinicalStatus?: true
    price?: true
    dentistId?: true
    observations?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceProcedureMaxAggregateInputType = {
    id?: true
    attendanceId?: true
    procedureId?: true
    procedureCode?: true
    description?: true
    tooth?: true
    surface?: true
    quantity?: true
    clinicalStatus?: true
    price?: true
    dentistId?: true
    observations?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceProcedureCountAggregateInputType = {
    id?: true
    attendanceId?: true
    procedureId?: true
    procedureCode?: true
    description?: true
    tooth?: true
    surface?: true
    faces?: true
    quantity?: true
    clinicalStatus?: true
    price?: true
    dentistId?: true
    observations?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceProcedureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceProcedure to aggregate.
     */
    where?: AttendanceProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceProcedures to fetch.
     */
    orderBy?: AttendanceProcedureOrderByWithRelationInput | AttendanceProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceProcedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceProcedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceProcedures
    **/
    _count?: true | AttendanceProcedureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceProcedureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceProcedureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceProcedureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceProcedureMaxAggregateInputType
  }

  export type GetAttendanceProcedureAggregateType<T extends AttendanceProcedureAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceProcedure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceProcedure[P]>
      : GetScalarType<T[P], AggregateAttendanceProcedure[P]>
  }




  export type AttendanceProcedureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceProcedureWhereInput
    orderBy?: AttendanceProcedureOrderByWithAggregationInput | AttendanceProcedureOrderByWithAggregationInput[]
    by: AttendanceProcedureScalarFieldEnum[] | AttendanceProcedureScalarFieldEnum
    having?: AttendanceProcedureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceProcedureCountAggregateInputType | true
    _avg?: AttendanceProcedureAvgAggregateInputType
    _sum?: AttendanceProcedureSumAggregateInputType
    _min?: AttendanceProcedureMinAggregateInputType
    _max?: AttendanceProcedureMaxAggregateInputType
  }

  export type AttendanceProcedureGroupByOutputType = {
    id: string
    attendanceId: string
    procedureId: string | null
    procedureCode: string | null
    description: string
    tooth: string | null
    surface: string | null
    faces: string[]
    quantity: number
    clinicalStatus: string | null
    price: Decimal | null
    dentistId: string | null
    observations: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceProcedureCountAggregateOutputType | null
    _avg: AttendanceProcedureAvgAggregateOutputType | null
    _sum: AttendanceProcedureSumAggregateOutputType | null
    _min: AttendanceProcedureMinAggregateOutputType | null
    _max: AttendanceProcedureMaxAggregateOutputType | null
  }

  type GetAttendanceProcedureGroupByPayload<T extends AttendanceProcedureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceProcedureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceProcedureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceProcedureGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceProcedureGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceProcedureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    procedureId?: boolean
    procedureCode?: boolean
    description?: boolean
    tooth?: boolean
    surface?: boolean
    faces?: boolean
    quantity?: boolean
    clinicalStatus?: boolean
    price?: boolean
    dentistId?: boolean
    observations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    procedure?: boolean | AttendanceProcedure$procedureArgs<ExtArgs>
    dentist?: boolean | AttendanceProcedure$dentistArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceProcedure"]>

  export type AttendanceProcedureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    procedureId?: boolean
    procedureCode?: boolean
    description?: boolean
    tooth?: boolean
    surface?: boolean
    faces?: boolean
    quantity?: boolean
    clinicalStatus?: boolean
    price?: boolean
    dentistId?: boolean
    observations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    procedure?: boolean | AttendanceProcedure$procedureArgs<ExtArgs>
    dentist?: boolean | AttendanceProcedure$dentistArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceProcedure"]>

  export type AttendanceProcedureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    procedureId?: boolean
    procedureCode?: boolean
    description?: boolean
    tooth?: boolean
    surface?: boolean
    faces?: boolean
    quantity?: boolean
    clinicalStatus?: boolean
    price?: boolean
    dentistId?: boolean
    observations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    procedure?: boolean | AttendanceProcedure$procedureArgs<ExtArgs>
    dentist?: boolean | AttendanceProcedure$dentistArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceProcedure"]>

  export type AttendanceProcedureSelectScalar = {
    id?: boolean
    attendanceId?: boolean
    procedureId?: boolean
    procedureCode?: boolean
    description?: boolean
    tooth?: boolean
    surface?: boolean
    faces?: boolean
    quantity?: boolean
    clinicalStatus?: boolean
    price?: boolean
    dentistId?: boolean
    observations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceProcedureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attendanceId" | "procedureId" | "procedureCode" | "description" | "tooth" | "surface" | "faces" | "quantity" | "clinicalStatus" | "price" | "dentistId" | "observations" | "createdAt" | "updatedAt", ExtArgs["result"]["attendanceProcedure"]>
  export type AttendanceProcedureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    procedure?: boolean | AttendanceProcedure$procedureArgs<ExtArgs>
    dentist?: boolean | AttendanceProcedure$dentistArgs<ExtArgs>
  }
  export type AttendanceProcedureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    procedure?: boolean | AttendanceProcedure$procedureArgs<ExtArgs>
    dentist?: boolean | AttendanceProcedure$dentistArgs<ExtArgs>
  }
  export type AttendanceProcedureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
    procedure?: boolean | AttendanceProcedure$procedureArgs<ExtArgs>
    dentist?: boolean | AttendanceProcedure$dentistArgs<ExtArgs>
  }

  export type $AttendanceProcedurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceProcedure"
    objects: {
      attendance: Prisma.$AttendancePayload<ExtArgs>
      procedure: Prisma.$ProcedurePayload<ExtArgs> | null
      dentist: Prisma.$DentistPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attendanceId: string
      procedureId: string | null
      procedureCode: string | null
      description: string
      tooth: string | null
      surface: string | null
      faces: string[]
      quantity: number
      clinicalStatus: string | null
      price: Prisma.Decimal | null
      dentistId: string | null
      observations: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceProcedure"]>
    composites: {}
  }

  type AttendanceProcedureGetPayload<S extends boolean | null | undefined | AttendanceProcedureDefaultArgs> = $Result.GetResult<Prisma.$AttendanceProcedurePayload, S>

  type AttendanceProcedureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceProcedureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceProcedureCountAggregateInputType | true
    }

  export interface AttendanceProcedureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceProcedure'], meta: { name: 'AttendanceProcedure' } }
    /**
     * Find zero or one AttendanceProcedure that matches the filter.
     * @param {AttendanceProcedureFindUniqueArgs} args - Arguments to find a AttendanceProcedure
     * @example
     * // Get one AttendanceProcedure
     * const attendanceProcedure = await prisma.attendanceProcedure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceProcedureFindUniqueArgs>(args: SelectSubset<T, AttendanceProcedureFindUniqueArgs<ExtArgs>>): Prisma__AttendanceProcedureClient<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceProcedure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceProcedureFindUniqueOrThrowArgs} args - Arguments to find a AttendanceProcedure
     * @example
     * // Get one AttendanceProcedure
     * const attendanceProcedure = await prisma.attendanceProcedure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceProcedureFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceProcedureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceProcedureClient<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceProcedure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceProcedureFindFirstArgs} args - Arguments to find a AttendanceProcedure
     * @example
     * // Get one AttendanceProcedure
     * const attendanceProcedure = await prisma.attendanceProcedure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceProcedureFindFirstArgs>(args?: SelectSubset<T, AttendanceProcedureFindFirstArgs<ExtArgs>>): Prisma__AttendanceProcedureClient<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceProcedure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceProcedureFindFirstOrThrowArgs} args - Arguments to find a AttendanceProcedure
     * @example
     * // Get one AttendanceProcedure
     * const attendanceProcedure = await prisma.attendanceProcedure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceProcedureFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceProcedureFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceProcedureClient<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceProcedures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceProcedureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceProcedures
     * const attendanceProcedures = await prisma.attendanceProcedure.findMany()
     * 
     * // Get first 10 AttendanceProcedures
     * const attendanceProcedures = await prisma.attendanceProcedure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceProcedureWithIdOnly = await prisma.attendanceProcedure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceProcedureFindManyArgs>(args?: SelectSubset<T, AttendanceProcedureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceProcedure.
     * @param {AttendanceProcedureCreateArgs} args - Arguments to create a AttendanceProcedure.
     * @example
     * // Create one AttendanceProcedure
     * const AttendanceProcedure = await prisma.attendanceProcedure.create({
     *   data: {
     *     // ... data to create a AttendanceProcedure
     *   }
     * })
     * 
     */
    create<T extends AttendanceProcedureCreateArgs>(args: SelectSubset<T, AttendanceProcedureCreateArgs<ExtArgs>>): Prisma__AttendanceProcedureClient<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceProcedures.
     * @param {AttendanceProcedureCreateManyArgs} args - Arguments to create many AttendanceProcedures.
     * @example
     * // Create many AttendanceProcedures
     * const attendanceProcedure = await prisma.attendanceProcedure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceProcedureCreateManyArgs>(args?: SelectSubset<T, AttendanceProcedureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceProcedures and returns the data saved in the database.
     * @param {AttendanceProcedureCreateManyAndReturnArgs} args - Arguments to create many AttendanceProcedures.
     * @example
     * // Create many AttendanceProcedures
     * const attendanceProcedure = await prisma.attendanceProcedure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceProcedures and only return the `id`
     * const attendanceProcedureWithIdOnly = await prisma.attendanceProcedure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceProcedureCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceProcedureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceProcedure.
     * @param {AttendanceProcedureDeleteArgs} args - Arguments to delete one AttendanceProcedure.
     * @example
     * // Delete one AttendanceProcedure
     * const AttendanceProcedure = await prisma.attendanceProcedure.delete({
     *   where: {
     *     // ... filter to delete one AttendanceProcedure
     *   }
     * })
     * 
     */
    delete<T extends AttendanceProcedureDeleteArgs>(args: SelectSubset<T, AttendanceProcedureDeleteArgs<ExtArgs>>): Prisma__AttendanceProcedureClient<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceProcedure.
     * @param {AttendanceProcedureUpdateArgs} args - Arguments to update one AttendanceProcedure.
     * @example
     * // Update one AttendanceProcedure
     * const attendanceProcedure = await prisma.attendanceProcedure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceProcedureUpdateArgs>(args: SelectSubset<T, AttendanceProcedureUpdateArgs<ExtArgs>>): Prisma__AttendanceProcedureClient<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceProcedures.
     * @param {AttendanceProcedureDeleteManyArgs} args - Arguments to filter AttendanceProcedures to delete.
     * @example
     * // Delete a few AttendanceProcedures
     * const { count } = await prisma.attendanceProcedure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceProcedureDeleteManyArgs>(args?: SelectSubset<T, AttendanceProcedureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceProcedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceProcedureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceProcedures
     * const attendanceProcedure = await prisma.attendanceProcedure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceProcedureUpdateManyArgs>(args: SelectSubset<T, AttendanceProcedureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceProcedures and returns the data updated in the database.
     * @param {AttendanceProcedureUpdateManyAndReturnArgs} args - Arguments to update many AttendanceProcedures.
     * @example
     * // Update many AttendanceProcedures
     * const attendanceProcedure = await prisma.attendanceProcedure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceProcedures and only return the `id`
     * const attendanceProcedureWithIdOnly = await prisma.attendanceProcedure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceProcedureUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceProcedureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceProcedure.
     * @param {AttendanceProcedureUpsertArgs} args - Arguments to update or create a AttendanceProcedure.
     * @example
     * // Update or create a AttendanceProcedure
     * const attendanceProcedure = await prisma.attendanceProcedure.upsert({
     *   create: {
     *     // ... data to create a AttendanceProcedure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceProcedure we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceProcedureUpsertArgs>(args: SelectSubset<T, AttendanceProcedureUpsertArgs<ExtArgs>>): Prisma__AttendanceProcedureClient<$Result.GetResult<Prisma.$AttendanceProcedurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceProcedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceProcedureCountArgs} args - Arguments to filter AttendanceProcedures to count.
     * @example
     * // Count the number of AttendanceProcedures
     * const count = await prisma.attendanceProcedure.count({
     *   where: {
     *     // ... the filter for the AttendanceProcedures we want to count
     *   }
     * })
    **/
    count<T extends AttendanceProcedureCountArgs>(
      args?: Subset<T, AttendanceProcedureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceProcedureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceProcedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceProcedureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceProcedureAggregateArgs>(args: Subset<T, AttendanceProcedureAggregateArgs>): Prisma.PrismaPromise<GetAttendanceProcedureAggregateType<T>>

    /**
     * Group by AttendanceProcedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceProcedureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceProcedureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceProcedureGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceProcedureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceProcedureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceProcedureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceProcedure model
   */
  readonly fields: AttendanceProcedureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceProcedure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceProcedureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends AttendanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDefaultArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    procedure<T extends AttendanceProcedure$procedureArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceProcedure$procedureArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dentist<T extends AttendanceProcedure$dentistArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceProcedure$dentistArgs<ExtArgs>>): Prisma__DentistClient<$Result.GetResult<Prisma.$DentistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceProcedure model
   */
  interface AttendanceProcedureFieldRefs {
    readonly id: FieldRef<"AttendanceProcedure", 'String'>
    readonly attendanceId: FieldRef<"AttendanceProcedure", 'String'>
    readonly procedureId: FieldRef<"AttendanceProcedure", 'String'>
    readonly procedureCode: FieldRef<"AttendanceProcedure", 'String'>
    readonly description: FieldRef<"AttendanceProcedure", 'String'>
    readonly tooth: FieldRef<"AttendanceProcedure", 'String'>
    readonly surface: FieldRef<"AttendanceProcedure", 'String'>
    readonly faces: FieldRef<"AttendanceProcedure", 'String[]'>
    readonly quantity: FieldRef<"AttendanceProcedure", 'Int'>
    readonly clinicalStatus: FieldRef<"AttendanceProcedure", 'String'>
    readonly price: FieldRef<"AttendanceProcedure", 'Decimal'>
    readonly dentistId: FieldRef<"AttendanceProcedure", 'String'>
    readonly observations: FieldRef<"AttendanceProcedure", 'String'>
    readonly createdAt: FieldRef<"AttendanceProcedure", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceProcedure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceProcedure findUnique
   */
  export type AttendanceProcedureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceProcedure to fetch.
     */
    where: AttendanceProcedureWhereUniqueInput
  }

  /**
   * AttendanceProcedure findUniqueOrThrow
   */
  export type AttendanceProcedureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceProcedure to fetch.
     */
    where: AttendanceProcedureWhereUniqueInput
  }

  /**
   * AttendanceProcedure findFirst
   */
  export type AttendanceProcedureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceProcedure to fetch.
     */
    where?: AttendanceProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceProcedures to fetch.
     */
    orderBy?: AttendanceProcedureOrderByWithRelationInput | AttendanceProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceProcedures.
     */
    cursor?: AttendanceProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceProcedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceProcedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceProcedures.
     */
    distinct?: AttendanceProcedureScalarFieldEnum | AttendanceProcedureScalarFieldEnum[]
  }

  /**
   * AttendanceProcedure findFirstOrThrow
   */
  export type AttendanceProcedureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceProcedure to fetch.
     */
    where?: AttendanceProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceProcedures to fetch.
     */
    orderBy?: AttendanceProcedureOrderByWithRelationInput | AttendanceProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceProcedures.
     */
    cursor?: AttendanceProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceProcedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceProcedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceProcedures.
     */
    distinct?: AttendanceProcedureScalarFieldEnum | AttendanceProcedureScalarFieldEnum[]
  }

  /**
   * AttendanceProcedure findMany
   */
  export type AttendanceProcedureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceProcedures to fetch.
     */
    where?: AttendanceProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceProcedures to fetch.
     */
    orderBy?: AttendanceProcedureOrderByWithRelationInput | AttendanceProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceProcedures.
     */
    cursor?: AttendanceProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceProcedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceProcedures.
     */
    skip?: number
    distinct?: AttendanceProcedureScalarFieldEnum | AttendanceProcedureScalarFieldEnum[]
  }

  /**
   * AttendanceProcedure create
   */
  export type AttendanceProcedureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceProcedure.
     */
    data: XOR<AttendanceProcedureCreateInput, AttendanceProcedureUncheckedCreateInput>
  }

  /**
   * AttendanceProcedure createMany
   */
  export type AttendanceProcedureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceProcedures.
     */
    data: AttendanceProcedureCreateManyInput | AttendanceProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceProcedure createManyAndReturn
   */
  export type AttendanceProcedureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceProcedures.
     */
    data: AttendanceProcedureCreateManyInput | AttendanceProcedureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceProcedure update
   */
  export type AttendanceProcedureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceProcedure.
     */
    data: XOR<AttendanceProcedureUpdateInput, AttendanceProcedureUncheckedUpdateInput>
    /**
     * Choose, which AttendanceProcedure to update.
     */
    where: AttendanceProcedureWhereUniqueInput
  }

  /**
   * AttendanceProcedure updateMany
   */
  export type AttendanceProcedureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceProcedures.
     */
    data: XOR<AttendanceProcedureUpdateManyMutationInput, AttendanceProcedureUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceProcedures to update
     */
    where?: AttendanceProcedureWhereInput
    /**
     * Limit how many AttendanceProcedures to update.
     */
    limit?: number
  }

  /**
   * AttendanceProcedure updateManyAndReturn
   */
  export type AttendanceProcedureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceProcedures.
     */
    data: XOR<AttendanceProcedureUpdateManyMutationInput, AttendanceProcedureUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceProcedures to update
     */
    where?: AttendanceProcedureWhereInput
    /**
     * Limit how many AttendanceProcedures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceProcedure upsert
   */
  export type AttendanceProcedureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceProcedure to update in case it exists.
     */
    where: AttendanceProcedureWhereUniqueInput
    /**
     * In case the AttendanceProcedure found by the `where` argument doesn't exist, create a new AttendanceProcedure with this data.
     */
    create: XOR<AttendanceProcedureCreateInput, AttendanceProcedureUncheckedCreateInput>
    /**
     * In case the AttendanceProcedure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceProcedureUpdateInput, AttendanceProcedureUncheckedUpdateInput>
  }

  /**
   * AttendanceProcedure delete
   */
  export type AttendanceProcedureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
    /**
     * Filter which AttendanceProcedure to delete.
     */
    where: AttendanceProcedureWhereUniqueInput
  }

  /**
   * AttendanceProcedure deleteMany
   */
  export type AttendanceProcedureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceProcedures to delete
     */
    where?: AttendanceProcedureWhereInput
    /**
     * Limit how many AttendanceProcedures to delete.
     */
    limit?: number
  }

  /**
   * AttendanceProcedure.procedure
   */
  export type AttendanceProcedure$procedureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
  }

  /**
   * AttendanceProcedure.dentist
   */
  export type AttendanceProcedure$dentistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dentist
     */
    select?: DentistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dentist
     */
    omit?: DentistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DentistInclude<ExtArgs> | null
    where?: DentistWhereInput
  }

  /**
   * AttendanceProcedure without action
   */
  export type AttendanceProcedureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceProcedure
     */
    select?: AttendanceProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceProcedure
     */
    omit?: AttendanceProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceProcedureInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceOdontogram
   */

  export type AggregateAttendanceOdontogram = {
    _count: AttendanceOdontogramCountAggregateOutputType | null
    _min: AttendanceOdontogramMinAggregateOutputType | null
    _max: AttendanceOdontogramMaxAggregateOutputType | null
  }

  export type AttendanceOdontogramMinAggregateOutputType = {
    attendanceId: string | null
  }

  export type AttendanceOdontogramMaxAggregateOutputType = {
    attendanceId: string | null
  }

  export type AttendanceOdontogramCountAggregateOutputType = {
    attendanceId: number
    data: number
    _all: number
  }


  export type AttendanceOdontogramMinAggregateInputType = {
    attendanceId?: true
  }

  export type AttendanceOdontogramMaxAggregateInputType = {
    attendanceId?: true
  }

  export type AttendanceOdontogramCountAggregateInputType = {
    attendanceId?: true
    data?: true
    _all?: true
  }

  export type AttendanceOdontogramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceOdontogram to aggregate.
     */
    where?: AttendanceOdontogramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceOdontograms to fetch.
     */
    orderBy?: AttendanceOdontogramOrderByWithRelationInput | AttendanceOdontogramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceOdontogramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceOdontograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceOdontograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceOdontograms
    **/
    _count?: true | AttendanceOdontogramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceOdontogramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceOdontogramMaxAggregateInputType
  }

  export type GetAttendanceOdontogramAggregateType<T extends AttendanceOdontogramAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceOdontogram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceOdontogram[P]>
      : GetScalarType<T[P], AggregateAttendanceOdontogram[P]>
  }




  export type AttendanceOdontogramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceOdontogramWhereInput
    orderBy?: AttendanceOdontogramOrderByWithAggregationInput | AttendanceOdontogramOrderByWithAggregationInput[]
    by: AttendanceOdontogramScalarFieldEnum[] | AttendanceOdontogramScalarFieldEnum
    having?: AttendanceOdontogramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceOdontogramCountAggregateInputType | true
    _min?: AttendanceOdontogramMinAggregateInputType
    _max?: AttendanceOdontogramMaxAggregateInputType
  }

  export type AttendanceOdontogramGroupByOutputType = {
    attendanceId: string
    data: JsonValue
    _count: AttendanceOdontogramCountAggregateOutputType | null
    _min: AttendanceOdontogramMinAggregateOutputType | null
    _max: AttendanceOdontogramMaxAggregateOutputType | null
  }

  type GetAttendanceOdontogramGroupByPayload<T extends AttendanceOdontogramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceOdontogramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceOdontogramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceOdontogramGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceOdontogramGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceOdontogramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attendanceId?: boolean
    data?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceOdontogram"]>

  export type AttendanceOdontogramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attendanceId?: boolean
    data?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceOdontogram"]>

  export type AttendanceOdontogramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attendanceId?: boolean
    data?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceOdontogram"]>

  export type AttendanceOdontogramSelectScalar = {
    attendanceId?: boolean
    data?: boolean
  }

  export type AttendanceOdontogramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"attendanceId" | "data", ExtArgs["result"]["attendanceOdontogram"]>
  export type AttendanceOdontogramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }
  export type AttendanceOdontogramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }
  export type AttendanceOdontogramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }

  export type $AttendanceOdontogramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceOdontogram"
    objects: {
      attendance: Prisma.$AttendancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      attendanceId: string
      data: Prisma.JsonValue
    }, ExtArgs["result"]["attendanceOdontogram"]>
    composites: {}
  }

  type AttendanceOdontogramGetPayload<S extends boolean | null | undefined | AttendanceOdontogramDefaultArgs> = $Result.GetResult<Prisma.$AttendanceOdontogramPayload, S>

  type AttendanceOdontogramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceOdontogramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceOdontogramCountAggregateInputType | true
    }

  export interface AttendanceOdontogramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceOdontogram'], meta: { name: 'AttendanceOdontogram' } }
    /**
     * Find zero or one AttendanceOdontogram that matches the filter.
     * @param {AttendanceOdontogramFindUniqueArgs} args - Arguments to find a AttendanceOdontogram
     * @example
     * // Get one AttendanceOdontogram
     * const attendanceOdontogram = await prisma.attendanceOdontogram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceOdontogramFindUniqueArgs>(args: SelectSubset<T, AttendanceOdontogramFindUniqueArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceOdontogram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceOdontogramFindUniqueOrThrowArgs} args - Arguments to find a AttendanceOdontogram
     * @example
     * // Get one AttendanceOdontogram
     * const attendanceOdontogram = await prisma.attendanceOdontogram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceOdontogramFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceOdontogramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceOdontogram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceOdontogramFindFirstArgs} args - Arguments to find a AttendanceOdontogram
     * @example
     * // Get one AttendanceOdontogram
     * const attendanceOdontogram = await prisma.attendanceOdontogram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceOdontogramFindFirstArgs>(args?: SelectSubset<T, AttendanceOdontogramFindFirstArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceOdontogram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceOdontogramFindFirstOrThrowArgs} args - Arguments to find a AttendanceOdontogram
     * @example
     * // Get one AttendanceOdontogram
     * const attendanceOdontogram = await prisma.attendanceOdontogram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceOdontogramFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceOdontogramFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceOdontograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceOdontogramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceOdontograms
     * const attendanceOdontograms = await prisma.attendanceOdontogram.findMany()
     * 
     * // Get first 10 AttendanceOdontograms
     * const attendanceOdontograms = await prisma.attendanceOdontogram.findMany({ take: 10 })
     * 
     * // Only select the `attendanceId`
     * const attendanceOdontogramWithAttendanceIdOnly = await prisma.attendanceOdontogram.findMany({ select: { attendanceId: true } })
     * 
     */
    findMany<T extends AttendanceOdontogramFindManyArgs>(args?: SelectSubset<T, AttendanceOdontogramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceOdontogram.
     * @param {AttendanceOdontogramCreateArgs} args - Arguments to create a AttendanceOdontogram.
     * @example
     * // Create one AttendanceOdontogram
     * const AttendanceOdontogram = await prisma.attendanceOdontogram.create({
     *   data: {
     *     // ... data to create a AttendanceOdontogram
     *   }
     * })
     * 
     */
    create<T extends AttendanceOdontogramCreateArgs>(args: SelectSubset<T, AttendanceOdontogramCreateArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceOdontograms.
     * @param {AttendanceOdontogramCreateManyArgs} args - Arguments to create many AttendanceOdontograms.
     * @example
     * // Create many AttendanceOdontograms
     * const attendanceOdontogram = await prisma.attendanceOdontogram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceOdontogramCreateManyArgs>(args?: SelectSubset<T, AttendanceOdontogramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceOdontograms and returns the data saved in the database.
     * @param {AttendanceOdontogramCreateManyAndReturnArgs} args - Arguments to create many AttendanceOdontograms.
     * @example
     * // Create many AttendanceOdontograms
     * const attendanceOdontogram = await prisma.attendanceOdontogram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceOdontograms and only return the `attendanceId`
     * const attendanceOdontogramWithAttendanceIdOnly = await prisma.attendanceOdontogram.createManyAndReturn({
     *   select: { attendanceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceOdontogramCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceOdontogramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceOdontogram.
     * @param {AttendanceOdontogramDeleteArgs} args - Arguments to delete one AttendanceOdontogram.
     * @example
     * // Delete one AttendanceOdontogram
     * const AttendanceOdontogram = await prisma.attendanceOdontogram.delete({
     *   where: {
     *     // ... filter to delete one AttendanceOdontogram
     *   }
     * })
     * 
     */
    delete<T extends AttendanceOdontogramDeleteArgs>(args: SelectSubset<T, AttendanceOdontogramDeleteArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceOdontogram.
     * @param {AttendanceOdontogramUpdateArgs} args - Arguments to update one AttendanceOdontogram.
     * @example
     * // Update one AttendanceOdontogram
     * const attendanceOdontogram = await prisma.attendanceOdontogram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceOdontogramUpdateArgs>(args: SelectSubset<T, AttendanceOdontogramUpdateArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceOdontograms.
     * @param {AttendanceOdontogramDeleteManyArgs} args - Arguments to filter AttendanceOdontograms to delete.
     * @example
     * // Delete a few AttendanceOdontograms
     * const { count } = await prisma.attendanceOdontogram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceOdontogramDeleteManyArgs>(args?: SelectSubset<T, AttendanceOdontogramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceOdontograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceOdontogramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceOdontograms
     * const attendanceOdontogram = await prisma.attendanceOdontogram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceOdontogramUpdateManyArgs>(args: SelectSubset<T, AttendanceOdontogramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceOdontograms and returns the data updated in the database.
     * @param {AttendanceOdontogramUpdateManyAndReturnArgs} args - Arguments to update many AttendanceOdontograms.
     * @example
     * // Update many AttendanceOdontograms
     * const attendanceOdontogram = await prisma.attendanceOdontogram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceOdontograms and only return the `attendanceId`
     * const attendanceOdontogramWithAttendanceIdOnly = await prisma.attendanceOdontogram.updateManyAndReturn({
     *   select: { attendanceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceOdontogramUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceOdontogramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceOdontogram.
     * @param {AttendanceOdontogramUpsertArgs} args - Arguments to update or create a AttendanceOdontogram.
     * @example
     * // Update or create a AttendanceOdontogram
     * const attendanceOdontogram = await prisma.attendanceOdontogram.upsert({
     *   create: {
     *     // ... data to create a AttendanceOdontogram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceOdontogram we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceOdontogramUpsertArgs>(args: SelectSubset<T, AttendanceOdontogramUpsertArgs<ExtArgs>>): Prisma__AttendanceOdontogramClient<$Result.GetResult<Prisma.$AttendanceOdontogramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceOdontograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceOdontogramCountArgs} args - Arguments to filter AttendanceOdontograms to count.
     * @example
     * // Count the number of AttendanceOdontograms
     * const count = await prisma.attendanceOdontogram.count({
     *   where: {
     *     // ... the filter for the AttendanceOdontograms we want to count
     *   }
     * })
    **/
    count<T extends AttendanceOdontogramCountArgs>(
      args?: Subset<T, AttendanceOdontogramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceOdontogramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceOdontogram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceOdontogramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceOdontogramAggregateArgs>(args: Subset<T, AttendanceOdontogramAggregateArgs>): Prisma.PrismaPromise<GetAttendanceOdontogramAggregateType<T>>

    /**
     * Group by AttendanceOdontogram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceOdontogramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceOdontogramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceOdontogramGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceOdontogramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceOdontogramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceOdontogramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceOdontogram model
   */
  readonly fields: AttendanceOdontogramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceOdontogram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceOdontogramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends AttendanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDefaultArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceOdontogram model
   */
  interface AttendanceOdontogramFieldRefs {
    readonly attendanceId: FieldRef<"AttendanceOdontogram", 'String'>
    readonly data: FieldRef<"AttendanceOdontogram", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceOdontogram findUnique
   */
  export type AttendanceOdontogramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceOdontogram to fetch.
     */
    where: AttendanceOdontogramWhereUniqueInput
  }

  /**
   * AttendanceOdontogram findUniqueOrThrow
   */
  export type AttendanceOdontogramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceOdontogram to fetch.
     */
    where: AttendanceOdontogramWhereUniqueInput
  }

  /**
   * AttendanceOdontogram findFirst
   */
  export type AttendanceOdontogramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceOdontogram to fetch.
     */
    where?: AttendanceOdontogramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceOdontograms to fetch.
     */
    orderBy?: AttendanceOdontogramOrderByWithRelationInput | AttendanceOdontogramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceOdontograms.
     */
    cursor?: AttendanceOdontogramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceOdontograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceOdontograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceOdontograms.
     */
    distinct?: AttendanceOdontogramScalarFieldEnum | AttendanceOdontogramScalarFieldEnum[]
  }

  /**
   * AttendanceOdontogram findFirstOrThrow
   */
  export type AttendanceOdontogramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceOdontogram to fetch.
     */
    where?: AttendanceOdontogramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceOdontograms to fetch.
     */
    orderBy?: AttendanceOdontogramOrderByWithRelationInput | AttendanceOdontogramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceOdontograms.
     */
    cursor?: AttendanceOdontogramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceOdontograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceOdontograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceOdontograms.
     */
    distinct?: AttendanceOdontogramScalarFieldEnum | AttendanceOdontogramScalarFieldEnum[]
  }

  /**
   * AttendanceOdontogram findMany
   */
  export type AttendanceOdontogramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceOdontograms to fetch.
     */
    where?: AttendanceOdontogramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceOdontograms to fetch.
     */
    orderBy?: AttendanceOdontogramOrderByWithRelationInput | AttendanceOdontogramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceOdontograms.
     */
    cursor?: AttendanceOdontogramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceOdontograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceOdontograms.
     */
    skip?: number
    distinct?: AttendanceOdontogramScalarFieldEnum | AttendanceOdontogramScalarFieldEnum[]
  }

  /**
   * AttendanceOdontogram create
   */
  export type AttendanceOdontogramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceOdontogram.
     */
    data: XOR<AttendanceOdontogramCreateInput, AttendanceOdontogramUncheckedCreateInput>
  }

  /**
   * AttendanceOdontogram createMany
   */
  export type AttendanceOdontogramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceOdontograms.
     */
    data: AttendanceOdontogramCreateManyInput | AttendanceOdontogramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceOdontogram createManyAndReturn
   */
  export type AttendanceOdontogramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceOdontograms.
     */
    data: AttendanceOdontogramCreateManyInput | AttendanceOdontogramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceOdontogram update
   */
  export type AttendanceOdontogramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceOdontogram.
     */
    data: XOR<AttendanceOdontogramUpdateInput, AttendanceOdontogramUncheckedUpdateInput>
    /**
     * Choose, which AttendanceOdontogram to update.
     */
    where: AttendanceOdontogramWhereUniqueInput
  }

  /**
   * AttendanceOdontogram updateMany
   */
  export type AttendanceOdontogramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceOdontograms.
     */
    data: XOR<AttendanceOdontogramUpdateManyMutationInput, AttendanceOdontogramUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceOdontograms to update
     */
    where?: AttendanceOdontogramWhereInput
    /**
     * Limit how many AttendanceOdontograms to update.
     */
    limit?: number
  }

  /**
   * AttendanceOdontogram updateManyAndReturn
   */
  export type AttendanceOdontogramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceOdontograms.
     */
    data: XOR<AttendanceOdontogramUpdateManyMutationInput, AttendanceOdontogramUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceOdontograms to update
     */
    where?: AttendanceOdontogramWhereInput
    /**
     * Limit how many AttendanceOdontograms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceOdontogram upsert
   */
  export type AttendanceOdontogramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceOdontogram to update in case it exists.
     */
    where: AttendanceOdontogramWhereUniqueInput
    /**
     * In case the AttendanceOdontogram found by the `where` argument doesn't exist, create a new AttendanceOdontogram with this data.
     */
    create: XOR<AttendanceOdontogramCreateInput, AttendanceOdontogramUncheckedCreateInput>
    /**
     * In case the AttendanceOdontogram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceOdontogramUpdateInput, AttendanceOdontogramUncheckedUpdateInput>
  }

  /**
   * AttendanceOdontogram delete
   */
  export type AttendanceOdontogramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
    /**
     * Filter which AttendanceOdontogram to delete.
     */
    where: AttendanceOdontogramWhereUniqueInput
  }

  /**
   * AttendanceOdontogram deleteMany
   */
  export type AttendanceOdontogramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceOdontograms to delete
     */
    where?: AttendanceOdontogramWhereInput
    /**
     * Limit how many AttendanceOdontograms to delete.
     */
    limit?: number
  }

  /**
   * AttendanceOdontogram without action
   */
  export type AttendanceOdontogramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceOdontogram
     */
    select?: AttendanceOdontogramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceOdontogram
     */
    omit?: AttendanceOdontogramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceOdontogramInclude<ExtArgs> | null
  }


  /**
   * Model ClinicalDocument
   */

  export type AggregateClinicalDocument = {
    _count: ClinicalDocumentCountAggregateOutputType | null
    _min: ClinicalDocumentMinAggregateOutputType | null
    _max: ClinicalDocumentMaxAggregateOutputType | null
  }

  export type ClinicalDocumentMinAggregateOutputType = {
    id: string | null
    attendanceId: string | null
    type: $Enums.ClinicalDocumentType | null
    generatedBy: string | null
    generatedAt: Date | null
  }

  export type ClinicalDocumentMaxAggregateOutputType = {
    id: string | null
    attendanceId: string | null
    type: $Enums.ClinicalDocumentType | null
    generatedBy: string | null
    generatedAt: Date | null
  }

  export type ClinicalDocumentCountAggregateOutputType = {
    id: number
    attendanceId: number
    type: number
    payload: number
    generatedBy: number
    generatedAt: number
    _all: number
  }


  export type ClinicalDocumentMinAggregateInputType = {
    id?: true
    attendanceId?: true
    type?: true
    generatedBy?: true
    generatedAt?: true
  }

  export type ClinicalDocumentMaxAggregateInputType = {
    id?: true
    attendanceId?: true
    type?: true
    generatedBy?: true
    generatedAt?: true
  }

  export type ClinicalDocumentCountAggregateInputType = {
    id?: true
    attendanceId?: true
    type?: true
    payload?: true
    generatedBy?: true
    generatedAt?: true
    _all?: true
  }

  export type ClinicalDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalDocument to aggregate.
     */
    where?: ClinicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalDocuments to fetch.
     */
    orderBy?: ClinicalDocumentOrderByWithRelationInput | ClinicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicalDocuments
    **/
    _count?: true | ClinicalDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicalDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicalDocumentMaxAggregateInputType
  }

  export type GetClinicalDocumentAggregateType<T extends ClinicalDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicalDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicalDocument[P]>
      : GetScalarType<T[P], AggregateClinicalDocument[P]>
  }




  export type ClinicalDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalDocumentWhereInput
    orderBy?: ClinicalDocumentOrderByWithAggregationInput | ClinicalDocumentOrderByWithAggregationInput[]
    by: ClinicalDocumentScalarFieldEnum[] | ClinicalDocumentScalarFieldEnum
    having?: ClinicalDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicalDocumentCountAggregateInputType | true
    _min?: ClinicalDocumentMinAggregateInputType
    _max?: ClinicalDocumentMaxAggregateInputType
  }

  export type ClinicalDocumentGroupByOutputType = {
    id: string
    attendanceId: string
    type: $Enums.ClinicalDocumentType
    payload: JsonValue
    generatedBy: string
    generatedAt: Date
    _count: ClinicalDocumentCountAggregateOutputType | null
    _min: ClinicalDocumentMinAggregateOutputType | null
    _max: ClinicalDocumentMaxAggregateOutputType | null
  }

  type GetClinicalDocumentGroupByPayload<T extends ClinicalDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicalDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicalDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicalDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicalDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ClinicalDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    type?: boolean
    payload?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalDocument"]>

  export type ClinicalDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    type?: boolean
    payload?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalDocument"]>

  export type ClinicalDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    type?: boolean
    payload?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalDocument"]>

  export type ClinicalDocumentSelectScalar = {
    id?: boolean
    attendanceId?: boolean
    type?: boolean
    payload?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
  }

  export type ClinicalDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attendanceId" | "type" | "payload" | "generatedBy" | "generatedAt", ExtArgs["result"]["clinicalDocument"]>
  export type ClinicalDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }
  export type ClinicalDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }
  export type ClinicalDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceDefaultArgs<ExtArgs>
  }

  export type $ClinicalDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicalDocument"
    objects: {
      attendance: Prisma.$AttendancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attendanceId: string
      type: $Enums.ClinicalDocumentType
      payload: Prisma.JsonValue
      generatedBy: string
      generatedAt: Date
    }, ExtArgs["result"]["clinicalDocument"]>
    composites: {}
  }

  type ClinicalDocumentGetPayload<S extends boolean | null | undefined | ClinicalDocumentDefaultArgs> = $Result.GetResult<Prisma.$ClinicalDocumentPayload, S>

  type ClinicalDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicalDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicalDocumentCountAggregateInputType | true
    }

  export interface ClinicalDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicalDocument'], meta: { name: 'ClinicalDocument' } }
    /**
     * Find zero or one ClinicalDocument that matches the filter.
     * @param {ClinicalDocumentFindUniqueArgs} args - Arguments to find a ClinicalDocument
     * @example
     * // Get one ClinicalDocument
     * const clinicalDocument = await prisma.clinicalDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicalDocumentFindUniqueArgs>(args: SelectSubset<T, ClinicalDocumentFindUniqueArgs<ExtArgs>>): Prisma__ClinicalDocumentClient<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicalDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicalDocumentFindUniqueOrThrowArgs} args - Arguments to find a ClinicalDocument
     * @example
     * // Get one ClinicalDocument
     * const clinicalDocument = await prisma.clinicalDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicalDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicalDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicalDocumentClient<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalDocumentFindFirstArgs} args - Arguments to find a ClinicalDocument
     * @example
     * // Get one ClinicalDocument
     * const clinicalDocument = await prisma.clinicalDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicalDocumentFindFirstArgs>(args?: SelectSubset<T, ClinicalDocumentFindFirstArgs<ExtArgs>>): Prisma__ClinicalDocumentClient<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalDocumentFindFirstOrThrowArgs} args - Arguments to find a ClinicalDocument
     * @example
     * // Get one ClinicalDocument
     * const clinicalDocument = await prisma.clinicalDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicalDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicalDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicalDocumentClient<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicalDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicalDocuments
     * const clinicalDocuments = await prisma.clinicalDocument.findMany()
     * 
     * // Get first 10 ClinicalDocuments
     * const clinicalDocuments = await prisma.clinicalDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicalDocumentWithIdOnly = await prisma.clinicalDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicalDocumentFindManyArgs>(args?: SelectSubset<T, ClinicalDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicalDocument.
     * @param {ClinicalDocumentCreateArgs} args - Arguments to create a ClinicalDocument.
     * @example
     * // Create one ClinicalDocument
     * const ClinicalDocument = await prisma.clinicalDocument.create({
     *   data: {
     *     // ... data to create a ClinicalDocument
     *   }
     * })
     * 
     */
    create<T extends ClinicalDocumentCreateArgs>(args: SelectSubset<T, ClinicalDocumentCreateArgs<ExtArgs>>): Prisma__ClinicalDocumentClient<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicalDocuments.
     * @param {ClinicalDocumentCreateManyArgs} args - Arguments to create many ClinicalDocuments.
     * @example
     * // Create many ClinicalDocuments
     * const clinicalDocument = await prisma.clinicalDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicalDocumentCreateManyArgs>(args?: SelectSubset<T, ClinicalDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicalDocuments and returns the data saved in the database.
     * @param {ClinicalDocumentCreateManyAndReturnArgs} args - Arguments to create many ClinicalDocuments.
     * @example
     * // Create many ClinicalDocuments
     * const clinicalDocument = await prisma.clinicalDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicalDocuments and only return the `id`
     * const clinicalDocumentWithIdOnly = await prisma.clinicalDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicalDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicalDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicalDocument.
     * @param {ClinicalDocumentDeleteArgs} args - Arguments to delete one ClinicalDocument.
     * @example
     * // Delete one ClinicalDocument
     * const ClinicalDocument = await prisma.clinicalDocument.delete({
     *   where: {
     *     // ... filter to delete one ClinicalDocument
     *   }
     * })
     * 
     */
    delete<T extends ClinicalDocumentDeleteArgs>(args: SelectSubset<T, ClinicalDocumentDeleteArgs<ExtArgs>>): Prisma__ClinicalDocumentClient<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicalDocument.
     * @param {ClinicalDocumentUpdateArgs} args - Arguments to update one ClinicalDocument.
     * @example
     * // Update one ClinicalDocument
     * const clinicalDocument = await prisma.clinicalDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicalDocumentUpdateArgs>(args: SelectSubset<T, ClinicalDocumentUpdateArgs<ExtArgs>>): Prisma__ClinicalDocumentClient<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicalDocuments.
     * @param {ClinicalDocumentDeleteManyArgs} args - Arguments to filter ClinicalDocuments to delete.
     * @example
     * // Delete a few ClinicalDocuments
     * const { count } = await prisma.clinicalDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicalDocumentDeleteManyArgs>(args?: SelectSubset<T, ClinicalDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicalDocuments
     * const clinicalDocument = await prisma.clinicalDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicalDocumentUpdateManyArgs>(args: SelectSubset<T, ClinicalDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalDocuments and returns the data updated in the database.
     * @param {ClinicalDocumentUpdateManyAndReturnArgs} args - Arguments to update many ClinicalDocuments.
     * @example
     * // Update many ClinicalDocuments
     * const clinicalDocument = await prisma.clinicalDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicalDocuments and only return the `id`
     * const clinicalDocumentWithIdOnly = await prisma.clinicalDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicalDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicalDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicalDocument.
     * @param {ClinicalDocumentUpsertArgs} args - Arguments to update or create a ClinicalDocument.
     * @example
     * // Update or create a ClinicalDocument
     * const clinicalDocument = await prisma.clinicalDocument.upsert({
     *   create: {
     *     // ... data to create a ClinicalDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicalDocument we want to update
     *   }
     * })
     */
    upsert<T extends ClinicalDocumentUpsertArgs>(args: SelectSubset<T, ClinicalDocumentUpsertArgs<ExtArgs>>): Prisma__ClinicalDocumentClient<$Result.GetResult<Prisma.$ClinicalDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicalDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalDocumentCountArgs} args - Arguments to filter ClinicalDocuments to count.
     * @example
     * // Count the number of ClinicalDocuments
     * const count = await prisma.clinicalDocument.count({
     *   where: {
     *     // ... the filter for the ClinicalDocuments we want to count
     *   }
     * })
    **/
    count<T extends ClinicalDocumentCountArgs>(
      args?: Subset<T, ClinicalDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicalDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicalDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicalDocumentAggregateArgs>(args: Subset<T, ClinicalDocumentAggregateArgs>): Prisma.PrismaPromise<GetClinicalDocumentAggregateType<T>>

    /**
     * Group by ClinicalDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicalDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicalDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ClinicalDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicalDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicalDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicalDocument model
   */
  readonly fields: ClinicalDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicalDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicalDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends AttendanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDefaultArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicalDocument model
   */
  interface ClinicalDocumentFieldRefs {
    readonly id: FieldRef<"ClinicalDocument", 'String'>
    readonly attendanceId: FieldRef<"ClinicalDocument", 'String'>
    readonly type: FieldRef<"ClinicalDocument", 'ClinicalDocumentType'>
    readonly payload: FieldRef<"ClinicalDocument", 'Json'>
    readonly generatedBy: FieldRef<"ClinicalDocument", 'String'>
    readonly generatedAt: FieldRef<"ClinicalDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicalDocument findUnique
   */
  export type ClinicalDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalDocument to fetch.
     */
    where: ClinicalDocumentWhereUniqueInput
  }

  /**
   * ClinicalDocument findUniqueOrThrow
   */
  export type ClinicalDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalDocument to fetch.
     */
    where: ClinicalDocumentWhereUniqueInput
  }

  /**
   * ClinicalDocument findFirst
   */
  export type ClinicalDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalDocument to fetch.
     */
    where?: ClinicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalDocuments to fetch.
     */
    orderBy?: ClinicalDocumentOrderByWithRelationInput | ClinicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalDocuments.
     */
    cursor?: ClinicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalDocuments.
     */
    distinct?: ClinicalDocumentScalarFieldEnum | ClinicalDocumentScalarFieldEnum[]
  }

  /**
   * ClinicalDocument findFirstOrThrow
   */
  export type ClinicalDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalDocument to fetch.
     */
    where?: ClinicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalDocuments to fetch.
     */
    orderBy?: ClinicalDocumentOrderByWithRelationInput | ClinicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalDocuments.
     */
    cursor?: ClinicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalDocuments.
     */
    distinct?: ClinicalDocumentScalarFieldEnum | ClinicalDocumentScalarFieldEnum[]
  }

  /**
   * ClinicalDocument findMany
   */
  export type ClinicalDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalDocuments to fetch.
     */
    where?: ClinicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalDocuments to fetch.
     */
    orderBy?: ClinicalDocumentOrderByWithRelationInput | ClinicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicalDocuments.
     */
    cursor?: ClinicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalDocuments.
     */
    skip?: number
    distinct?: ClinicalDocumentScalarFieldEnum | ClinicalDocumentScalarFieldEnum[]
  }

  /**
   * ClinicalDocument create
   */
  export type ClinicalDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicalDocument.
     */
    data: XOR<ClinicalDocumentCreateInput, ClinicalDocumentUncheckedCreateInput>
  }

  /**
   * ClinicalDocument createMany
   */
  export type ClinicalDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicalDocuments.
     */
    data: ClinicalDocumentCreateManyInput | ClinicalDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicalDocument createManyAndReturn
   */
  export type ClinicalDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicalDocuments.
     */
    data: ClinicalDocumentCreateManyInput | ClinicalDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalDocument update
   */
  export type ClinicalDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicalDocument.
     */
    data: XOR<ClinicalDocumentUpdateInput, ClinicalDocumentUncheckedUpdateInput>
    /**
     * Choose, which ClinicalDocument to update.
     */
    where: ClinicalDocumentWhereUniqueInput
  }

  /**
   * ClinicalDocument updateMany
   */
  export type ClinicalDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicalDocuments.
     */
    data: XOR<ClinicalDocumentUpdateManyMutationInput, ClinicalDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalDocuments to update
     */
    where?: ClinicalDocumentWhereInput
    /**
     * Limit how many ClinicalDocuments to update.
     */
    limit?: number
  }

  /**
   * ClinicalDocument updateManyAndReturn
   */
  export type ClinicalDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * The data used to update ClinicalDocuments.
     */
    data: XOR<ClinicalDocumentUpdateManyMutationInput, ClinicalDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalDocuments to update
     */
    where?: ClinicalDocumentWhereInput
    /**
     * Limit how many ClinicalDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalDocument upsert
   */
  export type ClinicalDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicalDocument to update in case it exists.
     */
    where: ClinicalDocumentWhereUniqueInput
    /**
     * In case the ClinicalDocument found by the `where` argument doesn't exist, create a new ClinicalDocument with this data.
     */
    create: XOR<ClinicalDocumentCreateInput, ClinicalDocumentUncheckedCreateInput>
    /**
     * In case the ClinicalDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicalDocumentUpdateInput, ClinicalDocumentUncheckedUpdateInput>
  }

  /**
   * ClinicalDocument delete
   */
  export type ClinicalDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
    /**
     * Filter which ClinicalDocument to delete.
     */
    where: ClinicalDocumentWhereUniqueInput
  }

  /**
   * ClinicalDocument deleteMany
   */
  export type ClinicalDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalDocuments to delete
     */
    where?: ClinicalDocumentWhereInput
    /**
     * Limit how many ClinicalDocuments to delete.
     */
    limit?: number
  }

  /**
   * ClinicalDocument without action
   */
  export type ClinicalDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalDocument
     */
    select?: ClinicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalDocument
     */
    omit?: ClinicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalDocumentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClinicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicScalarFieldEnum = (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DentistScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    userId: 'userId',
    cro: 'cro',
    specialty: 'specialty',
    workingHours: 'workingHours',
    bankInfo: 'bankInfo',
    contactInfo: 'contactInfo',
    personalInfo: 'personalInfo',
    commission: 'commission',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DentistScalarFieldEnum = (typeof DentistScalarFieldEnum)[keyof typeof DentistScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    cpf: 'cpf',
    birthDate: 'birthDate',
    address: 'address',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    dentistId: 'dentistId',
    patientId: 'patientId',
    date: 'date',
    durationMinutes: 'durationMinutes',
    status: 'status',
    procedure: 'procedure',
    procedureId: 'procedureId',
    procedureSnapshot: 'procedureSnapshot',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const RecordScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    dentistId: 'dentistId',
    appointmentId: 'appointmentId',
    attendanceId: 'attendanceId',
    description: 'description',
    procedures: 'procedures',
    odontogram: 'odontogram',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecordScalarFieldEnum = (typeof RecordScalarFieldEnum)[keyof typeof RecordScalarFieldEnum]


  export const TreatmentPlanScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    dentistId: 'dentistId',
    status: 'status',
    totalAmount: 'totalAmount',
    discountType: 'discountType',
    discountValue: 'discountValue',
    finalAmount: 'finalAmount',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TreatmentPlanScalarFieldEnum = (typeof TreatmentPlanScalarFieldEnum)[keyof typeof TreatmentPlanScalarFieldEnum]


  export const TreatmentItemScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    procedureId: 'procedureId',
    description: 'description',
    tooth: 'tooth',
    value: 'value',
    quantity: 'quantity'
  };

  export type TreatmentItemScalarFieldEnum = (typeof TreatmentItemScalarFieldEnum)[keyof typeof TreatmentItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    originalAmount: 'originalAmount',
    discountType: 'discountType',
    discountValue: 'discountValue',
    amount: 'amount',
    method: 'method',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentTreatmentPlanScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    treatmentPlanId: 'treatmentPlanId',
    createdAt: 'createdAt'
  };

  export type PaymentTreatmentPlanScalarFieldEnum = (typeof PaymentTreatmentPlanScalarFieldEnum)[keyof typeof PaymentTreatmentPlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    status: 'status',
    currentPeriodEnd: 'currentPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    userId: 'userId',
    action: 'action',
    targetId: 'targetId',
    targetType: 'targetType',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    name: 'name',
    description: 'description',
    unit: 'unit',
    currentQuantity: 'currentQuantity',
    minQuantity: 'minQuantity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    itemId: 'itemId',
    type: 'type',
    quantity: 'quantity',
    appointmentId: 'appointmentId',
    createdById: 'createdById',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const SpecialtyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialtyScalarFieldEnum = (typeof SpecialtyScalarFieldEnum)[keyof typeof SpecialtyScalarFieldEnum]


  export const CIDScalarFieldEnum: {
    id: 'id',
    code: 'code',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CIDScalarFieldEnum = (typeof CIDScalarFieldEnum)[keyof typeof CIDScalarFieldEnum]


  export const ProcedureScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    specialtyId: 'specialtyId',
    name: 'name',
    description: 'description',
    baseValue: 'baseValue',
    commissionPercentage: 'commissionPercentage',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcedureScalarFieldEnum = (typeof ProcedureScalarFieldEnum)[keyof typeof ProcedureScalarFieldEnum]


  export const DentistProcedureScalarFieldEnum: {
    id: 'id',
    dentistId: 'dentistId',
    procedureId: 'procedureId',
    createdAt: 'createdAt'
  };

  export type DentistProcedureScalarFieldEnum = (typeof DentistProcedureScalarFieldEnum)[keyof typeof DentistProcedureScalarFieldEnum]


  export const DentistSpecialtyScalarFieldEnum: {
    id: 'id',
    dentistId: 'dentistId',
    specialtyId: 'specialtyId',
    createdAt: 'createdAt'
  };

  export type DentistSpecialtyScalarFieldEnum = (typeof DentistSpecialtyScalarFieldEnum)[keyof typeof DentistSpecialtyScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    appointmentId: 'appointmentId',
    patientId: 'patientId',
    dentistId: 'dentistId',
    status: 'status',
    arrivalAt: 'arrivalAt',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    createdByRole: 'createdByRole',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const AttendanceCIDScalarFieldEnum: {
    id: 'id',
    attendanceId: 'attendanceId',
    cidCode: 'cidCode',
    description: 'description',
    observation: 'observation',
    createdByDentistId: 'createdByDentistId'
  };

  export type AttendanceCIDScalarFieldEnum = (typeof AttendanceCIDScalarFieldEnum)[keyof typeof AttendanceCIDScalarFieldEnum]


  export const AttendanceProcedureScalarFieldEnum: {
    id: 'id',
    attendanceId: 'attendanceId',
    procedureId: 'procedureId',
    procedureCode: 'procedureCode',
    description: 'description',
    tooth: 'tooth',
    surface: 'surface',
    faces: 'faces',
    quantity: 'quantity',
    clinicalStatus: 'clinicalStatus',
    price: 'price',
    dentistId: 'dentistId',
    observations: 'observations',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceProcedureScalarFieldEnum = (typeof AttendanceProcedureScalarFieldEnum)[keyof typeof AttendanceProcedureScalarFieldEnum]


  export const AttendanceOdontogramScalarFieldEnum: {
    attendanceId: 'attendanceId',
    data: 'data'
  };

  export type AttendanceOdontogramScalarFieldEnum = (typeof AttendanceOdontogramScalarFieldEnum)[keyof typeof AttendanceOdontogramScalarFieldEnum]


  export const ClinicalDocumentScalarFieldEnum: {
    id: 'id',
    attendanceId: 'attendanceId',
    type: 'type',
    payload: 'payload',
    generatedBy: 'generatedBy',
    generatedAt: 'generatedAt'
  };

  export type ClinicalDocumentScalarFieldEnum = (typeof ClinicalDocumentScalarFieldEnum)[keyof typeof ClinicalDocumentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'TreatmentPlanStatus'
   */
  export type EnumTreatmentPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreatmentPlanStatus'>
    


  /**
   * Reference to a field of type 'TreatmentPlanStatus[]'
   */
  export type ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreatmentPlanStatus[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'InventoryMovementType'
   */
  export type EnumInventoryMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryMovementType'>
    


  /**
   * Reference to a field of type 'InventoryMovementType[]'
   */
  export type ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryMovementType[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'ClinicalDocumentType'
   */
  export type EnumClinicalDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClinicalDocumentType'>
    


  /**
   * Reference to a field of type 'ClinicalDocumentType[]'
   */
  export type ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClinicalDocumentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ClinicWhereInput = {
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    id?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    email?: StringFilter<"Clinic"> | string
    phone?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    users?: UserListRelationFilter
    dentists?: DentistListRelationFilter
    patients?: PatientListRelationFilter
    appointments?: AppointmentListRelationFilter
    records?: RecordListRelationFilter
    treatmentPlans?: TreatmentPlanListRelationFilter
    payments?: PaymentListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    procedures?: ProcedureListRelationFilter
    attendances?: AttendanceListRelationFilter
  }

  export type ClinicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    dentists?: DentistOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    records?: RecordOrderByRelationAggregateInput
    treatmentPlans?: TreatmentPlanOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    procedures?: ProcedureOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
  }

  export type ClinicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    name?: StringFilter<"Clinic"> | string
    email?: StringFilter<"Clinic"> | string
    phone?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    users?: UserListRelationFilter
    dentists?: DentistListRelationFilter
    patients?: PatientListRelationFilter
    appointments?: AppointmentListRelationFilter
    records?: RecordListRelationFilter
    treatmentPlans?: TreatmentPlanListRelationFilter
    payments?: PaymentListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    procedures?: ProcedureListRelationFilter
    attendances?: AttendanceListRelationFilter
  }, "id">

  export type ClinicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicCountOrderByAggregateInput
    _max?: ClinicMaxOrderByAggregateInput
    _min?: ClinicMinOrderByAggregateInput
  }

  export type ClinicScalarWhereWithAggregatesInput = {
    AND?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    OR?: ClinicScalarWhereWithAggregatesInput[]
    NOT?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Clinic"> | string
    name?: StringWithAggregatesFilter<"Clinic"> | string
    email?: StringWithAggregatesFilter<"Clinic"> | string
    phone?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    address?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    clinicId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    dentist?: XOR<DentistNullableScalarRelationFilter, DentistWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    attendances?: AttendanceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    dentist?: DentistOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clinicId_email?: UserClinicIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    clinicId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    dentist?: XOR<DentistNullableScalarRelationFilter, DentistWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    attendances?: AttendanceListRelationFilter
  }, "id" | "clinicId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    clinicId?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DentistWhereInput = {
    AND?: DentistWhereInput | DentistWhereInput[]
    OR?: DentistWhereInput[]
    NOT?: DentistWhereInput | DentistWhereInput[]
    id?: StringFilter<"Dentist"> | string
    clinicId?: StringFilter<"Dentist"> | string
    userId?: StringFilter<"Dentist"> | string
    cro?: StringFilter<"Dentist"> | string
    specialty?: StringNullableFilter<"Dentist"> | string | null
    workingHours?: JsonNullableFilter<"Dentist">
    bankInfo?: JsonNullableFilter<"Dentist">
    contactInfo?: JsonNullableFilter<"Dentist">
    personalInfo?: JsonNullableFilter<"Dentist">
    commission?: DecimalNullableFilter<"Dentist"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Dentist"> | Date | string
    updatedAt?: DateTimeFilter<"Dentist"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointments?: AppointmentListRelationFilter
    records?: RecordListRelationFilter
    treatmentPlans?: TreatmentPlanListRelationFilter
    dentistProcedures?: DentistProcedureListRelationFilter
    dentistSpecialties?: DentistSpecialtyListRelationFilter
    attendances?: AttendanceListRelationFilter
    attendanceCids?: AttendanceCIDListRelationFilter
    attendanceProcedures?: AttendanceProcedureListRelationFilter
  }

  export type DentistOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    cro?: SortOrder
    specialty?: SortOrderInput | SortOrder
    workingHours?: SortOrderInput | SortOrder
    bankInfo?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    personalInfo?: SortOrderInput | SortOrder
    commission?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    records?: RecordOrderByRelationAggregateInput
    treatmentPlans?: TreatmentPlanOrderByRelationAggregateInput
    dentistProcedures?: DentistProcedureOrderByRelationAggregateInput
    dentistSpecialties?: DentistSpecialtyOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    attendanceCids?: AttendanceCIDOrderByRelationAggregateInput
    attendanceProcedures?: AttendanceProcedureOrderByRelationAggregateInput
  }

  export type DentistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DentistWhereInput | DentistWhereInput[]
    OR?: DentistWhereInput[]
    NOT?: DentistWhereInput | DentistWhereInput[]
    clinicId?: StringFilter<"Dentist"> | string
    cro?: StringFilter<"Dentist"> | string
    specialty?: StringNullableFilter<"Dentist"> | string | null
    workingHours?: JsonNullableFilter<"Dentist">
    bankInfo?: JsonNullableFilter<"Dentist">
    contactInfo?: JsonNullableFilter<"Dentist">
    personalInfo?: JsonNullableFilter<"Dentist">
    commission?: DecimalNullableFilter<"Dentist"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Dentist"> | Date | string
    updatedAt?: DateTimeFilter<"Dentist"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointments?: AppointmentListRelationFilter
    records?: RecordListRelationFilter
    treatmentPlans?: TreatmentPlanListRelationFilter
    dentistProcedures?: DentistProcedureListRelationFilter
    dentistSpecialties?: DentistSpecialtyListRelationFilter
    attendances?: AttendanceListRelationFilter
    attendanceCids?: AttendanceCIDListRelationFilter
    attendanceProcedures?: AttendanceProcedureListRelationFilter
  }, "id" | "userId">

  export type DentistOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    cro?: SortOrder
    specialty?: SortOrderInput | SortOrder
    workingHours?: SortOrderInput | SortOrder
    bankInfo?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    personalInfo?: SortOrderInput | SortOrder
    commission?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DentistCountOrderByAggregateInput
    _avg?: DentistAvgOrderByAggregateInput
    _max?: DentistMaxOrderByAggregateInput
    _min?: DentistMinOrderByAggregateInput
    _sum?: DentistSumOrderByAggregateInput
  }

  export type DentistScalarWhereWithAggregatesInput = {
    AND?: DentistScalarWhereWithAggregatesInput | DentistScalarWhereWithAggregatesInput[]
    OR?: DentistScalarWhereWithAggregatesInput[]
    NOT?: DentistScalarWhereWithAggregatesInput | DentistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dentist"> | string
    clinicId?: StringWithAggregatesFilter<"Dentist"> | string
    userId?: StringWithAggregatesFilter<"Dentist"> | string
    cro?: StringWithAggregatesFilter<"Dentist"> | string
    specialty?: StringNullableWithAggregatesFilter<"Dentist"> | string | null
    workingHours?: JsonNullableWithAggregatesFilter<"Dentist">
    bankInfo?: JsonNullableWithAggregatesFilter<"Dentist">
    contactInfo?: JsonNullableWithAggregatesFilter<"Dentist">
    personalInfo?: JsonNullableWithAggregatesFilter<"Dentist">
    commission?: DecimalNullableWithAggregatesFilter<"Dentist"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Dentist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dentist"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    clinicId?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    cpf?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    appointments?: AppointmentListRelationFilter
    records?: RecordListRelationFilter
    treatmentPlans?: TreatmentPlanListRelationFilter
    payments?: PaymentListRelationFilter
    attendances?: AttendanceListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    records?: RecordOrderByRelationAggregateInput
    treatmentPlans?: TreatmentPlanOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    clinicId?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    cpf?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    appointments?: AppointmentListRelationFilter
    records?: RecordListRelationFilter
    treatmentPlans?: TreatmentPlanListRelationFilter
    payments?: PaymentListRelationFilter
    attendances?: AttendanceListRelationFilter
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    clinicId?: StringWithAggregatesFilter<"Patient"> | string
    name?: StringWithAggregatesFilter<"Patient"> | string
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    cpf?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    isActive?: BoolWithAggregatesFilter<"Patient"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    clinicId?: StringFilter<"Appointment"> | string
    dentistId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    date?: DateTimeFilter<"Appointment"> | Date | string
    durationMinutes?: IntFilter<"Appointment"> | number
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    procedure?: StringNullableFilter<"Appointment"> | string | null
    procedureId?: StringNullableFilter<"Appointment"> | string | null
    procedureSnapshot?: JsonNullableFilter<"Appointment">
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    procedureRelation?: XOR<ProcedureNullableScalarRelationFilter, ProcedureWhereInput> | null
    record?: XOR<RecordNullableScalarRelationFilter, RecordWhereInput> | null
    inventoryMovements?: InventoryMovementListRelationFilter
    attendance?: XOR<AttendanceNullableScalarRelationFilter, AttendanceWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    dentistId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrder
    procedure?: SortOrderInput | SortOrder
    procedureId?: SortOrderInput | SortOrder
    procedureSnapshot?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    dentist?: DentistOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    procedureRelation?: ProcedureOrderByWithRelationInput
    record?: RecordOrderByWithRelationInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    attendance?: AttendanceOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    clinicId?: StringFilter<"Appointment"> | string
    dentistId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    date?: DateTimeFilter<"Appointment"> | Date | string
    durationMinutes?: IntFilter<"Appointment"> | number
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    procedure?: StringNullableFilter<"Appointment"> | string | null
    procedureId?: StringNullableFilter<"Appointment"> | string | null
    procedureSnapshot?: JsonNullableFilter<"Appointment">
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    procedureRelation?: XOR<ProcedureNullableScalarRelationFilter, ProcedureWhereInput> | null
    record?: XOR<RecordNullableScalarRelationFilter, RecordWhereInput> | null
    inventoryMovements?: InventoryMovementListRelationFilter
    attendance?: XOR<AttendanceNullableScalarRelationFilter, AttendanceWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    dentistId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrder
    procedure?: SortOrderInput | SortOrder
    procedureId?: SortOrderInput | SortOrder
    procedureSnapshot?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    clinicId?: StringWithAggregatesFilter<"Appointment"> | string
    dentistId?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    date?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    durationMinutes?: IntWithAggregatesFilter<"Appointment"> | number
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    procedure?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    procedureId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    procedureSnapshot?: JsonNullableWithAggregatesFilter<"Appointment">
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type RecordWhereInput = {
    AND?: RecordWhereInput | RecordWhereInput[]
    OR?: RecordWhereInput[]
    NOT?: RecordWhereInput | RecordWhereInput[]
    id?: StringFilter<"Record"> | string
    clinicId?: StringFilter<"Record"> | string
    patientId?: StringFilter<"Record"> | string
    dentistId?: StringFilter<"Record"> | string
    appointmentId?: StringNullableFilter<"Record"> | string | null
    attendanceId?: StringNullableFilter<"Record"> | string | null
    description?: StringFilter<"Record"> | string
    procedures?: JsonNullableFilter<"Record">
    odontogram?: JsonNullableFilter<"Record">
    createdAt?: DateTimeFilter<"Record"> | Date | string
    updatedAt?: DateTimeFilter<"Record"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    attendance?: XOR<AttendanceNullableScalarRelationFilter, AttendanceWhereInput> | null
  }

  export type RecordOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    attendanceId?: SortOrderInput | SortOrder
    description?: SortOrder
    procedures?: SortOrderInput | SortOrder
    odontogram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    dentist?: DentistOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    attendance?: AttendanceOrderByWithRelationInput
  }

  export type RecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    attendanceId?: string
    AND?: RecordWhereInput | RecordWhereInput[]
    OR?: RecordWhereInput[]
    NOT?: RecordWhereInput | RecordWhereInput[]
    clinicId?: StringFilter<"Record"> | string
    patientId?: StringFilter<"Record"> | string
    dentistId?: StringFilter<"Record"> | string
    description?: StringFilter<"Record"> | string
    procedures?: JsonNullableFilter<"Record">
    odontogram?: JsonNullableFilter<"Record">
    createdAt?: DateTimeFilter<"Record"> | Date | string
    updatedAt?: DateTimeFilter<"Record"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    attendance?: XOR<AttendanceNullableScalarRelationFilter, AttendanceWhereInput> | null
  }, "id" | "appointmentId" | "attendanceId">

  export type RecordOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    attendanceId?: SortOrderInput | SortOrder
    description?: SortOrder
    procedures?: SortOrderInput | SortOrder
    odontogram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecordCountOrderByAggregateInput
    _max?: RecordMaxOrderByAggregateInput
    _min?: RecordMinOrderByAggregateInput
  }

  export type RecordScalarWhereWithAggregatesInput = {
    AND?: RecordScalarWhereWithAggregatesInput | RecordScalarWhereWithAggregatesInput[]
    OR?: RecordScalarWhereWithAggregatesInput[]
    NOT?: RecordScalarWhereWithAggregatesInput | RecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Record"> | string
    clinicId?: StringWithAggregatesFilter<"Record"> | string
    patientId?: StringWithAggregatesFilter<"Record"> | string
    dentistId?: StringWithAggregatesFilter<"Record"> | string
    appointmentId?: StringNullableWithAggregatesFilter<"Record"> | string | null
    attendanceId?: StringNullableWithAggregatesFilter<"Record"> | string | null
    description?: StringWithAggregatesFilter<"Record"> | string
    procedures?: JsonNullableWithAggregatesFilter<"Record">
    odontogram?: JsonNullableWithAggregatesFilter<"Record">
    createdAt?: DateTimeWithAggregatesFilter<"Record"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Record"> | Date | string
  }

  export type TreatmentPlanWhereInput = {
    AND?: TreatmentPlanWhereInput | TreatmentPlanWhereInput[]
    OR?: TreatmentPlanWhereInput[]
    NOT?: TreatmentPlanWhereInput | TreatmentPlanWhereInput[]
    id?: StringFilter<"TreatmentPlan"> | string
    clinicId?: StringFilter<"TreatmentPlan"> | string
    patientId?: StringFilter<"TreatmentPlan"> | string
    dentistId?: StringFilter<"TreatmentPlan"> | string
    status?: EnumTreatmentPlanStatusFilter<"TreatmentPlan"> | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string
    discountType?: EnumDiscountTypeNullableFilter<"TreatmentPlan"> | $Enums.DiscountType | null
    discountValue?: DecimalNullableFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string | null
    finalAmount?: DecimalNullableFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"TreatmentPlan"> | string | null
    createdAt?: DateTimeFilter<"TreatmentPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TreatmentPlan"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    items?: TreatmentItemListRelationFilter
    paymentTreatmentPlans?: PaymentTreatmentPlanListRelationFilter
  }

  export type TreatmentPlanOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    discountType?: SortOrderInput | SortOrder
    discountValue?: SortOrderInput | SortOrder
    finalAmount?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    dentist?: DentistOrderByWithRelationInput
    items?: TreatmentItemOrderByRelationAggregateInput
    paymentTreatmentPlans?: PaymentTreatmentPlanOrderByRelationAggregateInput
  }

  export type TreatmentPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TreatmentPlanWhereInput | TreatmentPlanWhereInput[]
    OR?: TreatmentPlanWhereInput[]
    NOT?: TreatmentPlanWhereInput | TreatmentPlanWhereInput[]
    clinicId?: StringFilter<"TreatmentPlan"> | string
    patientId?: StringFilter<"TreatmentPlan"> | string
    dentistId?: StringFilter<"TreatmentPlan"> | string
    status?: EnumTreatmentPlanStatusFilter<"TreatmentPlan"> | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string
    discountType?: EnumDiscountTypeNullableFilter<"TreatmentPlan"> | $Enums.DiscountType | null
    discountValue?: DecimalNullableFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string | null
    finalAmount?: DecimalNullableFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"TreatmentPlan"> | string | null
    createdAt?: DateTimeFilter<"TreatmentPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TreatmentPlan"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    items?: TreatmentItemListRelationFilter
    paymentTreatmentPlans?: PaymentTreatmentPlanListRelationFilter
  }, "id">

  export type TreatmentPlanOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    discountType?: SortOrderInput | SortOrder
    discountValue?: SortOrderInput | SortOrder
    finalAmount?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TreatmentPlanCountOrderByAggregateInput
    _avg?: TreatmentPlanAvgOrderByAggregateInput
    _max?: TreatmentPlanMaxOrderByAggregateInput
    _min?: TreatmentPlanMinOrderByAggregateInput
    _sum?: TreatmentPlanSumOrderByAggregateInput
  }

  export type TreatmentPlanScalarWhereWithAggregatesInput = {
    AND?: TreatmentPlanScalarWhereWithAggregatesInput | TreatmentPlanScalarWhereWithAggregatesInput[]
    OR?: TreatmentPlanScalarWhereWithAggregatesInput[]
    NOT?: TreatmentPlanScalarWhereWithAggregatesInput | TreatmentPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TreatmentPlan"> | string
    clinicId?: StringWithAggregatesFilter<"TreatmentPlan"> | string
    patientId?: StringWithAggregatesFilter<"TreatmentPlan"> | string
    dentistId?: StringWithAggregatesFilter<"TreatmentPlan"> | string
    status?: EnumTreatmentPlanStatusWithAggregatesFilter<"TreatmentPlan"> | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalWithAggregatesFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string
    discountType?: EnumDiscountTypeNullableWithAggregatesFilter<"TreatmentPlan"> | $Enums.DiscountType | null
    discountValue?: DecimalNullableWithAggregatesFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string | null
    finalAmount?: DecimalNullableWithAggregatesFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"TreatmentPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TreatmentPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TreatmentPlan"> | Date | string
  }

  export type TreatmentItemWhereInput = {
    AND?: TreatmentItemWhereInput | TreatmentItemWhereInput[]
    OR?: TreatmentItemWhereInput[]
    NOT?: TreatmentItemWhereInput | TreatmentItemWhereInput[]
    id?: StringFilter<"TreatmentItem"> | string
    planId?: StringFilter<"TreatmentItem"> | string
    procedureId?: StringNullableFilter<"TreatmentItem"> | string | null
    description?: StringFilter<"TreatmentItem"> | string
    tooth?: StringNullableFilter<"TreatmentItem"> | string | null
    value?: DecimalFilter<"TreatmentItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"TreatmentItem"> | number
    plan?: XOR<TreatmentPlanScalarRelationFilter, TreatmentPlanWhereInput>
    procedure?: XOR<ProcedureNullableScalarRelationFilter, ProcedureWhereInput> | null
  }

  export type TreatmentItemOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    procedureId?: SortOrderInput | SortOrder
    description?: SortOrder
    tooth?: SortOrderInput | SortOrder
    value?: SortOrder
    quantity?: SortOrder
    plan?: TreatmentPlanOrderByWithRelationInput
    procedure?: ProcedureOrderByWithRelationInput
  }

  export type TreatmentItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TreatmentItemWhereInput | TreatmentItemWhereInput[]
    OR?: TreatmentItemWhereInput[]
    NOT?: TreatmentItemWhereInput | TreatmentItemWhereInput[]
    planId?: StringFilter<"TreatmentItem"> | string
    procedureId?: StringNullableFilter<"TreatmentItem"> | string | null
    description?: StringFilter<"TreatmentItem"> | string
    tooth?: StringNullableFilter<"TreatmentItem"> | string | null
    value?: DecimalFilter<"TreatmentItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"TreatmentItem"> | number
    plan?: XOR<TreatmentPlanScalarRelationFilter, TreatmentPlanWhereInput>
    procedure?: XOR<ProcedureNullableScalarRelationFilter, ProcedureWhereInput> | null
  }, "id">

  export type TreatmentItemOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    procedureId?: SortOrderInput | SortOrder
    description?: SortOrder
    tooth?: SortOrderInput | SortOrder
    value?: SortOrder
    quantity?: SortOrder
    _count?: TreatmentItemCountOrderByAggregateInput
    _avg?: TreatmentItemAvgOrderByAggregateInput
    _max?: TreatmentItemMaxOrderByAggregateInput
    _min?: TreatmentItemMinOrderByAggregateInput
    _sum?: TreatmentItemSumOrderByAggregateInput
  }

  export type TreatmentItemScalarWhereWithAggregatesInput = {
    AND?: TreatmentItemScalarWhereWithAggregatesInput | TreatmentItemScalarWhereWithAggregatesInput[]
    OR?: TreatmentItemScalarWhereWithAggregatesInput[]
    NOT?: TreatmentItemScalarWhereWithAggregatesInput | TreatmentItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TreatmentItem"> | string
    planId?: StringWithAggregatesFilter<"TreatmentItem"> | string
    procedureId?: StringNullableWithAggregatesFilter<"TreatmentItem"> | string | null
    description?: StringWithAggregatesFilter<"TreatmentItem"> | string
    tooth?: StringNullableWithAggregatesFilter<"TreatmentItem"> | string | null
    value?: DecimalWithAggregatesFilter<"TreatmentItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"TreatmentItem"> | number
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    clinicId?: StringFilter<"Payment"> | string
    patientId?: StringNullableFilter<"Payment"> | string | null
    originalAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    discountType?: EnumDiscountTypeNullableFilter<"Payment"> | $Enums.DiscountType | null
    discountValue?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    paymentTreatmentPlans?: PaymentTreatmentPlanListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrderInput | SortOrder
    originalAmount?: SortOrderInput | SortOrder
    discountType?: SortOrderInput | SortOrder
    discountValue?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    paymentTreatmentPlans?: PaymentTreatmentPlanOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    clinicId?: StringFilter<"Payment"> | string
    patientId?: StringNullableFilter<"Payment"> | string | null
    originalAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    discountType?: EnumDiscountTypeNullableFilter<"Payment"> | $Enums.DiscountType | null
    discountValue?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    paymentTreatmentPlans?: PaymentTreatmentPlanListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrderInput | SortOrder
    originalAmount?: SortOrderInput | SortOrder
    discountType?: SortOrderInput | SortOrder
    discountValue?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    clinicId?: StringWithAggregatesFilter<"Payment"> | string
    patientId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    originalAmount?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    discountType?: EnumDiscountTypeNullableWithAggregatesFilter<"Payment"> | $Enums.DiscountType | null
    discountValue?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PaymentTreatmentPlanWhereInput = {
    AND?: PaymentTreatmentPlanWhereInput | PaymentTreatmentPlanWhereInput[]
    OR?: PaymentTreatmentPlanWhereInput[]
    NOT?: PaymentTreatmentPlanWhereInput | PaymentTreatmentPlanWhereInput[]
    id?: StringFilter<"PaymentTreatmentPlan"> | string
    paymentId?: StringFilter<"PaymentTreatmentPlan"> | string
    treatmentPlanId?: StringFilter<"PaymentTreatmentPlan"> | string
    createdAt?: DateTimeFilter<"PaymentTreatmentPlan"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    treatmentPlan?: XOR<TreatmentPlanScalarRelationFilter, TreatmentPlanWhereInput>
  }

  export type PaymentTreatmentPlanOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    treatmentPlanId?: SortOrder
    createdAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    treatmentPlan?: TreatmentPlanOrderByWithRelationInput
  }

  export type PaymentTreatmentPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentId_treatmentPlanId?: PaymentTreatmentPlanPaymentIdTreatmentPlanIdCompoundUniqueInput
    AND?: PaymentTreatmentPlanWhereInput | PaymentTreatmentPlanWhereInput[]
    OR?: PaymentTreatmentPlanWhereInput[]
    NOT?: PaymentTreatmentPlanWhereInput | PaymentTreatmentPlanWhereInput[]
    paymentId?: StringFilter<"PaymentTreatmentPlan"> | string
    treatmentPlanId?: StringFilter<"PaymentTreatmentPlan"> | string
    createdAt?: DateTimeFilter<"PaymentTreatmentPlan"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    treatmentPlan?: XOR<TreatmentPlanScalarRelationFilter, TreatmentPlanWhereInput>
  }, "id" | "paymentId_treatmentPlanId">

  export type PaymentTreatmentPlanOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    treatmentPlanId?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentTreatmentPlanCountOrderByAggregateInput
    _max?: PaymentTreatmentPlanMaxOrderByAggregateInput
    _min?: PaymentTreatmentPlanMinOrderByAggregateInput
  }

  export type PaymentTreatmentPlanScalarWhereWithAggregatesInput = {
    AND?: PaymentTreatmentPlanScalarWhereWithAggregatesInput | PaymentTreatmentPlanScalarWhereWithAggregatesInput[]
    OR?: PaymentTreatmentPlanScalarWhereWithAggregatesInput[]
    NOT?: PaymentTreatmentPlanScalarWhereWithAggregatesInput | PaymentTreatmentPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentTreatmentPlan"> | string
    paymentId?: StringWithAggregatesFilter<"PaymentTreatmentPlan"> | string
    treatmentPlanId?: StringWithAggregatesFilter<"PaymentTreatmentPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentTreatmentPlan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    clinicId?: StringFilter<"Subscription"> | string
    stripeCustomerId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clinicId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    stripeCustomerId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
  }, "id" | "clinicId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    clinicId?: StringWithAggregatesFilter<"Subscription"> | string
    stripeCustomerId?: StringWithAggregatesFilter<"Subscription"> | string
    stripeSubscriptionId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    clinicId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    targetType?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetType?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    clinicId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    targetType?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetType?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    clinicId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    targetType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    clinicId?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    currentQuantity?: IntFilter<"InventoryItem"> | number
    minQuantity?: IntNullableFilter<"InventoryItem"> | number | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    movements?: InventoryMovementListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    movements?: InventoryMovementOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    clinicId?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    currentQuantity?: IntFilter<"InventoryItem"> | number
    minQuantity?: IntNullableFilter<"InventoryItem"> | number | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    movements?: InventoryMovementListRelationFilter
  }, "id">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    clinicId?: StringWithAggregatesFilter<"InventoryItem"> | string
    name?: StringWithAggregatesFilter<"InventoryItem"> | string
    description?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    unit?: StringWithAggregatesFilter<"InventoryItem"> | string
    currentQuantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    minQuantity?: IntNullableWithAggregatesFilter<"InventoryItem"> | number | null
    isActive?: BoolWithAggregatesFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    clinicId?: StringFilter<"InventoryMovement"> | string
    itemId?: StringFilter<"InventoryMovement"> | string
    type?: EnumInventoryMovementTypeFilter<"InventoryMovement"> | $Enums.InventoryMovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    appointmentId?: StringNullableFilter<"InventoryMovement"> | string | null
    createdById?: StringFilter<"InventoryMovement"> | string
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    item?: InventoryItemOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    clinicId?: StringFilter<"InventoryMovement"> | string
    itemId?: StringFilter<"InventoryMovement"> | string
    type?: EnumInventoryMovementTypeFilter<"InventoryMovement"> | $Enums.InventoryMovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    appointmentId?: StringNullableFilter<"InventoryMovement"> | string | null
    createdById?: StringFilter<"InventoryMovement"> | string
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryMovement"> | string
    clinicId?: StringWithAggregatesFilter<"InventoryMovement"> | string
    itemId?: StringWithAggregatesFilter<"InventoryMovement"> | string
    type?: EnumInventoryMovementTypeWithAggregatesFilter<"InventoryMovement"> | $Enums.InventoryMovementType
    quantity?: IntWithAggregatesFilter<"InventoryMovement"> | number
    appointmentId?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    createdById?: StringWithAggregatesFilter<"InventoryMovement"> | string
    notes?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
  }

  export type SpecialtyWhereInput = {
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    id?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    description?: StringNullableFilter<"Specialty"> | string | null
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
    procedures?: ProcedureListRelationFilter
    dentistSpecialties?: DentistSpecialtyListRelationFilter
  }

  export type SpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procedures?: ProcedureOrderByRelationAggregateInput
    dentistSpecialties?: DentistSpecialtyOrderByRelationAggregateInput
  }

  export type SpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    description?: StringNullableFilter<"Specialty"> | string | null
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
    procedures?: ProcedureListRelationFilter
    dentistSpecialties?: DentistSpecialtyListRelationFilter
  }, "id" | "name">

  export type SpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialtyCountOrderByAggregateInput
    _max?: SpecialtyMaxOrderByAggregateInput
    _min?: SpecialtyMinOrderByAggregateInput
  }

  export type SpecialtyScalarWhereWithAggregatesInput = {
    AND?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    OR?: SpecialtyScalarWhereWithAggregatesInput[]
    NOT?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Specialty"> | string
    name?: StringWithAggregatesFilter<"Specialty"> | string
    description?: StringNullableWithAggregatesFilter<"Specialty"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
  }

  export type CIDWhereInput = {
    AND?: CIDWhereInput | CIDWhereInput[]
    OR?: CIDWhereInput[]
    NOT?: CIDWhereInput | CIDWhereInput[]
    id?: StringFilter<"CID"> | string
    code?: StringFilter<"CID"> | string
    category?: StringFilter<"CID"> | string
    description?: StringFilter<"CID"> | string
    createdAt?: DateTimeFilter<"CID"> | Date | string
    updatedAt?: DateTimeFilter<"CID"> | Date | string
  }

  export type CIDOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CIDWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CIDWhereInput | CIDWhereInput[]
    OR?: CIDWhereInput[]
    NOT?: CIDWhereInput | CIDWhereInput[]
    category?: StringFilter<"CID"> | string
    description?: StringFilter<"CID"> | string
    createdAt?: DateTimeFilter<"CID"> | Date | string
    updatedAt?: DateTimeFilter<"CID"> | Date | string
  }, "id" | "code">

  export type CIDOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CIDCountOrderByAggregateInput
    _max?: CIDMaxOrderByAggregateInput
    _min?: CIDMinOrderByAggregateInput
  }

  export type CIDScalarWhereWithAggregatesInput = {
    AND?: CIDScalarWhereWithAggregatesInput | CIDScalarWhereWithAggregatesInput[]
    OR?: CIDScalarWhereWithAggregatesInput[]
    NOT?: CIDScalarWhereWithAggregatesInput | CIDScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CID"> | string
    code?: StringWithAggregatesFilter<"CID"> | string
    category?: StringWithAggregatesFilter<"CID"> | string
    description?: StringWithAggregatesFilter<"CID"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CID"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CID"> | Date | string
  }

  export type ProcedureWhereInput = {
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    id?: StringFilter<"Procedure"> | string
    clinicId?: StringFilter<"Procedure"> | string
    specialtyId?: StringFilter<"Procedure"> | string
    name?: StringFilter<"Procedure"> | string
    description?: StringNullableFilter<"Procedure"> | string | null
    baseValue?: DecimalFilter<"Procedure"> | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFilter<"Procedure"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Procedure"> | boolean
    createdAt?: DateTimeFilter<"Procedure"> | Date | string
    updatedAt?: DateTimeFilter<"Procedure"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    specialty?: XOR<SpecialtyScalarRelationFilter, SpecialtyWhereInput>
    dentistProcedures?: DentistProcedureListRelationFilter
    appointments?: AppointmentListRelationFilter
    attendanceProcedures?: AttendanceProcedureListRelationFilter
    treatmentItems?: TreatmentItemListRelationFilter
  }

  export type ProcedureOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    specialtyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    baseValue?: SortOrder
    commissionPercentage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
    dentistProcedures?: DentistProcedureOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    attendanceProcedures?: AttendanceProcedureOrderByRelationAggregateInput
    treatmentItems?: TreatmentItemOrderByRelationAggregateInput
  }

  export type ProcedureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    clinicId?: StringFilter<"Procedure"> | string
    specialtyId?: StringFilter<"Procedure"> | string
    name?: StringFilter<"Procedure"> | string
    description?: StringNullableFilter<"Procedure"> | string | null
    baseValue?: DecimalFilter<"Procedure"> | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFilter<"Procedure"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Procedure"> | boolean
    createdAt?: DateTimeFilter<"Procedure"> | Date | string
    updatedAt?: DateTimeFilter<"Procedure"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    specialty?: XOR<SpecialtyScalarRelationFilter, SpecialtyWhereInput>
    dentistProcedures?: DentistProcedureListRelationFilter
    appointments?: AppointmentListRelationFilter
    attendanceProcedures?: AttendanceProcedureListRelationFilter
    treatmentItems?: TreatmentItemListRelationFilter
  }, "id">

  export type ProcedureOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    specialtyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    baseValue?: SortOrder
    commissionPercentage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcedureCountOrderByAggregateInput
    _avg?: ProcedureAvgOrderByAggregateInput
    _max?: ProcedureMaxOrderByAggregateInput
    _min?: ProcedureMinOrderByAggregateInput
    _sum?: ProcedureSumOrderByAggregateInput
  }

  export type ProcedureScalarWhereWithAggregatesInput = {
    AND?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    OR?: ProcedureScalarWhereWithAggregatesInput[]
    NOT?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Procedure"> | string
    clinicId?: StringWithAggregatesFilter<"Procedure"> | string
    specialtyId?: StringWithAggregatesFilter<"Procedure"> | string
    name?: StringWithAggregatesFilter<"Procedure"> | string
    description?: StringNullableWithAggregatesFilter<"Procedure"> | string | null
    baseValue?: DecimalWithAggregatesFilter<"Procedure"> | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalWithAggregatesFilter<"Procedure"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"Procedure"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Procedure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Procedure"> | Date | string
  }

  export type DentistProcedureWhereInput = {
    AND?: DentistProcedureWhereInput | DentistProcedureWhereInput[]
    OR?: DentistProcedureWhereInput[]
    NOT?: DentistProcedureWhereInput | DentistProcedureWhereInput[]
    id?: StringFilter<"DentistProcedure"> | string
    dentistId?: StringFilter<"DentistProcedure"> | string
    procedureId?: StringFilter<"DentistProcedure"> | string
    createdAt?: DateTimeFilter<"DentistProcedure"> | Date | string
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    procedure?: XOR<ProcedureScalarRelationFilter, ProcedureWhereInput>
  }

  export type DentistProcedureOrderByWithRelationInput = {
    id?: SortOrder
    dentistId?: SortOrder
    procedureId?: SortOrder
    createdAt?: SortOrder
    dentist?: DentistOrderByWithRelationInput
    procedure?: ProcedureOrderByWithRelationInput
  }

  export type DentistProcedureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dentistId_procedureId?: DentistProcedureDentistIdProcedureIdCompoundUniqueInput
    AND?: DentistProcedureWhereInput | DentistProcedureWhereInput[]
    OR?: DentistProcedureWhereInput[]
    NOT?: DentistProcedureWhereInput | DentistProcedureWhereInput[]
    dentistId?: StringFilter<"DentistProcedure"> | string
    procedureId?: StringFilter<"DentistProcedure"> | string
    createdAt?: DateTimeFilter<"DentistProcedure"> | Date | string
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    procedure?: XOR<ProcedureScalarRelationFilter, ProcedureWhereInput>
  }, "id" | "dentistId_procedureId">

  export type DentistProcedureOrderByWithAggregationInput = {
    id?: SortOrder
    dentistId?: SortOrder
    procedureId?: SortOrder
    createdAt?: SortOrder
    _count?: DentistProcedureCountOrderByAggregateInput
    _max?: DentistProcedureMaxOrderByAggregateInput
    _min?: DentistProcedureMinOrderByAggregateInput
  }

  export type DentistProcedureScalarWhereWithAggregatesInput = {
    AND?: DentistProcedureScalarWhereWithAggregatesInput | DentistProcedureScalarWhereWithAggregatesInput[]
    OR?: DentistProcedureScalarWhereWithAggregatesInput[]
    NOT?: DentistProcedureScalarWhereWithAggregatesInput | DentistProcedureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DentistProcedure"> | string
    dentistId?: StringWithAggregatesFilter<"DentistProcedure"> | string
    procedureId?: StringWithAggregatesFilter<"DentistProcedure"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DentistProcedure"> | Date | string
  }

  export type DentistSpecialtyWhereInput = {
    AND?: DentistSpecialtyWhereInput | DentistSpecialtyWhereInput[]
    OR?: DentistSpecialtyWhereInput[]
    NOT?: DentistSpecialtyWhereInput | DentistSpecialtyWhereInput[]
    id?: StringFilter<"DentistSpecialty"> | string
    dentistId?: StringFilter<"DentistSpecialty"> | string
    specialtyId?: StringFilter<"DentistSpecialty"> | string
    createdAt?: DateTimeFilter<"DentistSpecialty"> | Date | string
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    specialty?: XOR<SpecialtyScalarRelationFilter, SpecialtyWhereInput>
  }

  export type DentistSpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    dentistId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
    dentist?: DentistOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
  }

  export type DentistSpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dentistId_specialtyId?: DentistSpecialtyDentistIdSpecialtyIdCompoundUniqueInput
    AND?: DentistSpecialtyWhereInput | DentistSpecialtyWhereInput[]
    OR?: DentistSpecialtyWhereInput[]
    NOT?: DentistSpecialtyWhereInput | DentistSpecialtyWhereInput[]
    dentistId?: StringFilter<"DentistSpecialty"> | string
    specialtyId?: StringFilter<"DentistSpecialty"> | string
    createdAt?: DateTimeFilter<"DentistSpecialty"> | Date | string
    dentist?: XOR<DentistScalarRelationFilter, DentistWhereInput>
    specialty?: XOR<SpecialtyScalarRelationFilter, SpecialtyWhereInput>
  }, "id" | "dentistId_specialtyId">

  export type DentistSpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    dentistId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
    _count?: DentistSpecialtyCountOrderByAggregateInput
    _max?: DentistSpecialtyMaxOrderByAggregateInput
    _min?: DentistSpecialtyMinOrderByAggregateInput
  }

  export type DentistSpecialtyScalarWhereWithAggregatesInput = {
    AND?: DentistSpecialtyScalarWhereWithAggregatesInput | DentistSpecialtyScalarWhereWithAggregatesInput[]
    OR?: DentistSpecialtyScalarWhereWithAggregatesInput[]
    NOT?: DentistSpecialtyScalarWhereWithAggregatesInput | DentistSpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DentistSpecialty"> | string
    dentistId?: StringWithAggregatesFilter<"DentistSpecialty"> | string
    specialtyId?: StringWithAggregatesFilter<"DentistSpecialty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DentistSpecialty"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    clinicId?: StringFilter<"Attendance"> | string
    appointmentId?: StringNullableFilter<"Attendance"> | string | null
    patientId?: StringFilter<"Attendance"> | string
    dentistId?: StringNullableFilter<"Attendance"> | string | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFilter<"Attendance"> | Date | string
    startedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdByRole?: EnumUserRoleFilter<"Attendance"> | $Enums.UserRole
    createdById?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    dentist?: XOR<DentistNullableScalarRelationFilter, DentistWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    cids?: AttendanceCIDListRelationFilter
    procedures?: AttendanceProcedureListRelationFilter
    odontogram?: XOR<AttendanceOdontogramNullableScalarRelationFilter, AttendanceOdontogramWhereInput> | null
    documents?: ClinicalDocumentListRelationFilter
    record?: XOR<RecordNullableScalarRelationFilter, RecordWhereInput> | null
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    dentistId?: SortOrderInput | SortOrder
    status?: SortOrder
    arrivalAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdByRole?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    dentist?: DentistOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    cids?: AttendanceCIDOrderByRelationAggregateInput
    procedures?: AttendanceProcedureOrderByRelationAggregateInput
    odontogram?: AttendanceOdontogramOrderByWithRelationInput
    documents?: ClinicalDocumentOrderByRelationAggregateInput
    record?: RecordOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    clinicId?: StringFilter<"Attendance"> | string
    patientId?: StringFilter<"Attendance"> | string
    dentistId?: StringNullableFilter<"Attendance"> | string | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFilter<"Attendance"> | Date | string
    startedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdByRole?: EnumUserRoleFilter<"Attendance"> | $Enums.UserRole
    createdById?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    dentist?: XOR<DentistNullableScalarRelationFilter, DentistWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    cids?: AttendanceCIDListRelationFilter
    procedures?: AttendanceProcedureListRelationFilter
    odontogram?: XOR<AttendanceOdontogramNullableScalarRelationFilter, AttendanceOdontogramWhereInput> | null
    documents?: ClinicalDocumentListRelationFilter
    record?: XOR<RecordNullableScalarRelationFilter, RecordWhereInput> | null
  }, "id" | "appointmentId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    dentistId?: SortOrderInput | SortOrder
    status?: SortOrder
    arrivalAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdByRole?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    clinicId?: StringWithAggregatesFilter<"Attendance"> | string
    appointmentId?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    patientId?: StringWithAggregatesFilter<"Attendance"> | string
    dentistId?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    arrivalAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    createdByRole?: EnumUserRoleWithAggregatesFilter<"Attendance"> | $Enums.UserRole
    createdById?: StringWithAggregatesFilter<"Attendance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type AttendanceCIDWhereInput = {
    AND?: AttendanceCIDWhereInput | AttendanceCIDWhereInput[]
    OR?: AttendanceCIDWhereInput[]
    NOT?: AttendanceCIDWhereInput | AttendanceCIDWhereInput[]
    id?: StringFilter<"AttendanceCID"> | string
    attendanceId?: StringFilter<"AttendanceCID"> | string
    cidCode?: StringFilter<"AttendanceCID"> | string
    description?: StringFilter<"AttendanceCID"> | string
    observation?: StringNullableFilter<"AttendanceCID"> | string | null
    createdByDentistId?: StringFilter<"AttendanceCID"> | string
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>
    createdBy?: XOR<DentistScalarRelationFilter, DentistWhereInput>
  }

  export type AttendanceCIDOrderByWithRelationInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    cidCode?: SortOrder
    description?: SortOrder
    observation?: SortOrderInput | SortOrder
    createdByDentistId?: SortOrder
    attendance?: AttendanceOrderByWithRelationInput
    createdBy?: DentistOrderByWithRelationInput
  }

  export type AttendanceCIDWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceCIDWhereInput | AttendanceCIDWhereInput[]
    OR?: AttendanceCIDWhereInput[]
    NOT?: AttendanceCIDWhereInput | AttendanceCIDWhereInput[]
    attendanceId?: StringFilter<"AttendanceCID"> | string
    cidCode?: StringFilter<"AttendanceCID"> | string
    description?: StringFilter<"AttendanceCID"> | string
    observation?: StringNullableFilter<"AttendanceCID"> | string | null
    createdByDentistId?: StringFilter<"AttendanceCID"> | string
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>
    createdBy?: XOR<DentistScalarRelationFilter, DentistWhereInput>
  }, "id">

  export type AttendanceCIDOrderByWithAggregationInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    cidCode?: SortOrder
    description?: SortOrder
    observation?: SortOrderInput | SortOrder
    createdByDentistId?: SortOrder
    _count?: AttendanceCIDCountOrderByAggregateInput
    _max?: AttendanceCIDMaxOrderByAggregateInput
    _min?: AttendanceCIDMinOrderByAggregateInput
  }

  export type AttendanceCIDScalarWhereWithAggregatesInput = {
    AND?: AttendanceCIDScalarWhereWithAggregatesInput | AttendanceCIDScalarWhereWithAggregatesInput[]
    OR?: AttendanceCIDScalarWhereWithAggregatesInput[]
    NOT?: AttendanceCIDScalarWhereWithAggregatesInput | AttendanceCIDScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceCID"> | string
    attendanceId?: StringWithAggregatesFilter<"AttendanceCID"> | string
    cidCode?: StringWithAggregatesFilter<"AttendanceCID"> | string
    description?: StringWithAggregatesFilter<"AttendanceCID"> | string
    observation?: StringNullableWithAggregatesFilter<"AttendanceCID"> | string | null
    createdByDentistId?: StringWithAggregatesFilter<"AttendanceCID"> | string
  }

  export type AttendanceProcedureWhereInput = {
    AND?: AttendanceProcedureWhereInput | AttendanceProcedureWhereInput[]
    OR?: AttendanceProcedureWhereInput[]
    NOT?: AttendanceProcedureWhereInput | AttendanceProcedureWhereInput[]
    id?: StringFilter<"AttendanceProcedure"> | string
    attendanceId?: StringFilter<"AttendanceProcedure"> | string
    procedureId?: StringNullableFilter<"AttendanceProcedure"> | string | null
    procedureCode?: StringNullableFilter<"AttendanceProcedure"> | string | null
    description?: StringFilter<"AttendanceProcedure"> | string
    tooth?: StringNullableFilter<"AttendanceProcedure"> | string | null
    surface?: StringNullableFilter<"AttendanceProcedure"> | string | null
    faces?: StringNullableListFilter<"AttendanceProcedure">
    quantity?: IntFilter<"AttendanceProcedure"> | number
    clinicalStatus?: StringNullableFilter<"AttendanceProcedure"> | string | null
    price?: DecimalNullableFilter<"AttendanceProcedure"> | Decimal | DecimalJsLike | number | string | null
    dentistId?: StringNullableFilter<"AttendanceProcedure"> | string | null
    observations?: StringNullableFilter<"AttendanceProcedure"> | string | null
    createdAt?: DateTimeFilter<"AttendanceProcedure"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceProcedure"> | Date | string
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>
    procedure?: XOR<ProcedureNullableScalarRelationFilter, ProcedureWhereInput> | null
    dentist?: XOR<DentistNullableScalarRelationFilter, DentistWhereInput> | null
  }

  export type AttendanceProcedureOrderByWithRelationInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    procedureId?: SortOrderInput | SortOrder
    procedureCode?: SortOrderInput | SortOrder
    description?: SortOrder
    tooth?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    faces?: SortOrder
    quantity?: SortOrder
    clinicalStatus?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    dentistId?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attendance?: AttendanceOrderByWithRelationInput
    procedure?: ProcedureOrderByWithRelationInput
    dentist?: DentistOrderByWithRelationInput
  }

  export type AttendanceProcedureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceProcedureWhereInput | AttendanceProcedureWhereInput[]
    OR?: AttendanceProcedureWhereInput[]
    NOT?: AttendanceProcedureWhereInput | AttendanceProcedureWhereInput[]
    attendanceId?: StringFilter<"AttendanceProcedure"> | string
    procedureId?: StringNullableFilter<"AttendanceProcedure"> | string | null
    procedureCode?: StringNullableFilter<"AttendanceProcedure"> | string | null
    description?: StringFilter<"AttendanceProcedure"> | string
    tooth?: StringNullableFilter<"AttendanceProcedure"> | string | null
    surface?: StringNullableFilter<"AttendanceProcedure"> | string | null
    faces?: StringNullableListFilter<"AttendanceProcedure">
    quantity?: IntFilter<"AttendanceProcedure"> | number
    clinicalStatus?: StringNullableFilter<"AttendanceProcedure"> | string | null
    price?: DecimalNullableFilter<"AttendanceProcedure"> | Decimal | DecimalJsLike | number | string | null
    dentistId?: StringNullableFilter<"AttendanceProcedure"> | string | null
    observations?: StringNullableFilter<"AttendanceProcedure"> | string | null
    createdAt?: DateTimeFilter<"AttendanceProcedure"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceProcedure"> | Date | string
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>
    procedure?: XOR<ProcedureNullableScalarRelationFilter, ProcedureWhereInput> | null
    dentist?: XOR<DentistNullableScalarRelationFilter, DentistWhereInput> | null
  }, "id">

  export type AttendanceProcedureOrderByWithAggregationInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    procedureId?: SortOrderInput | SortOrder
    procedureCode?: SortOrderInput | SortOrder
    description?: SortOrder
    tooth?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    faces?: SortOrder
    quantity?: SortOrder
    clinicalStatus?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    dentistId?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceProcedureCountOrderByAggregateInput
    _avg?: AttendanceProcedureAvgOrderByAggregateInput
    _max?: AttendanceProcedureMaxOrderByAggregateInput
    _min?: AttendanceProcedureMinOrderByAggregateInput
    _sum?: AttendanceProcedureSumOrderByAggregateInput
  }

  export type AttendanceProcedureScalarWhereWithAggregatesInput = {
    AND?: AttendanceProcedureScalarWhereWithAggregatesInput | AttendanceProcedureScalarWhereWithAggregatesInput[]
    OR?: AttendanceProcedureScalarWhereWithAggregatesInput[]
    NOT?: AttendanceProcedureScalarWhereWithAggregatesInput | AttendanceProcedureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceProcedure"> | string
    attendanceId?: StringWithAggregatesFilter<"AttendanceProcedure"> | string
    procedureId?: StringNullableWithAggregatesFilter<"AttendanceProcedure"> | string | null
    procedureCode?: StringNullableWithAggregatesFilter<"AttendanceProcedure"> | string | null
    description?: StringWithAggregatesFilter<"AttendanceProcedure"> | string
    tooth?: StringNullableWithAggregatesFilter<"AttendanceProcedure"> | string | null
    surface?: StringNullableWithAggregatesFilter<"AttendanceProcedure"> | string | null
    faces?: StringNullableListFilter<"AttendanceProcedure">
    quantity?: IntWithAggregatesFilter<"AttendanceProcedure"> | number
    clinicalStatus?: StringNullableWithAggregatesFilter<"AttendanceProcedure"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"AttendanceProcedure"> | Decimal | DecimalJsLike | number | string | null
    dentistId?: StringNullableWithAggregatesFilter<"AttendanceProcedure"> | string | null
    observations?: StringNullableWithAggregatesFilter<"AttendanceProcedure"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceProcedure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceProcedure"> | Date | string
  }

  export type AttendanceOdontogramWhereInput = {
    AND?: AttendanceOdontogramWhereInput | AttendanceOdontogramWhereInput[]
    OR?: AttendanceOdontogramWhereInput[]
    NOT?: AttendanceOdontogramWhereInput | AttendanceOdontogramWhereInput[]
    attendanceId?: StringFilter<"AttendanceOdontogram"> | string
    data?: JsonFilter<"AttendanceOdontogram">
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>
  }

  export type AttendanceOdontogramOrderByWithRelationInput = {
    attendanceId?: SortOrder
    data?: SortOrder
    attendance?: AttendanceOrderByWithRelationInput
  }

  export type AttendanceOdontogramWhereUniqueInput = Prisma.AtLeast<{
    attendanceId?: string
    AND?: AttendanceOdontogramWhereInput | AttendanceOdontogramWhereInput[]
    OR?: AttendanceOdontogramWhereInput[]
    NOT?: AttendanceOdontogramWhereInput | AttendanceOdontogramWhereInput[]
    data?: JsonFilter<"AttendanceOdontogram">
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>
  }, "attendanceId">

  export type AttendanceOdontogramOrderByWithAggregationInput = {
    attendanceId?: SortOrder
    data?: SortOrder
    _count?: AttendanceOdontogramCountOrderByAggregateInput
    _max?: AttendanceOdontogramMaxOrderByAggregateInput
    _min?: AttendanceOdontogramMinOrderByAggregateInput
  }

  export type AttendanceOdontogramScalarWhereWithAggregatesInput = {
    AND?: AttendanceOdontogramScalarWhereWithAggregatesInput | AttendanceOdontogramScalarWhereWithAggregatesInput[]
    OR?: AttendanceOdontogramScalarWhereWithAggregatesInput[]
    NOT?: AttendanceOdontogramScalarWhereWithAggregatesInput | AttendanceOdontogramScalarWhereWithAggregatesInput[]
    attendanceId?: StringWithAggregatesFilter<"AttendanceOdontogram"> | string
    data?: JsonWithAggregatesFilter<"AttendanceOdontogram">
  }

  export type ClinicalDocumentWhereInput = {
    AND?: ClinicalDocumentWhereInput | ClinicalDocumentWhereInput[]
    OR?: ClinicalDocumentWhereInput[]
    NOT?: ClinicalDocumentWhereInput | ClinicalDocumentWhereInput[]
    id?: StringFilter<"ClinicalDocument"> | string
    attendanceId?: StringFilter<"ClinicalDocument"> | string
    type?: EnumClinicalDocumentTypeFilter<"ClinicalDocument"> | $Enums.ClinicalDocumentType
    payload?: JsonFilter<"ClinicalDocument">
    generatedBy?: StringFilter<"ClinicalDocument"> | string
    generatedAt?: DateTimeFilter<"ClinicalDocument"> | Date | string
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>
  }

  export type ClinicalDocumentOrderByWithRelationInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    attendance?: AttendanceOrderByWithRelationInput
  }

  export type ClinicalDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicalDocumentWhereInput | ClinicalDocumentWhereInput[]
    OR?: ClinicalDocumentWhereInput[]
    NOT?: ClinicalDocumentWhereInput | ClinicalDocumentWhereInput[]
    attendanceId?: StringFilter<"ClinicalDocument"> | string
    type?: EnumClinicalDocumentTypeFilter<"ClinicalDocument"> | $Enums.ClinicalDocumentType
    payload?: JsonFilter<"ClinicalDocument">
    generatedBy?: StringFilter<"ClinicalDocument"> | string
    generatedAt?: DateTimeFilter<"ClinicalDocument"> | Date | string
    attendance?: XOR<AttendanceScalarRelationFilter, AttendanceWhereInput>
  }, "id">

  export type ClinicalDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    _count?: ClinicalDocumentCountOrderByAggregateInput
    _max?: ClinicalDocumentMaxOrderByAggregateInput
    _min?: ClinicalDocumentMinOrderByAggregateInput
  }

  export type ClinicalDocumentScalarWhereWithAggregatesInput = {
    AND?: ClinicalDocumentScalarWhereWithAggregatesInput | ClinicalDocumentScalarWhereWithAggregatesInput[]
    OR?: ClinicalDocumentScalarWhereWithAggregatesInput[]
    NOT?: ClinicalDocumentScalarWhereWithAggregatesInput | ClinicalDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicalDocument"> | string
    attendanceId?: StringWithAggregatesFilter<"ClinicalDocument"> | string
    type?: EnumClinicalDocumentTypeWithAggregatesFilter<"ClinicalDocument"> | $Enums.ClinicalDocumentType
    payload?: JsonWithAggregatesFilter<"ClinicalDocument">
    generatedBy?: StringWithAggregatesFilter<"ClinicalDocument"> | string
    generatedAt?: DateTimeWithAggregatesFilter<"ClinicalDocument"> | Date | string
  }

  export type ClinicCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutUsersInput
    dentist?: DentistCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    clinicId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentist?: DentistUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutUsersNestedInput
    dentist?: DentistUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    clinicId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistCreateInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type DentistCreateManyInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DentistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    records?: RecordCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    attendances?: AttendanceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    clinicId: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    records?: RecordUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    records?: RecordUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    records?: RecordUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    clinicId: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAppointmentsInput
    dentist: DentistCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    procedureRelation?: ProcedureCreateNestedOneWithoutAppointmentsInput
    record?: RecordCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    clinicId: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    record?: RecordUncheckedCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAppointmentsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    procedureRelation?: ProcedureUpdateOneWithoutAppointmentsNestedInput
    record?: RecordUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record?: RecordUncheckedUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    clinicId: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordCreateInput = {
    id?: string
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutRecordsInput
    patient: PatientCreateNestedOneWithoutRecordsInput
    dentist: DentistCreateNestedOneWithoutRecordsInput
    appointment?: AppointmentCreateNestedOneWithoutRecordInput
    attendance?: AttendanceCreateNestedOneWithoutRecordInput
  }

  export type RecordUncheckedCreateInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId: string
    appointmentId?: string | null
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutRecordsNestedInput
    patient?: PatientUpdateOneRequiredWithoutRecordsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutRecordsNestedInput
    appointment?: AppointmentUpdateOneWithoutRecordNestedInput
    attendance?: AttendanceUpdateOneWithoutRecordNestedInput
  }

  export type RecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordCreateManyInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId: string
    appointmentId?: string | null
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentPlanCreateInput = {
    id?: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutTreatmentPlansInput
    patient: PatientCreateNestedOneWithoutTreatmentPlansInput
    dentist: DentistCreateNestedOneWithoutTreatmentPlansInput
    items?: TreatmentItemCreateNestedManyWithoutPlanInput
    paymentTreatmentPlans?: PaymentTreatmentPlanCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanUncheckedCreateInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TreatmentItemUncheckedCreateNestedManyWithoutPlanInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutTreatmentPlansNestedInput
    patient?: PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput
    dentist?: DentistUpdateOneRequiredWithoutTreatmentPlansNestedInput
    items?: TreatmentItemUpdateManyWithoutPlanNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TreatmentItemUncheckedUpdateManyWithoutPlanNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanCreateManyInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentItemCreateInput = {
    id?: string
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
    plan: TreatmentPlanCreateNestedOneWithoutItemsInput
    procedure?: ProcedureCreateNestedOneWithoutTreatmentItemsInput
  }

  export type TreatmentItemUncheckedCreateInput = {
    id?: string
    planId: string
    procedureId?: string | null
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TreatmentItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    plan?: TreatmentPlanUpdateOneRequiredWithoutItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutTreatmentItemsNestedInput
  }

  export type TreatmentItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TreatmentItemCreateManyInput = {
    id?: string
    planId: string
    procedureId?: string | null
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TreatmentItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TreatmentItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateInput = {
    id?: string
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPaymentsInput
    patient?: PatientCreateNestedOneWithoutPaymentsInput
    paymentTreatmentPlans?: PaymentTreatmentPlanCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    clinicId: string
    patientId?: string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPaymentsNestedInput
    patient?: PatientUpdateOneWithoutPaymentsNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    clinicId: string
    patientId?: string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTreatmentPlanCreateInput = {
    id?: string
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutPaymentTreatmentPlansInput
    treatmentPlan: TreatmentPlanCreateNestedOneWithoutPaymentTreatmentPlansInput
  }

  export type PaymentTreatmentPlanUncheckedCreateInput = {
    id?: string
    paymentId: string
    treatmentPlanId: string
    createdAt?: Date | string
  }

  export type PaymentTreatmentPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutPaymentTreatmentPlansNestedInput
    treatmentPlan?: TreatmentPlanUpdateOneRequiredWithoutPaymentTreatmentPlansNestedInput
  }

  export type PaymentTreatmentPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    treatmentPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTreatmentPlanCreateManyInput = {
    id?: string
    paymentId: string
    treatmentPlanId: string
    createdAt?: Date | string
  }

  export type PaymentTreatmentPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTreatmentPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    treatmentPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    clinicId: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    clinicId: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAuditLogsInput
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    clinicId: string
    userId: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    clinicId: string
    userId: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    unit: string
    currentQuantity?: number
    minQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutInventoryItemsInput
    movements?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    clinicId: string
    name: string
    description?: string | null
    unit: string
    currentQuantity?: number
    minQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutInventoryItemsNestedInput
    movements?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    clinicId: string
    name: string
    description?: string | null
    unit: string
    currentQuantity?: number
    minQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateInput = {
    id?: string
    type: $Enums.InventoryMovementType
    quantity: number
    notes?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutInventoryMovementsInput
    item: InventoryItemCreateNestedOneWithoutMovementsInput
    appointment?: AppointmentCreateNestedOneWithoutInventoryMovementsInput
    createdBy: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: string
    clinicId: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutInventoryMovementsNestedInput
    item?: InventoryItemUpdateOneRequiredWithoutMovementsNestedInput
    appointment?: AppointmentUpdateOneWithoutInventoryMovementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyInput = {
    id?: string
    clinicId: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutSpecialtyInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutSpecialtyInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutSpecialtyNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutSpecialtyNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIDCreateInput = {
    id?: string
    code: string
    category: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CIDUncheckedCreateInput = {
    id?: string
    code: string
    category: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CIDUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIDUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIDCreateManyInput = {
    id?: string
    code: string
    category: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CIDUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIDUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureCreateInput = {
    id?: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutProceduresInput
    specialty: SpecialtyCreateNestedOneWithoutProceduresInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateInput = {
    id?: string
    clinicId: string
    specialtyId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutProceduresNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutProceduresNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureCreateManyInput = {
    id?: string
    clinicId: string
    specialtyId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistProcedureCreateInput = {
    id?: string
    createdAt?: Date | string
    dentist: DentistCreateNestedOneWithoutDentistProceduresInput
    procedure: ProcedureCreateNestedOneWithoutDentistProceduresInput
  }

  export type DentistProcedureUncheckedCreateInput = {
    id?: string
    dentistId: string
    procedureId: string
    createdAt?: Date | string
  }

  export type DentistProcedureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUpdateOneRequiredWithoutDentistProceduresNestedInput
    procedure?: ProcedureUpdateOneRequiredWithoutDentistProceduresNestedInput
  }

  export type DentistProcedureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    procedureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistProcedureCreateManyInput = {
    id?: string
    dentistId: string
    procedureId: string
    createdAt?: Date | string
  }

  export type DentistProcedureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistProcedureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    procedureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistSpecialtyCreateInput = {
    id?: string
    createdAt?: Date | string
    dentist: DentistCreateNestedOneWithoutDentistSpecialtiesInput
    specialty: SpecialtyCreateNestedOneWithoutDentistSpecialtiesInput
  }

  export type DentistSpecialtyUncheckedCreateInput = {
    id?: string
    dentistId: string
    specialtyId: string
    createdAt?: Date | string
  }

  export type DentistSpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUpdateOneRequiredWithoutDentistSpecialtiesNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutDentistSpecialtiesNestedInput
  }

  export type DentistSpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistSpecialtyCreateManyInput = {
    id?: string
    dentistId: string
    specialtyId: string
    createdAt?: Date | string
  }

  export type DentistSpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistSpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceCreateManyInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCIDCreateInput = {
    id?: string
    cidCode: string
    description: string
    observation?: string | null
    attendance: AttendanceCreateNestedOneWithoutCidsInput
    createdBy: DentistCreateNestedOneWithoutAttendanceCidsInput
  }

  export type AttendanceCIDUncheckedCreateInput = {
    id?: string
    attendanceId: string
    cidCode: string
    description: string
    observation?: string | null
    createdByDentistId: string
  }

  export type AttendanceCIDUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateOneRequiredWithoutCidsNestedInput
    createdBy?: DentistUpdateOneRequiredWithoutAttendanceCidsNestedInput
  }

  export type AttendanceCIDUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    createdByDentistId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceCIDCreateManyInput = {
    id?: string
    attendanceId: string
    cidCode: string
    description: string
    observation?: string | null
    createdByDentistId: string
  }

  export type AttendanceCIDUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceCIDUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    createdByDentistId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceProcedureCreateInput = {
    id?: string
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance: AttendanceCreateNestedOneWithoutProceduresInput
    procedure?: ProcedureCreateNestedOneWithoutAttendanceProceduresInput
    dentist?: DentistCreateNestedOneWithoutAttendanceProceduresInput
  }

  export type AttendanceProcedureUncheckedCreateInput = {
    id?: string
    attendanceId: string
    procedureId?: string | null
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    dentistId?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceProcedureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateOneRequiredWithoutProceduresNestedInput
    procedure?: ProcedureUpdateOneWithoutAttendanceProceduresNestedInput
    dentist?: DentistUpdateOneWithoutAttendanceProceduresNestedInput
  }

  export type AttendanceProcedureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceProcedureCreateManyInput = {
    id?: string
    attendanceId: string
    procedureId?: string | null
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    dentistId?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceProcedureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceProcedureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceOdontogramCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    attendance: AttendanceCreateNestedOneWithoutOdontogramInput
  }

  export type AttendanceOdontogramUncheckedCreateInput = {
    attendanceId: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type AttendanceOdontogramUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    attendance?: AttendanceUpdateOneRequiredWithoutOdontogramNestedInput
  }

  export type AttendanceOdontogramUncheckedUpdateInput = {
    attendanceId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AttendanceOdontogramCreateManyInput = {
    attendanceId: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type AttendanceOdontogramUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AttendanceOdontogramUncheckedUpdateManyInput = {
    attendanceId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ClinicalDocumentCreateInput = {
    id?: string
    type: $Enums.ClinicalDocumentType
    payload: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
    attendance: AttendanceCreateNestedOneWithoutDocumentsInput
  }

  export type ClinicalDocumentUncheckedCreateInput = {
    id?: string
    attendanceId: string
    type: $Enums.ClinicalDocumentType
    payload: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type ClinicalDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumClinicalDocumentTypeFieldUpdateOperationsInput | $Enums.ClinicalDocumentType
    payload?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type ClinicalDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    type?: EnumClinicalDocumentTypeFieldUpdateOperationsInput | $Enums.ClinicalDocumentType
    payload?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalDocumentCreateManyInput = {
    id?: string
    attendanceId: string
    type: $Enums.ClinicalDocumentType
    payload: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type ClinicalDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumClinicalDocumentTypeFieldUpdateOperationsInput | $Enums.ClinicalDocumentType
    payload?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    type?: EnumClinicalDocumentTypeFieldUpdateOperationsInput | $Enums.ClinicalDocumentType
    payload?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type DentistListRelationFilter = {
    every?: DentistWhereInput
    some?: DentistWhereInput
    none?: DentistWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type RecordListRelationFilter = {
    every?: RecordWhereInput
    some?: RecordWhereInput
    none?: RecordWhereInput
  }

  export type TreatmentPlanListRelationFilter = {
    every?: TreatmentPlanWhereInput
    some?: TreatmentPlanWhereInput
    none?: TreatmentPlanWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type ProcedureListRelationFilter = {
    every?: ProcedureWhereInput
    some?: ProcedureWhereInput
    none?: ProcedureWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DentistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreatmentPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcedureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ClinicScalarRelationFilter = {
    is?: ClinicWhereInput
    isNot?: ClinicWhereInput
  }

  export type DentistNullableScalarRelationFilter = {
    is?: DentistWhereInput | null
    isNot?: DentistWhereInput | null
  }

  export type UserClinicIdEmailCompoundUniqueInput = {
    clinicId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DentistProcedureListRelationFilter = {
    every?: DentistProcedureWhereInput
    some?: DentistProcedureWhereInput
    none?: DentistProcedureWhereInput
  }

  export type DentistSpecialtyListRelationFilter = {
    every?: DentistSpecialtyWhereInput
    some?: DentistSpecialtyWhereInput
    none?: DentistSpecialtyWhereInput
  }

  export type AttendanceCIDListRelationFilter = {
    every?: AttendanceCIDWhereInput
    some?: AttendanceCIDWhereInput
    none?: AttendanceCIDWhereInput
  }

  export type AttendanceProcedureListRelationFilter = {
    every?: AttendanceProcedureWhereInput
    some?: AttendanceProcedureWhereInput
    none?: AttendanceProcedureWhereInput
  }

  export type DentistProcedureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DentistSpecialtyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceCIDOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceProcedureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DentistCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    cro?: SortOrder
    specialty?: SortOrder
    workingHours?: SortOrder
    bankInfo?: SortOrder
    contactInfo?: SortOrder
    personalInfo?: SortOrder
    commission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DentistAvgOrderByAggregateInput = {
    commission?: SortOrder
  }

  export type DentistMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    cro?: SortOrder
    specialty?: SortOrder
    commission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DentistMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    cro?: SortOrder
    specialty?: SortOrder
    commission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DentistSumOrderByAggregateInput = {
    commission?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type DentistScalarRelationFilter = {
    is?: DentistWhereInput
    isNot?: DentistWhereInput
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type ProcedureNullableScalarRelationFilter = {
    is?: ProcedureWhereInput | null
    isNot?: ProcedureWhereInput | null
  }

  export type RecordNullableScalarRelationFilter = {
    is?: RecordWhereInput | null
    isNot?: RecordWhereInput | null
  }

  export type AttendanceNullableScalarRelationFilter = {
    is?: AttendanceWhereInput | null
    isNot?: AttendanceWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    dentistId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrder
    procedure?: SortOrder
    procedureId?: SortOrder
    procedureSnapshot?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    dentistId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrder
    procedure?: SortOrder
    procedureId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    dentistId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrder
    procedure?: SortOrder
    procedureId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type RecordCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    appointmentId?: SortOrder
    attendanceId?: SortOrder
    description?: SortOrder
    procedures?: SortOrder
    odontogram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecordMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    appointmentId?: SortOrder
    attendanceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecordMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    appointmentId?: SortOrder
    attendanceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTreatmentPlanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TreatmentPlanStatus | EnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TreatmentPlanStatus[] | ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreatmentPlanStatus[] | ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTreatmentPlanStatusFilter<$PrismaModel> | $Enums.TreatmentPlanStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumDiscountTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountTypeNullableFilter<$PrismaModel> | $Enums.DiscountType | null
  }

  export type TreatmentItemListRelationFilter = {
    every?: TreatmentItemWhereInput
    some?: TreatmentItemWhereInput
    none?: TreatmentItemWhereInput
  }

  export type PaymentTreatmentPlanListRelationFilter = {
    every?: PaymentTreatmentPlanWhereInput
    some?: PaymentTreatmentPlanWhereInput
    none?: PaymentTreatmentPlanWhereInput
  }

  export type TreatmentItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentTreatmentPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreatmentPlanCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    finalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TreatmentPlanAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountValue?: SortOrder
    finalAmount?: SortOrder
  }

  export type TreatmentPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    finalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TreatmentPlanMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    finalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TreatmentPlanSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountValue?: SortOrder
    finalAmount?: SortOrder
  }

  export type EnumTreatmentPlanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TreatmentPlanStatus | EnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TreatmentPlanStatus[] | ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreatmentPlanStatus[] | ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTreatmentPlanStatusWithAggregatesFilter<$PrismaModel> | $Enums.TreatmentPlanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTreatmentPlanStatusFilter<$PrismaModel>
    _max?: NestedEnumTreatmentPlanStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumDiscountTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeNullableFilter<$PrismaModel>
  }

  export type TreatmentPlanScalarRelationFilter = {
    is?: TreatmentPlanWhereInput
    isNot?: TreatmentPlanWhereInput
  }

  export type TreatmentItemCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    procedureId?: SortOrder
    description?: SortOrder
    tooth?: SortOrder
    value?: SortOrder
    quantity?: SortOrder
  }

  export type TreatmentItemAvgOrderByAggregateInput = {
    value?: SortOrder
    quantity?: SortOrder
  }

  export type TreatmentItemMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    procedureId?: SortOrder
    description?: SortOrder
    tooth?: SortOrder
    value?: SortOrder
    quantity?: SortOrder
  }

  export type TreatmentItemMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    procedureId?: SortOrder
    description?: SortOrder
    tooth?: SortOrder
    value?: SortOrder
    quantity?: SortOrder
  }

  export type TreatmentItemSumOrderByAggregateInput = {
    value?: SortOrder
    quantity?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    originalAmount?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    originalAmount?: SortOrder
    discountValue?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    originalAmount?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    originalAmount?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    originalAmount?: SortOrder
    discountValue?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type PaymentTreatmentPlanPaymentIdTreatmentPlanIdCompoundUniqueInput = {
    paymentId: string
    treatmentPlanId: string
  }

  export type PaymentTreatmentPlanCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    treatmentPlanId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentTreatmentPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    treatmentPlanId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentTreatmentPlanMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    treatmentPlanId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumInventoryMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMovementType | EnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryMovementTypeFilter<$PrismaModel> | $Enums.InventoryMovementType
  }

  export type InventoryItemScalarRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    appointmentId?: SortOrder
    createdById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    appointmentId?: SortOrder
    createdById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    appointmentId?: SortOrder
    createdById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumInventoryMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMovementType | EnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.InventoryMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumInventoryMovementTypeFilter<$PrismaModel>
  }

  export type SpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CIDCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CIDMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CIDMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyScalarRelationFilter = {
    is?: SpecialtyWhereInput
    isNot?: SpecialtyWhereInput
  }

  export type ProcedureCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    specialtyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseValue?: SortOrder
    commissionPercentage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcedureAvgOrderByAggregateInput = {
    baseValue?: SortOrder
    commissionPercentage?: SortOrder
  }

  export type ProcedureMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    specialtyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseValue?: SortOrder
    commissionPercentage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcedureMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    specialtyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseValue?: SortOrder
    commissionPercentage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcedureSumOrderByAggregateInput = {
    baseValue?: SortOrder
    commissionPercentage?: SortOrder
  }

  export type ProcedureScalarRelationFilter = {
    is?: ProcedureWhereInput
    isNot?: ProcedureWhereInput
  }

  export type DentistProcedureDentistIdProcedureIdCompoundUniqueInput = {
    dentistId: string
    procedureId: string
  }

  export type DentistProcedureCountOrderByAggregateInput = {
    id?: SortOrder
    dentistId?: SortOrder
    procedureId?: SortOrder
    createdAt?: SortOrder
  }

  export type DentistProcedureMaxOrderByAggregateInput = {
    id?: SortOrder
    dentistId?: SortOrder
    procedureId?: SortOrder
    createdAt?: SortOrder
  }

  export type DentistProcedureMinOrderByAggregateInput = {
    id?: SortOrder
    dentistId?: SortOrder
    procedureId?: SortOrder
    createdAt?: SortOrder
  }

  export type DentistSpecialtyDentistIdSpecialtyIdCompoundUniqueInput = {
    dentistId: string
    specialtyId: string
  }

  export type DentistSpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    dentistId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
  }

  export type DentistSpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    dentistId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
  }

  export type DentistSpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    dentistId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceOdontogramNullableScalarRelationFilter = {
    is?: AttendanceOdontogramWhereInput | null
    isNot?: AttendanceOdontogramWhereInput | null
  }

  export type ClinicalDocumentListRelationFilter = {
    every?: ClinicalDocumentWhereInput
    some?: ClinicalDocumentWhereInput
    none?: ClinicalDocumentWhereInput
  }

  export type ClinicalDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    status?: SortOrder
    arrivalAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdByRole?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    status?: SortOrder
    arrivalAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdByRole?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    dentistId?: SortOrder
    status?: SortOrder
    arrivalAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdByRole?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type AttendanceScalarRelationFilter = {
    is?: AttendanceWhereInput
    isNot?: AttendanceWhereInput
  }

  export type AttendanceCIDCountOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    cidCode?: SortOrder
    description?: SortOrder
    observation?: SortOrder
    createdByDentistId?: SortOrder
  }

  export type AttendanceCIDMaxOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    cidCode?: SortOrder
    description?: SortOrder
    observation?: SortOrder
    createdByDentistId?: SortOrder
  }

  export type AttendanceCIDMinOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    cidCode?: SortOrder
    description?: SortOrder
    observation?: SortOrder
    createdByDentistId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AttendanceProcedureCountOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    procedureId?: SortOrder
    procedureCode?: SortOrder
    description?: SortOrder
    tooth?: SortOrder
    surface?: SortOrder
    faces?: SortOrder
    quantity?: SortOrder
    clinicalStatus?: SortOrder
    price?: SortOrder
    dentistId?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceProcedureAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type AttendanceProcedureMaxOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    procedureId?: SortOrder
    procedureCode?: SortOrder
    description?: SortOrder
    tooth?: SortOrder
    surface?: SortOrder
    quantity?: SortOrder
    clinicalStatus?: SortOrder
    price?: SortOrder
    dentistId?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceProcedureMinOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    procedureId?: SortOrder
    procedureCode?: SortOrder
    description?: SortOrder
    tooth?: SortOrder
    surface?: SortOrder
    quantity?: SortOrder
    clinicalStatus?: SortOrder
    price?: SortOrder
    dentistId?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceProcedureSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AttendanceOdontogramCountOrderByAggregateInput = {
    attendanceId?: SortOrder
    data?: SortOrder
  }

  export type AttendanceOdontogramMaxOrderByAggregateInput = {
    attendanceId?: SortOrder
  }

  export type AttendanceOdontogramMinOrderByAggregateInput = {
    attendanceId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumClinicalDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicalDocumentType | EnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicalDocumentType[] | ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicalDocumentType[] | ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicalDocumentTypeFilter<$PrismaModel> | $Enums.ClinicalDocumentType
  }

  export type ClinicalDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
  }

  export type ClinicalDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    type?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
  }

  export type ClinicalDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    type?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
  }

  export type EnumClinicalDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicalDocumentType | EnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicalDocumentType[] | ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicalDocumentType[] | ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicalDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClinicalDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClinicalDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumClinicalDocumentTypeFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutClinicInput = {
    create?: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput> | UserCreateWithoutClinicInput[] | UserUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClinicInput | UserCreateOrConnectWithoutClinicInput[]
    createMany?: UserCreateManyClinicInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DentistCreateNestedManyWithoutClinicInput = {
    create?: XOR<DentistCreateWithoutClinicInput, DentistUncheckedCreateWithoutClinicInput> | DentistCreateWithoutClinicInput[] | DentistUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DentistCreateOrConnectWithoutClinicInput | DentistCreateOrConnectWithoutClinicInput[]
    createMany?: DentistCreateManyClinicInputEnvelope
    connect?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutClinicInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutClinicInput = {
    create?: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput> | AppointmentCreateWithoutClinicInput[] | AppointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClinicInput | AppointmentCreateOrConnectWithoutClinicInput[]
    createMany?: AppointmentCreateManyClinicInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RecordCreateNestedManyWithoutClinicInput = {
    create?: XOR<RecordCreateWithoutClinicInput, RecordUncheckedCreateWithoutClinicInput> | RecordCreateWithoutClinicInput[] | RecordUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutClinicInput | RecordCreateOrConnectWithoutClinicInput[]
    createMany?: RecordCreateManyClinicInputEnvelope
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
  }

  export type TreatmentPlanCreateNestedManyWithoutClinicInput = {
    create?: XOR<TreatmentPlanCreateWithoutClinicInput, TreatmentPlanUncheckedCreateWithoutClinicInput> | TreatmentPlanCreateWithoutClinicInput[] | TreatmentPlanUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutClinicInput | TreatmentPlanCreateOrConnectWithoutClinicInput[]
    createMany?: TreatmentPlanCreateManyClinicInputEnvelope
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutClinicInput = {
    create?: XOR<PaymentCreateWithoutClinicInput, PaymentUncheckedCreateWithoutClinicInput> | PaymentCreateWithoutClinicInput[] | PaymentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutClinicInput | PaymentCreateOrConnectWithoutClinicInput[]
    createMany?: PaymentCreateManyClinicInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutClinicInput = {
    create?: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClinicInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutClinicInput = {
    create?: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput> | AuditLogCreateWithoutClinicInput[] | AuditLogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutClinicInput | AuditLogCreateOrConnectWithoutClinicInput[]
    createMany?: AuditLogCreateManyClinicInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutClinicInput = {
    create?: XOR<InventoryItemCreateWithoutClinicInput, InventoryItemUncheckedCreateWithoutClinicInput> | InventoryItemCreateWithoutClinicInput[] | InventoryItemUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutClinicInput | InventoryItemCreateOrConnectWithoutClinicInput[]
    createMany?: InventoryItemCreateManyClinicInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutClinicInput = {
    create?: XOR<InventoryMovementCreateWithoutClinicInput, InventoryMovementUncheckedCreateWithoutClinicInput> | InventoryMovementCreateWithoutClinicInput[] | InventoryMovementUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutClinicInput | InventoryMovementCreateOrConnectWithoutClinicInput[]
    createMany?: InventoryMovementCreateManyClinicInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type ProcedureCreateNestedManyWithoutClinicInput = {
    create?: XOR<ProcedureCreateWithoutClinicInput, ProcedureUncheckedCreateWithoutClinicInput> | ProcedureCreateWithoutClinicInput[] | ProcedureUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutClinicInput | ProcedureCreateOrConnectWithoutClinicInput[]
    createMany?: ProcedureCreateManyClinicInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutClinicInput = {
    create?: XOR<AttendanceCreateWithoutClinicInput, AttendanceUncheckedCreateWithoutClinicInput> | AttendanceCreateWithoutClinicInput[] | AttendanceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClinicInput | AttendanceCreateOrConnectWithoutClinicInput[]
    createMany?: AttendanceCreateManyClinicInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput> | UserCreateWithoutClinicInput[] | UserUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClinicInput | UserCreateOrConnectWithoutClinicInput[]
    createMany?: UserCreateManyClinicInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DentistUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<DentistCreateWithoutClinicInput, DentistUncheckedCreateWithoutClinicInput> | DentistCreateWithoutClinicInput[] | DentistUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DentistCreateOrConnectWithoutClinicInput | DentistCreateOrConnectWithoutClinicInput[]
    createMany?: DentistCreateManyClinicInputEnvelope
    connect?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput> | AppointmentCreateWithoutClinicInput[] | AppointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClinicInput | AppointmentCreateOrConnectWithoutClinicInput[]
    createMany?: AppointmentCreateManyClinicInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RecordUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<RecordCreateWithoutClinicInput, RecordUncheckedCreateWithoutClinicInput> | RecordCreateWithoutClinicInput[] | RecordUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutClinicInput | RecordCreateOrConnectWithoutClinicInput[]
    createMany?: RecordCreateManyClinicInputEnvelope
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
  }

  export type TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<TreatmentPlanCreateWithoutClinicInput, TreatmentPlanUncheckedCreateWithoutClinicInput> | TreatmentPlanCreateWithoutClinicInput[] | TreatmentPlanUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutClinicInput | TreatmentPlanCreateOrConnectWithoutClinicInput[]
    createMany?: TreatmentPlanCreateManyClinicInputEnvelope
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<PaymentCreateWithoutClinicInput, PaymentUncheckedCreateWithoutClinicInput> | PaymentCreateWithoutClinicInput[] | PaymentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutClinicInput | PaymentCreateOrConnectWithoutClinicInput[]
    createMany?: PaymentCreateManyClinicInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutClinicInput = {
    create?: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClinicInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput> | AuditLogCreateWithoutClinicInput[] | AuditLogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutClinicInput | AuditLogCreateOrConnectWithoutClinicInput[]
    createMany?: AuditLogCreateManyClinicInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<InventoryItemCreateWithoutClinicInput, InventoryItemUncheckedCreateWithoutClinicInput> | InventoryItemCreateWithoutClinicInput[] | InventoryItemUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutClinicInput | InventoryItemCreateOrConnectWithoutClinicInput[]
    createMany?: InventoryItemCreateManyClinicInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<InventoryMovementCreateWithoutClinicInput, InventoryMovementUncheckedCreateWithoutClinicInput> | InventoryMovementCreateWithoutClinicInput[] | InventoryMovementUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutClinicInput | InventoryMovementCreateOrConnectWithoutClinicInput[]
    createMany?: InventoryMovementCreateManyClinicInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type ProcedureUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<ProcedureCreateWithoutClinicInput, ProcedureUncheckedCreateWithoutClinicInput> | ProcedureCreateWithoutClinicInput[] | ProcedureUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutClinicInput | ProcedureCreateOrConnectWithoutClinicInput[]
    createMany?: ProcedureCreateManyClinicInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<AttendanceCreateWithoutClinicInput, AttendanceUncheckedCreateWithoutClinicInput> | AttendanceCreateWithoutClinicInput[] | AttendanceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClinicInput | AttendanceCreateOrConnectWithoutClinicInput[]
    createMany?: AttendanceCreateManyClinicInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutClinicNestedInput = {
    create?: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput> | UserCreateWithoutClinicInput[] | UserUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClinicInput | UserCreateOrConnectWithoutClinicInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClinicInput | UserUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: UserCreateManyClinicInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClinicInput | UserUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClinicInput | UserUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DentistUpdateManyWithoutClinicNestedInput = {
    create?: XOR<DentistCreateWithoutClinicInput, DentistUncheckedCreateWithoutClinicInput> | DentistCreateWithoutClinicInput[] | DentistUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DentistCreateOrConnectWithoutClinicInput | DentistCreateOrConnectWithoutClinicInput[]
    upsert?: DentistUpsertWithWhereUniqueWithoutClinicInput | DentistUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: DentistCreateManyClinicInputEnvelope
    set?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
    disconnect?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
    delete?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
    connect?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
    update?: DentistUpdateWithWhereUniqueWithoutClinicInput | DentistUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: DentistUpdateManyWithWhereWithoutClinicInput | DentistUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: DentistScalarWhereInput | DentistScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutClinicInput | PatientUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutClinicInput | PatientUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutClinicInput | PatientUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput> | AppointmentCreateWithoutClinicInput[] | AppointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClinicInput | AppointmentCreateOrConnectWithoutClinicInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClinicInput | AppointmentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AppointmentCreateManyClinicInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClinicInput | AppointmentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClinicInput | AppointmentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RecordUpdateManyWithoutClinicNestedInput = {
    create?: XOR<RecordCreateWithoutClinicInput, RecordUncheckedCreateWithoutClinicInput> | RecordCreateWithoutClinicInput[] | RecordUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutClinicInput | RecordCreateOrConnectWithoutClinicInput[]
    upsert?: RecordUpsertWithWhereUniqueWithoutClinicInput | RecordUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: RecordCreateManyClinicInputEnvelope
    set?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    disconnect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    delete?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    update?: RecordUpdateWithWhereUniqueWithoutClinicInput | RecordUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: RecordUpdateManyWithWhereWithoutClinicInput | RecordUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: RecordScalarWhereInput | RecordScalarWhereInput[]
  }

  export type TreatmentPlanUpdateManyWithoutClinicNestedInput = {
    create?: XOR<TreatmentPlanCreateWithoutClinicInput, TreatmentPlanUncheckedCreateWithoutClinicInput> | TreatmentPlanCreateWithoutClinicInput[] | TreatmentPlanUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutClinicInput | TreatmentPlanCreateOrConnectWithoutClinicInput[]
    upsert?: TreatmentPlanUpsertWithWhereUniqueWithoutClinicInput | TreatmentPlanUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: TreatmentPlanCreateManyClinicInputEnvelope
    set?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    disconnect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    delete?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    update?: TreatmentPlanUpdateWithWhereUniqueWithoutClinicInput | TreatmentPlanUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: TreatmentPlanUpdateManyWithWhereWithoutClinicInput | TreatmentPlanUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: TreatmentPlanScalarWhereInput | TreatmentPlanScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PaymentCreateWithoutClinicInput, PaymentUncheckedCreateWithoutClinicInput> | PaymentCreateWithoutClinicInput[] | PaymentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutClinicInput | PaymentCreateOrConnectWithoutClinicInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutClinicInput | PaymentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PaymentCreateManyClinicInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutClinicInput | PaymentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutClinicInput | PaymentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutClinicNestedInput = {
    create?: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClinicInput
    upsert?: SubscriptionUpsertWithoutClinicInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutClinicInput, SubscriptionUpdateWithoutClinicInput>, SubscriptionUncheckedUpdateWithoutClinicInput>
  }

  export type AuditLogUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput> | AuditLogCreateWithoutClinicInput[] | AuditLogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutClinicInput | AuditLogCreateOrConnectWithoutClinicInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutClinicInput | AuditLogUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AuditLogCreateManyClinicInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutClinicInput | AuditLogUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutClinicInput | AuditLogUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutClinicNestedInput = {
    create?: XOR<InventoryItemCreateWithoutClinicInput, InventoryItemUncheckedCreateWithoutClinicInput> | InventoryItemCreateWithoutClinicInput[] | InventoryItemUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutClinicInput | InventoryItemCreateOrConnectWithoutClinicInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutClinicInput | InventoryItemUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: InventoryItemCreateManyClinicInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutClinicInput | InventoryItemUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutClinicInput | InventoryItemUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutClinicNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutClinicInput, InventoryMovementUncheckedCreateWithoutClinicInput> | InventoryMovementCreateWithoutClinicInput[] | InventoryMovementUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutClinicInput | InventoryMovementCreateOrConnectWithoutClinicInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutClinicInput | InventoryMovementUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: InventoryMovementCreateManyClinicInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutClinicInput | InventoryMovementUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutClinicInput | InventoryMovementUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ProcedureUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ProcedureCreateWithoutClinicInput, ProcedureUncheckedCreateWithoutClinicInput> | ProcedureCreateWithoutClinicInput[] | ProcedureUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutClinicInput | ProcedureCreateOrConnectWithoutClinicInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutClinicInput | ProcedureUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ProcedureCreateManyClinicInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutClinicInput | ProcedureUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutClinicInput | ProcedureUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AttendanceCreateWithoutClinicInput, AttendanceUncheckedCreateWithoutClinicInput> | AttendanceCreateWithoutClinicInput[] | AttendanceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClinicInput | AttendanceCreateOrConnectWithoutClinicInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutClinicInput | AttendanceUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AttendanceCreateManyClinicInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutClinicInput | AttendanceUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutClinicInput | AttendanceUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput> | UserCreateWithoutClinicInput[] | UserUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClinicInput | UserCreateOrConnectWithoutClinicInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClinicInput | UserUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: UserCreateManyClinicInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClinicInput | UserUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClinicInput | UserUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DentistUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<DentistCreateWithoutClinicInput, DentistUncheckedCreateWithoutClinicInput> | DentistCreateWithoutClinicInput[] | DentistUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: DentistCreateOrConnectWithoutClinicInput | DentistCreateOrConnectWithoutClinicInput[]
    upsert?: DentistUpsertWithWhereUniqueWithoutClinicInput | DentistUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: DentistCreateManyClinicInputEnvelope
    set?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
    disconnect?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
    delete?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
    connect?: DentistWhereUniqueInput | DentistWhereUniqueInput[]
    update?: DentistUpdateWithWhereUniqueWithoutClinicInput | DentistUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: DentistUpdateManyWithWhereWithoutClinicInput | DentistUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: DentistScalarWhereInput | DentistScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutClinicInput | PatientUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutClinicInput | PatientUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutClinicInput | PatientUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput> | AppointmentCreateWithoutClinicInput[] | AppointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClinicInput | AppointmentCreateOrConnectWithoutClinicInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClinicInput | AppointmentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AppointmentCreateManyClinicInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClinicInput | AppointmentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClinicInput | AppointmentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RecordUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<RecordCreateWithoutClinicInput, RecordUncheckedCreateWithoutClinicInput> | RecordCreateWithoutClinicInput[] | RecordUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutClinicInput | RecordCreateOrConnectWithoutClinicInput[]
    upsert?: RecordUpsertWithWhereUniqueWithoutClinicInput | RecordUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: RecordCreateManyClinicInputEnvelope
    set?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    disconnect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    delete?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    update?: RecordUpdateWithWhereUniqueWithoutClinicInput | RecordUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: RecordUpdateManyWithWhereWithoutClinicInput | RecordUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: RecordScalarWhereInput | RecordScalarWhereInput[]
  }

  export type TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<TreatmentPlanCreateWithoutClinicInput, TreatmentPlanUncheckedCreateWithoutClinicInput> | TreatmentPlanCreateWithoutClinicInput[] | TreatmentPlanUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutClinicInput | TreatmentPlanCreateOrConnectWithoutClinicInput[]
    upsert?: TreatmentPlanUpsertWithWhereUniqueWithoutClinicInput | TreatmentPlanUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: TreatmentPlanCreateManyClinicInputEnvelope
    set?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    disconnect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    delete?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    update?: TreatmentPlanUpdateWithWhereUniqueWithoutClinicInput | TreatmentPlanUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: TreatmentPlanUpdateManyWithWhereWithoutClinicInput | TreatmentPlanUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: TreatmentPlanScalarWhereInput | TreatmentPlanScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PaymentCreateWithoutClinicInput, PaymentUncheckedCreateWithoutClinicInput> | PaymentCreateWithoutClinicInput[] | PaymentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutClinicInput | PaymentCreateOrConnectWithoutClinicInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutClinicInput | PaymentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PaymentCreateManyClinicInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutClinicInput | PaymentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutClinicInput | PaymentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutClinicNestedInput = {
    create?: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClinicInput
    upsert?: SubscriptionUpsertWithoutClinicInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutClinicInput, SubscriptionUpdateWithoutClinicInput>, SubscriptionUncheckedUpdateWithoutClinicInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput> | AuditLogCreateWithoutClinicInput[] | AuditLogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutClinicInput | AuditLogCreateOrConnectWithoutClinicInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutClinicInput | AuditLogUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AuditLogCreateManyClinicInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutClinicInput | AuditLogUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutClinicInput | AuditLogUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<InventoryItemCreateWithoutClinicInput, InventoryItemUncheckedCreateWithoutClinicInput> | InventoryItemCreateWithoutClinicInput[] | InventoryItemUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutClinicInput | InventoryItemCreateOrConnectWithoutClinicInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutClinicInput | InventoryItemUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: InventoryItemCreateManyClinicInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutClinicInput | InventoryItemUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutClinicInput | InventoryItemUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutClinicInput, InventoryMovementUncheckedCreateWithoutClinicInput> | InventoryMovementCreateWithoutClinicInput[] | InventoryMovementUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutClinicInput | InventoryMovementCreateOrConnectWithoutClinicInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutClinicInput | InventoryMovementUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: InventoryMovementCreateManyClinicInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutClinicInput | InventoryMovementUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutClinicInput | InventoryMovementUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ProcedureUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ProcedureCreateWithoutClinicInput, ProcedureUncheckedCreateWithoutClinicInput> | ProcedureCreateWithoutClinicInput[] | ProcedureUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutClinicInput | ProcedureCreateOrConnectWithoutClinicInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutClinicInput | ProcedureUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ProcedureCreateManyClinicInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutClinicInput | ProcedureUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutClinicInput | ProcedureUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<AttendanceCreateWithoutClinicInput, AttendanceUncheckedCreateWithoutClinicInput> | AttendanceCreateWithoutClinicInput[] | AttendanceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClinicInput | AttendanceCreateOrConnectWithoutClinicInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutClinicInput | AttendanceUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: AttendanceCreateManyClinicInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutClinicInput | AttendanceUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutClinicInput | AttendanceUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutUsersInput
    connect?: ClinicWhereUniqueInput
  }

  export type DentistCreateNestedOneWithoutUserInput = {
    create?: XOR<DentistCreateWithoutUserInput, DentistUncheckedCreateWithoutUserInput>
    connectOrCreate?: DentistCreateOrConnectWithoutUserInput
    connect?: DentistWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InventoryMovementCreateWithoutCreatedByInput, InventoryMovementUncheckedCreateWithoutCreatedByInput> | InventoryMovementCreateWithoutCreatedByInput[] | InventoryMovementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutCreatedByInput | InventoryMovementCreateOrConnectWithoutCreatedByInput[]
    createMany?: InventoryMovementCreateManyCreatedByInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AttendanceCreateWithoutCreatedByInput, AttendanceUncheckedCreateWithoutCreatedByInput> | AttendanceCreateWithoutCreatedByInput[] | AttendanceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCreatedByInput | AttendanceCreateOrConnectWithoutCreatedByInput[]
    createMany?: AttendanceCreateManyCreatedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type DentistUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DentistCreateWithoutUserInput, DentistUncheckedCreateWithoutUserInput>
    connectOrCreate?: DentistCreateOrConnectWithoutUserInput
    connect?: DentistWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InventoryMovementCreateWithoutCreatedByInput, InventoryMovementUncheckedCreateWithoutCreatedByInput> | InventoryMovementCreateWithoutCreatedByInput[] | InventoryMovementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutCreatedByInput | InventoryMovementCreateOrConnectWithoutCreatedByInput[]
    createMany?: InventoryMovementCreateManyCreatedByInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AttendanceCreateWithoutCreatedByInput, AttendanceUncheckedCreateWithoutCreatedByInput> | AttendanceCreateWithoutCreatedByInput[] | AttendanceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCreatedByInput | AttendanceCreateOrConnectWithoutCreatedByInput[]
    createMany?: AttendanceCreateManyCreatedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ClinicUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutUsersInput
    upsert?: ClinicUpsertWithoutUsersInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutUsersInput, ClinicUpdateWithoutUsersInput>, ClinicUncheckedUpdateWithoutUsersInput>
  }

  export type DentistUpdateOneWithoutUserNestedInput = {
    create?: XOR<DentistCreateWithoutUserInput, DentistUncheckedCreateWithoutUserInput>
    connectOrCreate?: DentistCreateOrConnectWithoutUserInput
    upsert?: DentistUpsertWithoutUserInput
    disconnect?: DentistWhereInput | boolean
    delete?: DentistWhereInput | boolean
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutUserInput, DentistUpdateWithoutUserInput>, DentistUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutCreatedByInput, InventoryMovementUncheckedCreateWithoutCreatedByInput> | InventoryMovementCreateWithoutCreatedByInput[] | InventoryMovementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutCreatedByInput | InventoryMovementCreateOrConnectWithoutCreatedByInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutCreatedByInput | InventoryMovementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InventoryMovementCreateManyCreatedByInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutCreatedByInput | InventoryMovementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutCreatedByInput | InventoryMovementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutCreatedByInput, AttendanceUncheckedCreateWithoutCreatedByInput> | AttendanceCreateWithoutCreatedByInput[] | AttendanceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCreatedByInput | AttendanceCreateOrConnectWithoutCreatedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutCreatedByInput | AttendanceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AttendanceCreateManyCreatedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutCreatedByInput | AttendanceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutCreatedByInput | AttendanceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type DentistUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DentistCreateWithoutUserInput, DentistUncheckedCreateWithoutUserInput>
    connectOrCreate?: DentistCreateOrConnectWithoutUserInput
    upsert?: DentistUpsertWithoutUserInput
    disconnect?: DentistWhereInput | boolean
    delete?: DentistWhereInput | boolean
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutUserInput, DentistUpdateWithoutUserInput>, DentistUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutCreatedByInput, InventoryMovementUncheckedCreateWithoutCreatedByInput> | InventoryMovementCreateWithoutCreatedByInput[] | InventoryMovementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutCreatedByInput | InventoryMovementCreateOrConnectWithoutCreatedByInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutCreatedByInput | InventoryMovementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InventoryMovementCreateManyCreatedByInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutCreatedByInput | InventoryMovementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutCreatedByInput | InventoryMovementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutCreatedByInput, AttendanceUncheckedCreateWithoutCreatedByInput> | AttendanceCreateWithoutCreatedByInput[] | AttendanceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCreatedByInput | AttendanceCreateOrConnectWithoutCreatedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutCreatedByInput | AttendanceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AttendanceCreateManyCreatedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutCreatedByInput | AttendanceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutCreatedByInput | AttendanceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutDentistsInput = {
    create?: XOR<ClinicCreateWithoutDentistsInput, ClinicUncheckedCreateWithoutDentistsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutDentistsInput
    connect?: ClinicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDentistInput = {
    create?: XOR<UserCreateWithoutDentistInput, UserUncheckedCreateWithoutDentistInput>
    connectOrCreate?: UserCreateOrConnectWithoutDentistInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutDentistInput = {
    create?: XOR<AppointmentCreateWithoutDentistInput, AppointmentUncheckedCreateWithoutDentistInput> | AppointmentCreateWithoutDentistInput[] | AppointmentUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDentistInput | AppointmentCreateOrConnectWithoutDentistInput[]
    createMany?: AppointmentCreateManyDentistInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RecordCreateNestedManyWithoutDentistInput = {
    create?: XOR<RecordCreateWithoutDentistInput, RecordUncheckedCreateWithoutDentistInput> | RecordCreateWithoutDentistInput[] | RecordUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutDentistInput | RecordCreateOrConnectWithoutDentistInput[]
    createMany?: RecordCreateManyDentistInputEnvelope
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
  }

  export type TreatmentPlanCreateNestedManyWithoutDentistInput = {
    create?: XOR<TreatmentPlanCreateWithoutDentistInput, TreatmentPlanUncheckedCreateWithoutDentistInput> | TreatmentPlanCreateWithoutDentistInput[] | TreatmentPlanUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutDentistInput | TreatmentPlanCreateOrConnectWithoutDentistInput[]
    createMany?: TreatmentPlanCreateManyDentistInputEnvelope
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
  }

  export type DentistProcedureCreateNestedManyWithoutDentistInput = {
    create?: XOR<DentistProcedureCreateWithoutDentistInput, DentistProcedureUncheckedCreateWithoutDentistInput> | DentistProcedureCreateWithoutDentistInput[] | DentistProcedureUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: DentistProcedureCreateOrConnectWithoutDentistInput | DentistProcedureCreateOrConnectWithoutDentistInput[]
    createMany?: DentistProcedureCreateManyDentistInputEnvelope
    connect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
  }

  export type DentistSpecialtyCreateNestedManyWithoutDentistInput = {
    create?: XOR<DentistSpecialtyCreateWithoutDentistInput, DentistSpecialtyUncheckedCreateWithoutDentistInput> | DentistSpecialtyCreateWithoutDentistInput[] | DentistSpecialtyUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: DentistSpecialtyCreateOrConnectWithoutDentistInput | DentistSpecialtyCreateOrConnectWithoutDentistInput[]
    createMany?: DentistSpecialtyCreateManyDentistInputEnvelope
    connect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutDentistInput = {
    create?: XOR<AttendanceCreateWithoutDentistInput, AttendanceUncheckedCreateWithoutDentistInput> | AttendanceCreateWithoutDentistInput[] | AttendanceUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutDentistInput | AttendanceCreateOrConnectWithoutDentistInput[]
    createMany?: AttendanceCreateManyDentistInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceCIDCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AttendanceCIDCreateWithoutCreatedByInput, AttendanceCIDUncheckedCreateWithoutCreatedByInput> | AttendanceCIDCreateWithoutCreatedByInput[] | AttendanceCIDUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AttendanceCIDCreateOrConnectWithoutCreatedByInput | AttendanceCIDCreateOrConnectWithoutCreatedByInput[]
    createMany?: AttendanceCIDCreateManyCreatedByInputEnvelope
    connect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
  }

  export type AttendanceProcedureCreateNestedManyWithoutDentistInput = {
    create?: XOR<AttendanceProcedureCreateWithoutDentistInput, AttendanceProcedureUncheckedCreateWithoutDentistInput> | AttendanceProcedureCreateWithoutDentistInput[] | AttendanceProcedureUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutDentistInput | AttendanceProcedureCreateOrConnectWithoutDentistInput[]
    createMany?: AttendanceProcedureCreateManyDentistInputEnvelope
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDentistInput = {
    create?: XOR<AppointmentCreateWithoutDentistInput, AppointmentUncheckedCreateWithoutDentistInput> | AppointmentCreateWithoutDentistInput[] | AppointmentUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDentistInput | AppointmentCreateOrConnectWithoutDentistInput[]
    createMany?: AppointmentCreateManyDentistInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RecordUncheckedCreateNestedManyWithoutDentistInput = {
    create?: XOR<RecordCreateWithoutDentistInput, RecordUncheckedCreateWithoutDentistInput> | RecordCreateWithoutDentistInput[] | RecordUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutDentistInput | RecordCreateOrConnectWithoutDentistInput[]
    createMany?: RecordCreateManyDentistInputEnvelope
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
  }

  export type TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput = {
    create?: XOR<TreatmentPlanCreateWithoutDentistInput, TreatmentPlanUncheckedCreateWithoutDentistInput> | TreatmentPlanCreateWithoutDentistInput[] | TreatmentPlanUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutDentistInput | TreatmentPlanCreateOrConnectWithoutDentistInput[]
    createMany?: TreatmentPlanCreateManyDentistInputEnvelope
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
  }

  export type DentistProcedureUncheckedCreateNestedManyWithoutDentistInput = {
    create?: XOR<DentistProcedureCreateWithoutDentistInput, DentistProcedureUncheckedCreateWithoutDentistInput> | DentistProcedureCreateWithoutDentistInput[] | DentistProcedureUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: DentistProcedureCreateOrConnectWithoutDentistInput | DentistProcedureCreateOrConnectWithoutDentistInput[]
    createMany?: DentistProcedureCreateManyDentistInputEnvelope
    connect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
  }

  export type DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput = {
    create?: XOR<DentistSpecialtyCreateWithoutDentistInput, DentistSpecialtyUncheckedCreateWithoutDentistInput> | DentistSpecialtyCreateWithoutDentistInput[] | DentistSpecialtyUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: DentistSpecialtyCreateOrConnectWithoutDentistInput | DentistSpecialtyCreateOrConnectWithoutDentistInput[]
    createMany?: DentistSpecialtyCreateManyDentistInputEnvelope
    connect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutDentistInput = {
    create?: XOR<AttendanceCreateWithoutDentistInput, AttendanceUncheckedCreateWithoutDentistInput> | AttendanceCreateWithoutDentistInput[] | AttendanceUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutDentistInput | AttendanceCreateOrConnectWithoutDentistInput[]
    createMany?: AttendanceCreateManyDentistInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AttendanceCIDCreateWithoutCreatedByInput, AttendanceCIDUncheckedCreateWithoutCreatedByInput> | AttendanceCIDCreateWithoutCreatedByInput[] | AttendanceCIDUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AttendanceCIDCreateOrConnectWithoutCreatedByInput | AttendanceCIDCreateOrConnectWithoutCreatedByInput[]
    createMany?: AttendanceCIDCreateManyCreatedByInputEnvelope
    connect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
  }

  export type AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput = {
    create?: XOR<AttendanceProcedureCreateWithoutDentistInput, AttendanceProcedureUncheckedCreateWithoutDentistInput> | AttendanceProcedureCreateWithoutDentistInput[] | AttendanceProcedureUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutDentistInput | AttendanceProcedureCreateOrConnectWithoutDentistInput[]
    createMany?: AttendanceProcedureCreateManyDentistInputEnvelope
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ClinicUpdateOneRequiredWithoutDentistsNestedInput = {
    create?: XOR<ClinicCreateWithoutDentistsInput, ClinicUncheckedCreateWithoutDentistsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutDentistsInput
    upsert?: ClinicUpsertWithoutDentistsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutDentistsInput, ClinicUpdateWithoutDentistsInput>, ClinicUncheckedUpdateWithoutDentistsInput>
  }

  export type UserUpdateOneRequiredWithoutDentistNestedInput = {
    create?: XOR<UserCreateWithoutDentistInput, UserUncheckedCreateWithoutDentistInput>
    connectOrCreate?: UserCreateOrConnectWithoutDentistInput
    upsert?: UserUpsertWithoutDentistInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDentistInput, UserUpdateWithoutDentistInput>, UserUncheckedUpdateWithoutDentistInput>
  }

  export type AppointmentUpdateManyWithoutDentistNestedInput = {
    create?: XOR<AppointmentCreateWithoutDentistInput, AppointmentUncheckedCreateWithoutDentistInput> | AppointmentCreateWithoutDentistInput[] | AppointmentUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDentistInput | AppointmentCreateOrConnectWithoutDentistInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDentistInput | AppointmentUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: AppointmentCreateManyDentistInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDentistInput | AppointmentUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDentistInput | AppointmentUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RecordUpdateManyWithoutDentistNestedInput = {
    create?: XOR<RecordCreateWithoutDentistInput, RecordUncheckedCreateWithoutDentistInput> | RecordCreateWithoutDentistInput[] | RecordUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutDentistInput | RecordCreateOrConnectWithoutDentistInput[]
    upsert?: RecordUpsertWithWhereUniqueWithoutDentistInput | RecordUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: RecordCreateManyDentistInputEnvelope
    set?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    disconnect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    delete?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    update?: RecordUpdateWithWhereUniqueWithoutDentistInput | RecordUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: RecordUpdateManyWithWhereWithoutDentistInput | RecordUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: RecordScalarWhereInput | RecordScalarWhereInput[]
  }

  export type TreatmentPlanUpdateManyWithoutDentistNestedInput = {
    create?: XOR<TreatmentPlanCreateWithoutDentistInput, TreatmentPlanUncheckedCreateWithoutDentistInput> | TreatmentPlanCreateWithoutDentistInput[] | TreatmentPlanUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutDentistInput | TreatmentPlanCreateOrConnectWithoutDentistInput[]
    upsert?: TreatmentPlanUpsertWithWhereUniqueWithoutDentistInput | TreatmentPlanUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: TreatmentPlanCreateManyDentistInputEnvelope
    set?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    disconnect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    delete?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    update?: TreatmentPlanUpdateWithWhereUniqueWithoutDentistInput | TreatmentPlanUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: TreatmentPlanUpdateManyWithWhereWithoutDentistInput | TreatmentPlanUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: TreatmentPlanScalarWhereInput | TreatmentPlanScalarWhereInput[]
  }

  export type DentistProcedureUpdateManyWithoutDentistNestedInput = {
    create?: XOR<DentistProcedureCreateWithoutDentistInput, DentistProcedureUncheckedCreateWithoutDentistInput> | DentistProcedureCreateWithoutDentistInput[] | DentistProcedureUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: DentistProcedureCreateOrConnectWithoutDentistInput | DentistProcedureCreateOrConnectWithoutDentistInput[]
    upsert?: DentistProcedureUpsertWithWhereUniqueWithoutDentistInput | DentistProcedureUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: DentistProcedureCreateManyDentistInputEnvelope
    set?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    disconnect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    delete?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    connect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    update?: DentistProcedureUpdateWithWhereUniqueWithoutDentistInput | DentistProcedureUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: DentistProcedureUpdateManyWithWhereWithoutDentistInput | DentistProcedureUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: DentistProcedureScalarWhereInput | DentistProcedureScalarWhereInput[]
  }

  export type DentistSpecialtyUpdateManyWithoutDentistNestedInput = {
    create?: XOR<DentistSpecialtyCreateWithoutDentistInput, DentistSpecialtyUncheckedCreateWithoutDentistInput> | DentistSpecialtyCreateWithoutDentistInput[] | DentistSpecialtyUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: DentistSpecialtyCreateOrConnectWithoutDentistInput | DentistSpecialtyCreateOrConnectWithoutDentistInput[]
    upsert?: DentistSpecialtyUpsertWithWhereUniqueWithoutDentistInput | DentistSpecialtyUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: DentistSpecialtyCreateManyDentistInputEnvelope
    set?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    disconnect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    delete?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    connect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    update?: DentistSpecialtyUpdateWithWhereUniqueWithoutDentistInput | DentistSpecialtyUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: DentistSpecialtyUpdateManyWithWhereWithoutDentistInput | DentistSpecialtyUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: DentistSpecialtyScalarWhereInput | DentistSpecialtyScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutDentistNestedInput = {
    create?: XOR<AttendanceCreateWithoutDentistInput, AttendanceUncheckedCreateWithoutDentistInput> | AttendanceCreateWithoutDentistInput[] | AttendanceUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutDentistInput | AttendanceCreateOrConnectWithoutDentistInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutDentistInput | AttendanceUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: AttendanceCreateManyDentistInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutDentistInput | AttendanceUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutDentistInput | AttendanceUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceCIDUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AttendanceCIDCreateWithoutCreatedByInput, AttendanceCIDUncheckedCreateWithoutCreatedByInput> | AttendanceCIDCreateWithoutCreatedByInput[] | AttendanceCIDUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AttendanceCIDCreateOrConnectWithoutCreatedByInput | AttendanceCIDCreateOrConnectWithoutCreatedByInput[]
    upsert?: AttendanceCIDUpsertWithWhereUniqueWithoutCreatedByInput | AttendanceCIDUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AttendanceCIDCreateManyCreatedByInputEnvelope
    set?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    disconnect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    delete?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    connect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    update?: AttendanceCIDUpdateWithWhereUniqueWithoutCreatedByInput | AttendanceCIDUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AttendanceCIDUpdateManyWithWhereWithoutCreatedByInput | AttendanceCIDUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AttendanceCIDScalarWhereInput | AttendanceCIDScalarWhereInput[]
  }

  export type AttendanceProcedureUpdateManyWithoutDentistNestedInput = {
    create?: XOR<AttendanceProcedureCreateWithoutDentistInput, AttendanceProcedureUncheckedCreateWithoutDentistInput> | AttendanceProcedureCreateWithoutDentistInput[] | AttendanceProcedureUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutDentistInput | AttendanceProcedureCreateOrConnectWithoutDentistInput[]
    upsert?: AttendanceProcedureUpsertWithWhereUniqueWithoutDentistInput | AttendanceProcedureUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: AttendanceProcedureCreateManyDentistInputEnvelope
    set?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    disconnect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    delete?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    update?: AttendanceProcedureUpdateWithWhereUniqueWithoutDentistInput | AttendanceProcedureUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: AttendanceProcedureUpdateManyWithWhereWithoutDentistInput | AttendanceProcedureUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: AttendanceProcedureScalarWhereInput | AttendanceProcedureScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDentistNestedInput = {
    create?: XOR<AppointmentCreateWithoutDentistInput, AppointmentUncheckedCreateWithoutDentistInput> | AppointmentCreateWithoutDentistInput[] | AppointmentUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDentistInput | AppointmentCreateOrConnectWithoutDentistInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDentistInput | AppointmentUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: AppointmentCreateManyDentistInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDentistInput | AppointmentUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDentistInput | AppointmentUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RecordUncheckedUpdateManyWithoutDentistNestedInput = {
    create?: XOR<RecordCreateWithoutDentistInput, RecordUncheckedCreateWithoutDentistInput> | RecordCreateWithoutDentistInput[] | RecordUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutDentistInput | RecordCreateOrConnectWithoutDentistInput[]
    upsert?: RecordUpsertWithWhereUniqueWithoutDentistInput | RecordUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: RecordCreateManyDentistInputEnvelope
    set?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    disconnect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    delete?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    update?: RecordUpdateWithWhereUniqueWithoutDentistInput | RecordUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: RecordUpdateManyWithWhereWithoutDentistInput | RecordUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: RecordScalarWhereInput | RecordScalarWhereInput[]
  }

  export type TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput = {
    create?: XOR<TreatmentPlanCreateWithoutDentistInput, TreatmentPlanUncheckedCreateWithoutDentistInput> | TreatmentPlanCreateWithoutDentistInput[] | TreatmentPlanUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutDentistInput | TreatmentPlanCreateOrConnectWithoutDentistInput[]
    upsert?: TreatmentPlanUpsertWithWhereUniqueWithoutDentistInput | TreatmentPlanUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: TreatmentPlanCreateManyDentistInputEnvelope
    set?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    disconnect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    delete?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    update?: TreatmentPlanUpdateWithWhereUniqueWithoutDentistInput | TreatmentPlanUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: TreatmentPlanUpdateManyWithWhereWithoutDentistInput | TreatmentPlanUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: TreatmentPlanScalarWhereInput | TreatmentPlanScalarWhereInput[]
  }

  export type DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput = {
    create?: XOR<DentistProcedureCreateWithoutDentistInput, DentistProcedureUncheckedCreateWithoutDentistInput> | DentistProcedureCreateWithoutDentistInput[] | DentistProcedureUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: DentistProcedureCreateOrConnectWithoutDentistInput | DentistProcedureCreateOrConnectWithoutDentistInput[]
    upsert?: DentistProcedureUpsertWithWhereUniqueWithoutDentistInput | DentistProcedureUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: DentistProcedureCreateManyDentistInputEnvelope
    set?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    disconnect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    delete?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    connect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    update?: DentistProcedureUpdateWithWhereUniqueWithoutDentistInput | DentistProcedureUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: DentistProcedureUpdateManyWithWhereWithoutDentistInput | DentistProcedureUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: DentistProcedureScalarWhereInput | DentistProcedureScalarWhereInput[]
  }

  export type DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput = {
    create?: XOR<DentistSpecialtyCreateWithoutDentistInput, DentistSpecialtyUncheckedCreateWithoutDentistInput> | DentistSpecialtyCreateWithoutDentistInput[] | DentistSpecialtyUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: DentistSpecialtyCreateOrConnectWithoutDentistInput | DentistSpecialtyCreateOrConnectWithoutDentistInput[]
    upsert?: DentistSpecialtyUpsertWithWhereUniqueWithoutDentistInput | DentistSpecialtyUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: DentistSpecialtyCreateManyDentistInputEnvelope
    set?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    disconnect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    delete?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    connect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    update?: DentistSpecialtyUpdateWithWhereUniqueWithoutDentistInput | DentistSpecialtyUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: DentistSpecialtyUpdateManyWithWhereWithoutDentistInput | DentistSpecialtyUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: DentistSpecialtyScalarWhereInput | DentistSpecialtyScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutDentistNestedInput = {
    create?: XOR<AttendanceCreateWithoutDentistInput, AttendanceUncheckedCreateWithoutDentistInput> | AttendanceCreateWithoutDentistInput[] | AttendanceUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutDentistInput | AttendanceCreateOrConnectWithoutDentistInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutDentistInput | AttendanceUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: AttendanceCreateManyDentistInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutDentistInput | AttendanceUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutDentistInput | AttendanceUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AttendanceCIDCreateWithoutCreatedByInput, AttendanceCIDUncheckedCreateWithoutCreatedByInput> | AttendanceCIDCreateWithoutCreatedByInput[] | AttendanceCIDUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AttendanceCIDCreateOrConnectWithoutCreatedByInput | AttendanceCIDCreateOrConnectWithoutCreatedByInput[]
    upsert?: AttendanceCIDUpsertWithWhereUniqueWithoutCreatedByInput | AttendanceCIDUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AttendanceCIDCreateManyCreatedByInputEnvelope
    set?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    disconnect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    delete?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    connect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    update?: AttendanceCIDUpdateWithWhereUniqueWithoutCreatedByInput | AttendanceCIDUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AttendanceCIDUpdateManyWithWhereWithoutCreatedByInput | AttendanceCIDUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AttendanceCIDScalarWhereInput | AttendanceCIDScalarWhereInput[]
  }

  export type AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput = {
    create?: XOR<AttendanceProcedureCreateWithoutDentistInput, AttendanceProcedureUncheckedCreateWithoutDentistInput> | AttendanceProcedureCreateWithoutDentistInput[] | AttendanceProcedureUncheckedCreateWithoutDentistInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutDentistInput | AttendanceProcedureCreateOrConnectWithoutDentistInput[]
    upsert?: AttendanceProcedureUpsertWithWhereUniqueWithoutDentistInput | AttendanceProcedureUpsertWithWhereUniqueWithoutDentistInput[]
    createMany?: AttendanceProcedureCreateManyDentistInputEnvelope
    set?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    disconnect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    delete?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    update?: AttendanceProcedureUpdateWithWhereUniqueWithoutDentistInput | AttendanceProcedureUpdateWithWhereUniqueWithoutDentistInput[]
    updateMany?: AttendanceProcedureUpdateManyWithWhereWithoutDentistInput | AttendanceProcedureUpdateManyWithWhereWithoutDentistInput[]
    deleteMany?: AttendanceProcedureScalarWhereInput | AttendanceProcedureScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutPatientsInput = {
    create?: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPatientsInput
    connect?: ClinicWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RecordCreateNestedManyWithoutPatientInput = {
    create?: XOR<RecordCreateWithoutPatientInput, RecordUncheckedCreateWithoutPatientInput> | RecordCreateWithoutPatientInput[] | RecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutPatientInput | RecordCreateOrConnectWithoutPatientInput[]
    createMany?: RecordCreateManyPatientInputEnvelope
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
  }

  export type TreatmentPlanCreateNestedManyWithoutPatientInput = {
    create?: XOR<TreatmentPlanCreateWithoutPatientInput, TreatmentPlanUncheckedCreateWithoutPatientInput> | TreatmentPlanCreateWithoutPatientInput[] | TreatmentPlanUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutPatientInput | TreatmentPlanCreateOrConnectWithoutPatientInput[]
    createMany?: TreatmentPlanCreateManyPatientInputEnvelope
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutPatientInput = {
    create?: XOR<AttendanceCreateWithoutPatientInput, AttendanceUncheckedCreateWithoutPatientInput> | AttendanceCreateWithoutPatientInput[] | AttendanceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutPatientInput | AttendanceCreateOrConnectWithoutPatientInput[]
    createMany?: AttendanceCreateManyPatientInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RecordUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RecordCreateWithoutPatientInput, RecordUncheckedCreateWithoutPatientInput> | RecordCreateWithoutPatientInput[] | RecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutPatientInput | RecordCreateOrConnectWithoutPatientInput[]
    createMany?: RecordCreateManyPatientInputEnvelope
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
  }

  export type TreatmentPlanUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TreatmentPlanCreateWithoutPatientInput, TreatmentPlanUncheckedCreateWithoutPatientInput> | TreatmentPlanCreateWithoutPatientInput[] | TreatmentPlanUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutPatientInput | TreatmentPlanCreateOrConnectWithoutPatientInput[]
    createMany?: TreatmentPlanCreateManyPatientInputEnvelope
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AttendanceCreateWithoutPatientInput, AttendanceUncheckedCreateWithoutPatientInput> | AttendanceCreateWithoutPatientInput[] | AttendanceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutPatientInput | AttendanceCreateOrConnectWithoutPatientInput[]
    createMany?: AttendanceCreateManyPatientInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClinicUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPatientsInput
    upsert?: ClinicUpsertWithoutPatientsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutPatientsInput, ClinicUpdateWithoutPatientsInput>, ClinicUncheckedUpdateWithoutPatientsInput>
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RecordUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RecordCreateWithoutPatientInput, RecordUncheckedCreateWithoutPatientInput> | RecordCreateWithoutPatientInput[] | RecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutPatientInput | RecordCreateOrConnectWithoutPatientInput[]
    upsert?: RecordUpsertWithWhereUniqueWithoutPatientInput | RecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RecordCreateManyPatientInputEnvelope
    set?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    disconnect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    delete?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    update?: RecordUpdateWithWhereUniqueWithoutPatientInput | RecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RecordUpdateManyWithWhereWithoutPatientInput | RecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RecordScalarWhereInput | RecordScalarWhereInput[]
  }

  export type TreatmentPlanUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TreatmentPlanCreateWithoutPatientInput, TreatmentPlanUncheckedCreateWithoutPatientInput> | TreatmentPlanCreateWithoutPatientInput[] | TreatmentPlanUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutPatientInput | TreatmentPlanCreateOrConnectWithoutPatientInput[]
    upsert?: TreatmentPlanUpsertWithWhereUniqueWithoutPatientInput | TreatmentPlanUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TreatmentPlanCreateManyPatientInputEnvelope
    set?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    disconnect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    delete?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    update?: TreatmentPlanUpdateWithWhereUniqueWithoutPatientInput | TreatmentPlanUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TreatmentPlanUpdateManyWithWhereWithoutPatientInput | TreatmentPlanUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TreatmentPlanScalarWhereInput | TreatmentPlanScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPatientInput | PaymentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPatientInput | PaymentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPatientInput | PaymentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AttendanceCreateWithoutPatientInput, AttendanceUncheckedCreateWithoutPatientInput> | AttendanceCreateWithoutPatientInput[] | AttendanceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutPatientInput | AttendanceCreateOrConnectWithoutPatientInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutPatientInput | AttendanceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AttendanceCreateManyPatientInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutPatientInput | AttendanceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutPatientInput | AttendanceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RecordUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RecordCreateWithoutPatientInput, RecordUncheckedCreateWithoutPatientInput> | RecordCreateWithoutPatientInput[] | RecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RecordCreateOrConnectWithoutPatientInput | RecordCreateOrConnectWithoutPatientInput[]
    upsert?: RecordUpsertWithWhereUniqueWithoutPatientInput | RecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RecordCreateManyPatientInputEnvelope
    set?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    disconnect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    delete?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    connect?: RecordWhereUniqueInput | RecordWhereUniqueInput[]
    update?: RecordUpdateWithWhereUniqueWithoutPatientInput | RecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RecordUpdateManyWithWhereWithoutPatientInput | RecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RecordScalarWhereInput | RecordScalarWhereInput[]
  }

  export type TreatmentPlanUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TreatmentPlanCreateWithoutPatientInput, TreatmentPlanUncheckedCreateWithoutPatientInput> | TreatmentPlanCreateWithoutPatientInput[] | TreatmentPlanUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutPatientInput | TreatmentPlanCreateOrConnectWithoutPatientInput[]
    upsert?: TreatmentPlanUpsertWithWhereUniqueWithoutPatientInput | TreatmentPlanUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TreatmentPlanCreateManyPatientInputEnvelope
    set?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    disconnect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    delete?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    connect?: TreatmentPlanWhereUniqueInput | TreatmentPlanWhereUniqueInput[]
    update?: TreatmentPlanUpdateWithWhereUniqueWithoutPatientInput | TreatmentPlanUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TreatmentPlanUpdateManyWithWhereWithoutPatientInput | TreatmentPlanUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TreatmentPlanScalarWhereInput | TreatmentPlanScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPatientInput | PaymentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPatientInput | PaymentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPatientInput | PaymentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AttendanceCreateWithoutPatientInput, AttendanceUncheckedCreateWithoutPatientInput> | AttendanceCreateWithoutPatientInput[] | AttendanceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutPatientInput | AttendanceCreateOrConnectWithoutPatientInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutPatientInput | AttendanceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AttendanceCreateManyPatientInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutPatientInput | AttendanceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutPatientInput | AttendanceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ClinicCreateWithoutAppointmentsInput, ClinicUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAppointmentsInput
    connect?: ClinicWhereUniqueInput
  }

  export type DentistCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DentistCreateWithoutAppointmentsInput, DentistUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DentistCreateOrConnectWithoutAppointmentsInput
    connect?: DentistWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type ProcedureCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ProcedureCreateWithoutAppointmentsInput, ProcedureUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutAppointmentsInput
    connect?: ProcedureWhereUniqueInput
  }

  export type RecordCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<RecordCreateWithoutAppointmentInput, RecordUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: RecordCreateOrConnectWithoutAppointmentInput
    connect?: RecordWhereUniqueInput
  }

  export type InventoryMovementCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<InventoryMovementCreateWithoutAppointmentInput, InventoryMovementUncheckedCreateWithoutAppointmentInput> | InventoryMovementCreateWithoutAppointmentInput[] | InventoryMovementUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutAppointmentInput | InventoryMovementCreateOrConnectWithoutAppointmentInput[]
    createMany?: InventoryMovementCreateManyAppointmentInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type AttendanceCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<AttendanceCreateWithoutAppointmentInput, AttendanceUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutAppointmentInput
    connect?: AttendanceWhereUniqueInput
  }

  export type RecordUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<RecordCreateWithoutAppointmentInput, RecordUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: RecordCreateOrConnectWithoutAppointmentInput
    connect?: RecordWhereUniqueInput
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<InventoryMovementCreateWithoutAppointmentInput, InventoryMovementUncheckedCreateWithoutAppointmentInput> | InventoryMovementCreateWithoutAppointmentInput[] | InventoryMovementUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutAppointmentInput | InventoryMovementCreateOrConnectWithoutAppointmentInput[]
    createMany?: InventoryMovementCreateManyAppointmentInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<AttendanceCreateWithoutAppointmentInput, AttendanceUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutAppointmentInput
    connect?: AttendanceWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type ClinicUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<ClinicCreateWithoutAppointmentsInput, ClinicUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAppointmentsInput
    upsert?: ClinicUpsertWithoutAppointmentsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutAppointmentsInput, ClinicUpdateWithoutAppointmentsInput>, ClinicUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DentistUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<DentistCreateWithoutAppointmentsInput, DentistUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DentistCreateOrConnectWithoutAppointmentsInput
    upsert?: DentistUpsertWithoutAppointmentsInput
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutAppointmentsInput, DentistUpdateWithoutAppointmentsInput>, DentistUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ProcedureUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<ProcedureCreateWithoutAppointmentsInput, ProcedureUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutAppointmentsInput
    upsert?: ProcedureUpsertWithoutAppointmentsInput
    disconnect?: ProcedureWhereInput | boolean
    delete?: ProcedureWhereInput | boolean
    connect?: ProcedureWhereUniqueInput
    update?: XOR<XOR<ProcedureUpdateToOneWithWhereWithoutAppointmentsInput, ProcedureUpdateWithoutAppointmentsInput>, ProcedureUncheckedUpdateWithoutAppointmentsInput>
  }

  export type RecordUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<RecordCreateWithoutAppointmentInput, RecordUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: RecordCreateOrConnectWithoutAppointmentInput
    upsert?: RecordUpsertWithoutAppointmentInput
    disconnect?: RecordWhereInput | boolean
    delete?: RecordWhereInput | boolean
    connect?: RecordWhereUniqueInput
    update?: XOR<XOR<RecordUpdateToOneWithWhereWithoutAppointmentInput, RecordUpdateWithoutAppointmentInput>, RecordUncheckedUpdateWithoutAppointmentInput>
  }

  export type InventoryMovementUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutAppointmentInput, InventoryMovementUncheckedCreateWithoutAppointmentInput> | InventoryMovementCreateWithoutAppointmentInput[] | InventoryMovementUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutAppointmentInput | InventoryMovementCreateOrConnectWithoutAppointmentInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutAppointmentInput | InventoryMovementUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: InventoryMovementCreateManyAppointmentInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutAppointmentInput | InventoryMovementUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutAppointmentInput | InventoryMovementUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type AttendanceUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<AttendanceCreateWithoutAppointmentInput, AttendanceUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutAppointmentInput
    upsert?: AttendanceUpsertWithoutAppointmentInput
    disconnect?: AttendanceWhereInput | boolean
    delete?: AttendanceWhereInput | boolean
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutAppointmentInput, AttendanceUpdateWithoutAppointmentInput>, AttendanceUncheckedUpdateWithoutAppointmentInput>
  }

  export type RecordUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<RecordCreateWithoutAppointmentInput, RecordUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: RecordCreateOrConnectWithoutAppointmentInput
    upsert?: RecordUpsertWithoutAppointmentInput
    disconnect?: RecordWhereInput | boolean
    delete?: RecordWhereInput | boolean
    connect?: RecordWhereUniqueInput
    update?: XOR<XOR<RecordUpdateToOneWithWhereWithoutAppointmentInput, RecordUpdateWithoutAppointmentInput>, RecordUncheckedUpdateWithoutAppointmentInput>
  }

  export type InventoryMovementUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutAppointmentInput, InventoryMovementUncheckedCreateWithoutAppointmentInput> | InventoryMovementCreateWithoutAppointmentInput[] | InventoryMovementUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutAppointmentInput | InventoryMovementCreateOrConnectWithoutAppointmentInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutAppointmentInput | InventoryMovementUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: InventoryMovementCreateManyAppointmentInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutAppointmentInput | InventoryMovementUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutAppointmentInput | InventoryMovementUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<AttendanceCreateWithoutAppointmentInput, AttendanceUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutAppointmentInput
    upsert?: AttendanceUpsertWithoutAppointmentInput
    disconnect?: AttendanceWhereInput | boolean
    delete?: AttendanceWhereInput | boolean
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutAppointmentInput, AttendanceUpdateWithoutAppointmentInput>, AttendanceUncheckedUpdateWithoutAppointmentInput>
  }

  export type ClinicCreateNestedOneWithoutRecordsInput = {
    create?: XOR<ClinicCreateWithoutRecordsInput, ClinicUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutRecordsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutRecordsInput = {
    create?: XOR<PatientCreateWithoutRecordsInput, PatientUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRecordsInput
    connect?: PatientWhereUniqueInput
  }

  export type DentistCreateNestedOneWithoutRecordsInput = {
    create?: XOR<DentistCreateWithoutRecordsInput, DentistUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: DentistCreateOrConnectWithoutRecordsInput
    connect?: DentistWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutRecordInput = {
    create?: XOR<AppointmentCreateWithoutRecordInput, AppointmentUncheckedCreateWithoutRecordInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutRecordInput
    connect?: AppointmentWhereUniqueInput
  }

  export type AttendanceCreateNestedOneWithoutRecordInput = {
    create?: XOR<AttendanceCreateWithoutRecordInput, AttendanceUncheckedCreateWithoutRecordInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutRecordInput
    connect?: AttendanceWhereUniqueInput
  }

  export type ClinicUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<ClinicCreateWithoutRecordsInput, ClinicUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutRecordsInput
    upsert?: ClinicUpsertWithoutRecordsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutRecordsInput, ClinicUpdateWithoutRecordsInput>, ClinicUncheckedUpdateWithoutRecordsInput>
  }

  export type PatientUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<PatientCreateWithoutRecordsInput, PatientUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRecordsInput
    upsert?: PatientUpsertWithoutRecordsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRecordsInput, PatientUpdateWithoutRecordsInput>, PatientUncheckedUpdateWithoutRecordsInput>
  }

  export type DentistUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<DentistCreateWithoutRecordsInput, DentistUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: DentistCreateOrConnectWithoutRecordsInput
    upsert?: DentistUpsertWithoutRecordsInput
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutRecordsInput, DentistUpdateWithoutRecordsInput>, DentistUncheckedUpdateWithoutRecordsInput>
  }

  export type AppointmentUpdateOneWithoutRecordNestedInput = {
    create?: XOR<AppointmentCreateWithoutRecordInput, AppointmentUncheckedCreateWithoutRecordInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutRecordInput
    upsert?: AppointmentUpsertWithoutRecordInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutRecordInput, AppointmentUpdateWithoutRecordInput>, AppointmentUncheckedUpdateWithoutRecordInput>
  }

  export type AttendanceUpdateOneWithoutRecordNestedInput = {
    create?: XOR<AttendanceCreateWithoutRecordInput, AttendanceUncheckedCreateWithoutRecordInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutRecordInput
    upsert?: AttendanceUpsertWithoutRecordInput
    disconnect?: AttendanceWhereInput | boolean
    delete?: AttendanceWhereInput | boolean
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutRecordInput, AttendanceUpdateWithoutRecordInput>, AttendanceUncheckedUpdateWithoutRecordInput>
  }

  export type ClinicCreateNestedOneWithoutTreatmentPlansInput = {
    create?: XOR<ClinicCreateWithoutTreatmentPlansInput, ClinicUncheckedCreateWithoutTreatmentPlansInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutTreatmentPlansInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutTreatmentPlansInput = {
    create?: XOR<PatientCreateWithoutTreatmentPlansInput, PatientUncheckedCreateWithoutTreatmentPlansInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTreatmentPlansInput
    connect?: PatientWhereUniqueInput
  }

  export type DentistCreateNestedOneWithoutTreatmentPlansInput = {
    create?: XOR<DentistCreateWithoutTreatmentPlansInput, DentistUncheckedCreateWithoutTreatmentPlansInput>
    connectOrCreate?: DentistCreateOrConnectWithoutTreatmentPlansInput
    connect?: DentistWhereUniqueInput
  }

  export type TreatmentItemCreateNestedManyWithoutPlanInput = {
    create?: XOR<TreatmentItemCreateWithoutPlanInput, TreatmentItemUncheckedCreateWithoutPlanInput> | TreatmentItemCreateWithoutPlanInput[] | TreatmentItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TreatmentItemCreateOrConnectWithoutPlanInput | TreatmentItemCreateOrConnectWithoutPlanInput[]
    createMany?: TreatmentItemCreateManyPlanInputEnvelope
    connect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
  }

  export type PaymentTreatmentPlanCreateNestedManyWithoutTreatmentPlanInput = {
    create?: XOR<PaymentTreatmentPlanCreateWithoutTreatmentPlanInput, PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput> | PaymentTreatmentPlanCreateWithoutTreatmentPlanInput[] | PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput[]
    connectOrCreate?: PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput | PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput[]
    createMany?: PaymentTreatmentPlanCreateManyTreatmentPlanInputEnvelope
    connect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
  }

  export type TreatmentItemUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<TreatmentItemCreateWithoutPlanInput, TreatmentItemUncheckedCreateWithoutPlanInput> | TreatmentItemCreateWithoutPlanInput[] | TreatmentItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TreatmentItemCreateOrConnectWithoutPlanInput | TreatmentItemCreateOrConnectWithoutPlanInput[]
    createMany?: TreatmentItemCreateManyPlanInputEnvelope
    connect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
  }

  export type PaymentTreatmentPlanUncheckedCreateNestedManyWithoutTreatmentPlanInput = {
    create?: XOR<PaymentTreatmentPlanCreateWithoutTreatmentPlanInput, PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput> | PaymentTreatmentPlanCreateWithoutTreatmentPlanInput[] | PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput[]
    connectOrCreate?: PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput | PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput[]
    createMany?: PaymentTreatmentPlanCreateManyTreatmentPlanInputEnvelope
    connect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
  }

  export type EnumTreatmentPlanStatusFieldUpdateOperationsInput = {
    set?: $Enums.TreatmentPlanStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType | null
  }

  export type ClinicUpdateOneRequiredWithoutTreatmentPlansNestedInput = {
    create?: XOR<ClinicCreateWithoutTreatmentPlansInput, ClinicUncheckedCreateWithoutTreatmentPlansInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutTreatmentPlansInput
    upsert?: ClinicUpsertWithoutTreatmentPlansInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutTreatmentPlansInput, ClinicUpdateWithoutTreatmentPlansInput>, ClinicUncheckedUpdateWithoutTreatmentPlansInput>
  }

  export type PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput = {
    create?: XOR<PatientCreateWithoutTreatmentPlansInput, PatientUncheckedCreateWithoutTreatmentPlansInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTreatmentPlansInput
    upsert?: PatientUpsertWithoutTreatmentPlansInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutTreatmentPlansInput, PatientUpdateWithoutTreatmentPlansInput>, PatientUncheckedUpdateWithoutTreatmentPlansInput>
  }

  export type DentistUpdateOneRequiredWithoutTreatmentPlansNestedInput = {
    create?: XOR<DentistCreateWithoutTreatmentPlansInput, DentistUncheckedCreateWithoutTreatmentPlansInput>
    connectOrCreate?: DentistCreateOrConnectWithoutTreatmentPlansInput
    upsert?: DentistUpsertWithoutTreatmentPlansInput
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutTreatmentPlansInput, DentistUpdateWithoutTreatmentPlansInput>, DentistUncheckedUpdateWithoutTreatmentPlansInput>
  }

  export type TreatmentItemUpdateManyWithoutPlanNestedInput = {
    create?: XOR<TreatmentItemCreateWithoutPlanInput, TreatmentItemUncheckedCreateWithoutPlanInput> | TreatmentItemCreateWithoutPlanInput[] | TreatmentItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TreatmentItemCreateOrConnectWithoutPlanInput | TreatmentItemCreateOrConnectWithoutPlanInput[]
    upsert?: TreatmentItemUpsertWithWhereUniqueWithoutPlanInput | TreatmentItemUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: TreatmentItemCreateManyPlanInputEnvelope
    set?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    disconnect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    delete?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    connect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    update?: TreatmentItemUpdateWithWhereUniqueWithoutPlanInput | TreatmentItemUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: TreatmentItemUpdateManyWithWhereWithoutPlanInput | TreatmentItemUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: TreatmentItemScalarWhereInput | TreatmentItemScalarWhereInput[]
  }

  export type PaymentTreatmentPlanUpdateManyWithoutTreatmentPlanNestedInput = {
    create?: XOR<PaymentTreatmentPlanCreateWithoutTreatmentPlanInput, PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput> | PaymentTreatmentPlanCreateWithoutTreatmentPlanInput[] | PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput[]
    connectOrCreate?: PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput | PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput[]
    upsert?: PaymentTreatmentPlanUpsertWithWhereUniqueWithoutTreatmentPlanInput | PaymentTreatmentPlanUpsertWithWhereUniqueWithoutTreatmentPlanInput[]
    createMany?: PaymentTreatmentPlanCreateManyTreatmentPlanInputEnvelope
    set?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    disconnect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    delete?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    connect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    update?: PaymentTreatmentPlanUpdateWithWhereUniqueWithoutTreatmentPlanInput | PaymentTreatmentPlanUpdateWithWhereUniqueWithoutTreatmentPlanInput[]
    updateMany?: PaymentTreatmentPlanUpdateManyWithWhereWithoutTreatmentPlanInput | PaymentTreatmentPlanUpdateManyWithWhereWithoutTreatmentPlanInput[]
    deleteMany?: PaymentTreatmentPlanScalarWhereInput | PaymentTreatmentPlanScalarWhereInput[]
  }

  export type TreatmentItemUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<TreatmentItemCreateWithoutPlanInput, TreatmentItemUncheckedCreateWithoutPlanInput> | TreatmentItemCreateWithoutPlanInput[] | TreatmentItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TreatmentItemCreateOrConnectWithoutPlanInput | TreatmentItemCreateOrConnectWithoutPlanInput[]
    upsert?: TreatmentItemUpsertWithWhereUniqueWithoutPlanInput | TreatmentItemUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: TreatmentItemCreateManyPlanInputEnvelope
    set?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    disconnect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    delete?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    connect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    update?: TreatmentItemUpdateWithWhereUniqueWithoutPlanInput | TreatmentItemUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: TreatmentItemUpdateManyWithWhereWithoutPlanInput | TreatmentItemUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: TreatmentItemScalarWhereInput | TreatmentItemScalarWhereInput[]
  }

  export type PaymentTreatmentPlanUncheckedUpdateManyWithoutTreatmentPlanNestedInput = {
    create?: XOR<PaymentTreatmentPlanCreateWithoutTreatmentPlanInput, PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput> | PaymentTreatmentPlanCreateWithoutTreatmentPlanInput[] | PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput[]
    connectOrCreate?: PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput | PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput[]
    upsert?: PaymentTreatmentPlanUpsertWithWhereUniqueWithoutTreatmentPlanInput | PaymentTreatmentPlanUpsertWithWhereUniqueWithoutTreatmentPlanInput[]
    createMany?: PaymentTreatmentPlanCreateManyTreatmentPlanInputEnvelope
    set?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    disconnect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    delete?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    connect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    update?: PaymentTreatmentPlanUpdateWithWhereUniqueWithoutTreatmentPlanInput | PaymentTreatmentPlanUpdateWithWhereUniqueWithoutTreatmentPlanInput[]
    updateMany?: PaymentTreatmentPlanUpdateManyWithWhereWithoutTreatmentPlanInput | PaymentTreatmentPlanUpdateManyWithWhereWithoutTreatmentPlanInput[]
    deleteMany?: PaymentTreatmentPlanScalarWhereInput | PaymentTreatmentPlanScalarWhereInput[]
  }

  export type TreatmentPlanCreateNestedOneWithoutItemsInput = {
    create?: XOR<TreatmentPlanCreateWithoutItemsInput, TreatmentPlanUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutItemsInput
    connect?: TreatmentPlanWhereUniqueInput
  }

  export type ProcedureCreateNestedOneWithoutTreatmentItemsInput = {
    create?: XOR<ProcedureCreateWithoutTreatmentItemsInput, ProcedureUncheckedCreateWithoutTreatmentItemsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutTreatmentItemsInput
    connect?: ProcedureWhereUniqueInput
  }

  export type TreatmentPlanUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TreatmentPlanCreateWithoutItemsInput, TreatmentPlanUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutItemsInput
    upsert?: TreatmentPlanUpsertWithoutItemsInput
    connect?: TreatmentPlanWhereUniqueInput
    update?: XOR<XOR<TreatmentPlanUpdateToOneWithWhereWithoutItemsInput, TreatmentPlanUpdateWithoutItemsInput>, TreatmentPlanUncheckedUpdateWithoutItemsInput>
  }

  export type ProcedureUpdateOneWithoutTreatmentItemsNestedInput = {
    create?: XOR<ProcedureCreateWithoutTreatmentItemsInput, ProcedureUncheckedCreateWithoutTreatmentItemsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutTreatmentItemsInput
    upsert?: ProcedureUpsertWithoutTreatmentItemsInput
    disconnect?: ProcedureWhereInput | boolean
    delete?: ProcedureWhereInput | boolean
    connect?: ProcedureWhereUniqueInput
    update?: XOR<XOR<ProcedureUpdateToOneWithWhereWithoutTreatmentItemsInput, ProcedureUpdateWithoutTreatmentItemsInput>, ProcedureUncheckedUpdateWithoutTreatmentItemsInput>
  }

  export type ClinicCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ClinicCreateWithoutPaymentsInput, ClinicUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPaymentsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPaymentsInput
    connect?: PatientWhereUniqueInput
  }

  export type PaymentTreatmentPlanCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentTreatmentPlanCreateWithoutPaymentInput, PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput> | PaymentTreatmentPlanCreateWithoutPaymentInput[] | PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput | PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentTreatmentPlanCreateManyPaymentInputEnvelope
    connect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
  }

  export type PaymentTreatmentPlanUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentTreatmentPlanCreateWithoutPaymentInput, PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput> | PaymentTreatmentPlanCreateWithoutPaymentInput[] | PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput | PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentTreatmentPlanCreateManyPaymentInputEnvelope
    connect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type ClinicUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ClinicCreateWithoutPaymentsInput, ClinicUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPaymentsInput
    upsert?: ClinicUpsertWithoutPaymentsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutPaymentsInput, ClinicUpdateWithoutPaymentsInput>, ClinicUncheckedUpdateWithoutPaymentsInput>
  }

  export type PatientUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPaymentsInput
    upsert?: PatientUpsertWithoutPaymentsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPaymentsInput, PatientUpdateWithoutPaymentsInput>, PatientUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentTreatmentPlanUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentTreatmentPlanCreateWithoutPaymentInput, PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput> | PaymentTreatmentPlanCreateWithoutPaymentInput[] | PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput | PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentTreatmentPlanUpsertWithWhereUniqueWithoutPaymentInput | PaymentTreatmentPlanUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentTreatmentPlanCreateManyPaymentInputEnvelope
    set?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    disconnect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    delete?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    connect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    update?: PaymentTreatmentPlanUpdateWithWhereUniqueWithoutPaymentInput | PaymentTreatmentPlanUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentTreatmentPlanUpdateManyWithWhereWithoutPaymentInput | PaymentTreatmentPlanUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentTreatmentPlanScalarWhereInput | PaymentTreatmentPlanScalarWhereInput[]
  }

  export type PaymentTreatmentPlanUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentTreatmentPlanCreateWithoutPaymentInput, PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput> | PaymentTreatmentPlanCreateWithoutPaymentInput[] | PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput | PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentTreatmentPlanUpsertWithWhereUniqueWithoutPaymentInput | PaymentTreatmentPlanUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentTreatmentPlanCreateManyPaymentInputEnvelope
    set?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    disconnect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    delete?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    connect?: PaymentTreatmentPlanWhereUniqueInput | PaymentTreatmentPlanWhereUniqueInput[]
    update?: PaymentTreatmentPlanUpdateWithWhereUniqueWithoutPaymentInput | PaymentTreatmentPlanUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentTreatmentPlanUpdateManyWithWhereWithoutPaymentInput | PaymentTreatmentPlanUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentTreatmentPlanScalarWhereInput | PaymentTreatmentPlanScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutPaymentTreatmentPlansInput = {
    create?: XOR<PaymentCreateWithoutPaymentTreatmentPlansInput, PaymentUncheckedCreateWithoutPaymentTreatmentPlansInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentTreatmentPlansInput
    connect?: PaymentWhereUniqueInput
  }

  export type TreatmentPlanCreateNestedOneWithoutPaymentTreatmentPlansInput = {
    create?: XOR<TreatmentPlanCreateWithoutPaymentTreatmentPlansInput, TreatmentPlanUncheckedCreateWithoutPaymentTreatmentPlansInput>
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutPaymentTreatmentPlansInput
    connect?: TreatmentPlanWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutPaymentTreatmentPlansNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentTreatmentPlansInput, PaymentUncheckedCreateWithoutPaymentTreatmentPlansInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentTreatmentPlansInput
    upsert?: PaymentUpsertWithoutPaymentTreatmentPlansInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutPaymentTreatmentPlansInput, PaymentUpdateWithoutPaymentTreatmentPlansInput>, PaymentUncheckedUpdateWithoutPaymentTreatmentPlansInput>
  }

  export type TreatmentPlanUpdateOneRequiredWithoutPaymentTreatmentPlansNestedInput = {
    create?: XOR<TreatmentPlanCreateWithoutPaymentTreatmentPlansInput, TreatmentPlanUncheckedCreateWithoutPaymentTreatmentPlansInput>
    connectOrCreate?: TreatmentPlanCreateOrConnectWithoutPaymentTreatmentPlansInput
    upsert?: TreatmentPlanUpsertWithoutPaymentTreatmentPlansInput
    connect?: TreatmentPlanWhereUniqueInput
    update?: XOR<XOR<TreatmentPlanUpdateToOneWithWhereWithoutPaymentTreatmentPlansInput, TreatmentPlanUpdateWithoutPaymentTreatmentPlansInput>, TreatmentPlanUncheckedUpdateWithoutPaymentTreatmentPlansInput>
  }

  export type ClinicCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<ClinicCreateWithoutSubscriptionInput, ClinicUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutSubscriptionInput
    connect?: ClinicWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type ClinicUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<ClinicCreateWithoutSubscriptionInput, ClinicUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutSubscriptionInput
    upsert?: ClinicUpsertWithoutSubscriptionInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutSubscriptionInput, ClinicUpdateWithoutSubscriptionInput>, ClinicUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ClinicCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ClinicCreateWithoutAuditLogsInput, ClinicUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAuditLogsInput
    connect?: ClinicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ClinicUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<ClinicCreateWithoutAuditLogsInput, ClinicUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAuditLogsInput
    upsert?: ClinicUpsertWithoutAuditLogsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutAuditLogsInput, ClinicUpdateWithoutAuditLogsInput>, ClinicUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ClinicCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ClinicCreateWithoutInventoryItemsInput, ClinicUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutInventoryItemsInput
    connect?: ClinicWhereUniqueInput
  }

  export type InventoryMovementCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClinicUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ClinicCreateWithoutInventoryItemsInput, ClinicUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutInventoryItemsInput
    upsert?: ClinicUpsertWithoutInventoryItemsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutInventoryItemsInput, ClinicUpdateWithoutInventoryItemsInput>, ClinicUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type InventoryMovementUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutItemInput | InventoryMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutItemInput | InventoryMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutItemInput | InventoryMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutItemInput | InventoryMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutItemInput | InventoryMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutItemInput | InventoryMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<ClinicCreateWithoutInventoryMovementsInput, ClinicUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutInventoryMovementsInput
    connect?: ClinicWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutMovementsInput = {
    create?: XOR<InventoryItemCreateWithoutMovementsInput, InventoryItemUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutMovementsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<AppointmentCreateWithoutInventoryMovementsInput, AppointmentUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutInventoryMovementsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInventoryMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.InventoryMovementType
  }

  export type ClinicUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<ClinicCreateWithoutInventoryMovementsInput, ClinicUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutInventoryMovementsInput
    upsert?: ClinicUpsertWithoutInventoryMovementsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutInventoryMovementsInput, ClinicUpdateWithoutInventoryMovementsInput>, ClinicUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type InventoryItemUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutMovementsInput, InventoryItemUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutMovementsInput
    upsert?: InventoryItemUpsertWithoutMovementsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutMovementsInput, InventoryItemUpdateWithoutMovementsInput>, InventoryItemUncheckedUpdateWithoutMovementsInput>
  }

  export type AppointmentUpdateOneWithoutInventoryMovementsNestedInput = {
    create?: XOR<AppointmentCreateWithoutInventoryMovementsInput, AppointmentUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutInventoryMovementsInput
    upsert?: AppointmentUpsertWithoutInventoryMovementsInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutInventoryMovementsInput, AppointmentUpdateWithoutInventoryMovementsInput>, AppointmentUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    upsert?: UserUpsertWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryMovementsInput, UserUpdateWithoutInventoryMovementsInput>, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type ProcedureCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<ProcedureCreateWithoutSpecialtyInput, ProcedureUncheckedCreateWithoutSpecialtyInput> | ProcedureCreateWithoutSpecialtyInput[] | ProcedureUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutSpecialtyInput | ProcedureCreateOrConnectWithoutSpecialtyInput[]
    createMany?: ProcedureCreateManySpecialtyInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type DentistSpecialtyCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<DentistSpecialtyCreateWithoutSpecialtyInput, DentistSpecialtyUncheckedCreateWithoutSpecialtyInput> | DentistSpecialtyCreateWithoutSpecialtyInput[] | DentistSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: DentistSpecialtyCreateOrConnectWithoutSpecialtyInput | DentistSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    createMany?: DentistSpecialtyCreateManySpecialtyInputEnvelope
    connect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
  }

  export type ProcedureUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<ProcedureCreateWithoutSpecialtyInput, ProcedureUncheckedCreateWithoutSpecialtyInput> | ProcedureCreateWithoutSpecialtyInput[] | ProcedureUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutSpecialtyInput | ProcedureCreateOrConnectWithoutSpecialtyInput[]
    createMany?: ProcedureCreateManySpecialtyInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type DentistSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<DentistSpecialtyCreateWithoutSpecialtyInput, DentistSpecialtyUncheckedCreateWithoutSpecialtyInput> | DentistSpecialtyCreateWithoutSpecialtyInput[] | DentistSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: DentistSpecialtyCreateOrConnectWithoutSpecialtyInput | DentistSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    createMany?: DentistSpecialtyCreateManySpecialtyInputEnvelope
    connect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
  }

  export type ProcedureUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<ProcedureCreateWithoutSpecialtyInput, ProcedureUncheckedCreateWithoutSpecialtyInput> | ProcedureCreateWithoutSpecialtyInput[] | ProcedureUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutSpecialtyInput | ProcedureCreateOrConnectWithoutSpecialtyInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutSpecialtyInput | ProcedureUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: ProcedureCreateManySpecialtyInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutSpecialtyInput | ProcedureUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutSpecialtyInput | ProcedureUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type DentistSpecialtyUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<DentistSpecialtyCreateWithoutSpecialtyInput, DentistSpecialtyUncheckedCreateWithoutSpecialtyInput> | DentistSpecialtyCreateWithoutSpecialtyInput[] | DentistSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: DentistSpecialtyCreateOrConnectWithoutSpecialtyInput | DentistSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    upsert?: DentistSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput | DentistSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: DentistSpecialtyCreateManySpecialtyInputEnvelope
    set?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    disconnect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    delete?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    connect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    update?: DentistSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput | DentistSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: DentistSpecialtyUpdateManyWithWhereWithoutSpecialtyInput | DentistSpecialtyUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: DentistSpecialtyScalarWhereInput | DentistSpecialtyScalarWhereInput[]
  }

  export type ProcedureUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<ProcedureCreateWithoutSpecialtyInput, ProcedureUncheckedCreateWithoutSpecialtyInput> | ProcedureCreateWithoutSpecialtyInput[] | ProcedureUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutSpecialtyInput | ProcedureCreateOrConnectWithoutSpecialtyInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutSpecialtyInput | ProcedureUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: ProcedureCreateManySpecialtyInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutSpecialtyInput | ProcedureUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutSpecialtyInput | ProcedureUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type DentistSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<DentistSpecialtyCreateWithoutSpecialtyInput, DentistSpecialtyUncheckedCreateWithoutSpecialtyInput> | DentistSpecialtyCreateWithoutSpecialtyInput[] | DentistSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: DentistSpecialtyCreateOrConnectWithoutSpecialtyInput | DentistSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    upsert?: DentistSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput | DentistSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: DentistSpecialtyCreateManySpecialtyInputEnvelope
    set?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    disconnect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    delete?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    connect?: DentistSpecialtyWhereUniqueInput | DentistSpecialtyWhereUniqueInput[]
    update?: DentistSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput | DentistSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: DentistSpecialtyUpdateManyWithWhereWithoutSpecialtyInput | DentistSpecialtyUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: DentistSpecialtyScalarWhereInput | DentistSpecialtyScalarWhereInput[]
  }

  export type ClinicCreateNestedOneWithoutProceduresInput = {
    create?: XOR<ClinicCreateWithoutProceduresInput, ClinicUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutProceduresInput
    connect?: ClinicWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutProceduresInput = {
    create?: XOR<SpecialtyCreateWithoutProceduresInput, SpecialtyUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutProceduresInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type DentistProcedureCreateNestedManyWithoutProcedureInput = {
    create?: XOR<DentistProcedureCreateWithoutProcedureInput, DentistProcedureUncheckedCreateWithoutProcedureInput> | DentistProcedureCreateWithoutProcedureInput[] | DentistProcedureUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: DentistProcedureCreateOrConnectWithoutProcedureInput | DentistProcedureCreateOrConnectWithoutProcedureInput[]
    createMany?: DentistProcedureCreateManyProcedureInputEnvelope
    connect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutProcedureRelationInput = {
    create?: XOR<AppointmentCreateWithoutProcedureRelationInput, AppointmentUncheckedCreateWithoutProcedureRelationInput> | AppointmentCreateWithoutProcedureRelationInput[] | AppointmentUncheckedCreateWithoutProcedureRelationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProcedureRelationInput | AppointmentCreateOrConnectWithoutProcedureRelationInput[]
    createMany?: AppointmentCreateManyProcedureRelationInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AttendanceProcedureCreateNestedManyWithoutProcedureInput = {
    create?: XOR<AttendanceProcedureCreateWithoutProcedureInput, AttendanceProcedureUncheckedCreateWithoutProcedureInput> | AttendanceProcedureCreateWithoutProcedureInput[] | AttendanceProcedureUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutProcedureInput | AttendanceProcedureCreateOrConnectWithoutProcedureInput[]
    createMany?: AttendanceProcedureCreateManyProcedureInputEnvelope
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
  }

  export type TreatmentItemCreateNestedManyWithoutProcedureInput = {
    create?: XOR<TreatmentItemCreateWithoutProcedureInput, TreatmentItemUncheckedCreateWithoutProcedureInput> | TreatmentItemCreateWithoutProcedureInput[] | TreatmentItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: TreatmentItemCreateOrConnectWithoutProcedureInput | TreatmentItemCreateOrConnectWithoutProcedureInput[]
    createMany?: TreatmentItemCreateManyProcedureInputEnvelope
    connect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
  }

  export type DentistProcedureUncheckedCreateNestedManyWithoutProcedureInput = {
    create?: XOR<DentistProcedureCreateWithoutProcedureInput, DentistProcedureUncheckedCreateWithoutProcedureInput> | DentistProcedureCreateWithoutProcedureInput[] | DentistProcedureUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: DentistProcedureCreateOrConnectWithoutProcedureInput | DentistProcedureCreateOrConnectWithoutProcedureInput[]
    createMany?: DentistProcedureCreateManyProcedureInputEnvelope
    connect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutProcedureRelationInput = {
    create?: XOR<AppointmentCreateWithoutProcedureRelationInput, AppointmentUncheckedCreateWithoutProcedureRelationInput> | AppointmentCreateWithoutProcedureRelationInput[] | AppointmentUncheckedCreateWithoutProcedureRelationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProcedureRelationInput | AppointmentCreateOrConnectWithoutProcedureRelationInput[]
    createMany?: AppointmentCreateManyProcedureRelationInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AttendanceProcedureUncheckedCreateNestedManyWithoutProcedureInput = {
    create?: XOR<AttendanceProcedureCreateWithoutProcedureInput, AttendanceProcedureUncheckedCreateWithoutProcedureInput> | AttendanceProcedureCreateWithoutProcedureInput[] | AttendanceProcedureUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutProcedureInput | AttendanceProcedureCreateOrConnectWithoutProcedureInput[]
    createMany?: AttendanceProcedureCreateManyProcedureInputEnvelope
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
  }

  export type TreatmentItemUncheckedCreateNestedManyWithoutProcedureInput = {
    create?: XOR<TreatmentItemCreateWithoutProcedureInput, TreatmentItemUncheckedCreateWithoutProcedureInput> | TreatmentItemCreateWithoutProcedureInput[] | TreatmentItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: TreatmentItemCreateOrConnectWithoutProcedureInput | TreatmentItemCreateOrConnectWithoutProcedureInput[]
    createMany?: TreatmentItemCreateManyProcedureInputEnvelope
    connect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
  }

  export type ClinicUpdateOneRequiredWithoutProceduresNestedInput = {
    create?: XOR<ClinicCreateWithoutProceduresInput, ClinicUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutProceduresInput
    upsert?: ClinicUpsertWithoutProceduresInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutProceduresInput, ClinicUpdateWithoutProceduresInput>, ClinicUncheckedUpdateWithoutProceduresInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutProceduresNestedInput = {
    create?: XOR<SpecialtyCreateWithoutProceduresInput, SpecialtyUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutProceduresInput
    upsert?: SpecialtyUpsertWithoutProceduresInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<XOR<SpecialtyUpdateToOneWithWhereWithoutProceduresInput, SpecialtyUpdateWithoutProceduresInput>, SpecialtyUncheckedUpdateWithoutProceduresInput>
  }

  export type DentistProcedureUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<DentistProcedureCreateWithoutProcedureInput, DentistProcedureUncheckedCreateWithoutProcedureInput> | DentistProcedureCreateWithoutProcedureInput[] | DentistProcedureUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: DentistProcedureCreateOrConnectWithoutProcedureInput | DentistProcedureCreateOrConnectWithoutProcedureInput[]
    upsert?: DentistProcedureUpsertWithWhereUniqueWithoutProcedureInput | DentistProcedureUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: DentistProcedureCreateManyProcedureInputEnvelope
    set?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    disconnect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    delete?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    connect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    update?: DentistProcedureUpdateWithWhereUniqueWithoutProcedureInput | DentistProcedureUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: DentistProcedureUpdateManyWithWhereWithoutProcedureInput | DentistProcedureUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: DentistProcedureScalarWhereInput | DentistProcedureScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutProcedureRelationNestedInput = {
    create?: XOR<AppointmentCreateWithoutProcedureRelationInput, AppointmentUncheckedCreateWithoutProcedureRelationInput> | AppointmentCreateWithoutProcedureRelationInput[] | AppointmentUncheckedCreateWithoutProcedureRelationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProcedureRelationInput | AppointmentCreateOrConnectWithoutProcedureRelationInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProcedureRelationInput | AppointmentUpsertWithWhereUniqueWithoutProcedureRelationInput[]
    createMany?: AppointmentCreateManyProcedureRelationInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProcedureRelationInput | AppointmentUpdateWithWhereUniqueWithoutProcedureRelationInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProcedureRelationInput | AppointmentUpdateManyWithWhereWithoutProcedureRelationInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AttendanceProcedureUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<AttendanceProcedureCreateWithoutProcedureInput, AttendanceProcedureUncheckedCreateWithoutProcedureInput> | AttendanceProcedureCreateWithoutProcedureInput[] | AttendanceProcedureUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutProcedureInput | AttendanceProcedureCreateOrConnectWithoutProcedureInput[]
    upsert?: AttendanceProcedureUpsertWithWhereUniqueWithoutProcedureInput | AttendanceProcedureUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: AttendanceProcedureCreateManyProcedureInputEnvelope
    set?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    disconnect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    delete?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    update?: AttendanceProcedureUpdateWithWhereUniqueWithoutProcedureInput | AttendanceProcedureUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: AttendanceProcedureUpdateManyWithWhereWithoutProcedureInput | AttendanceProcedureUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: AttendanceProcedureScalarWhereInput | AttendanceProcedureScalarWhereInput[]
  }

  export type TreatmentItemUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<TreatmentItemCreateWithoutProcedureInput, TreatmentItemUncheckedCreateWithoutProcedureInput> | TreatmentItemCreateWithoutProcedureInput[] | TreatmentItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: TreatmentItemCreateOrConnectWithoutProcedureInput | TreatmentItemCreateOrConnectWithoutProcedureInput[]
    upsert?: TreatmentItemUpsertWithWhereUniqueWithoutProcedureInput | TreatmentItemUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: TreatmentItemCreateManyProcedureInputEnvelope
    set?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    disconnect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    delete?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    connect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    update?: TreatmentItemUpdateWithWhereUniqueWithoutProcedureInput | TreatmentItemUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: TreatmentItemUpdateManyWithWhereWithoutProcedureInput | TreatmentItemUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: TreatmentItemScalarWhereInput | TreatmentItemScalarWhereInput[]
  }

  export type DentistProcedureUncheckedUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<DentistProcedureCreateWithoutProcedureInput, DentistProcedureUncheckedCreateWithoutProcedureInput> | DentistProcedureCreateWithoutProcedureInput[] | DentistProcedureUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: DentistProcedureCreateOrConnectWithoutProcedureInput | DentistProcedureCreateOrConnectWithoutProcedureInput[]
    upsert?: DentistProcedureUpsertWithWhereUniqueWithoutProcedureInput | DentistProcedureUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: DentistProcedureCreateManyProcedureInputEnvelope
    set?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    disconnect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    delete?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    connect?: DentistProcedureWhereUniqueInput | DentistProcedureWhereUniqueInput[]
    update?: DentistProcedureUpdateWithWhereUniqueWithoutProcedureInput | DentistProcedureUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: DentistProcedureUpdateManyWithWhereWithoutProcedureInput | DentistProcedureUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: DentistProcedureScalarWhereInput | DentistProcedureScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutProcedureRelationNestedInput = {
    create?: XOR<AppointmentCreateWithoutProcedureRelationInput, AppointmentUncheckedCreateWithoutProcedureRelationInput> | AppointmentCreateWithoutProcedureRelationInput[] | AppointmentUncheckedCreateWithoutProcedureRelationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProcedureRelationInput | AppointmentCreateOrConnectWithoutProcedureRelationInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProcedureRelationInput | AppointmentUpsertWithWhereUniqueWithoutProcedureRelationInput[]
    createMany?: AppointmentCreateManyProcedureRelationInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProcedureRelationInput | AppointmentUpdateWithWhereUniqueWithoutProcedureRelationInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProcedureRelationInput | AppointmentUpdateManyWithWhereWithoutProcedureRelationInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AttendanceProcedureUncheckedUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<AttendanceProcedureCreateWithoutProcedureInput, AttendanceProcedureUncheckedCreateWithoutProcedureInput> | AttendanceProcedureCreateWithoutProcedureInput[] | AttendanceProcedureUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutProcedureInput | AttendanceProcedureCreateOrConnectWithoutProcedureInput[]
    upsert?: AttendanceProcedureUpsertWithWhereUniqueWithoutProcedureInput | AttendanceProcedureUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: AttendanceProcedureCreateManyProcedureInputEnvelope
    set?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    disconnect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    delete?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    update?: AttendanceProcedureUpdateWithWhereUniqueWithoutProcedureInput | AttendanceProcedureUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: AttendanceProcedureUpdateManyWithWhereWithoutProcedureInput | AttendanceProcedureUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: AttendanceProcedureScalarWhereInput | AttendanceProcedureScalarWhereInput[]
  }

  export type TreatmentItemUncheckedUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<TreatmentItemCreateWithoutProcedureInput, TreatmentItemUncheckedCreateWithoutProcedureInput> | TreatmentItemCreateWithoutProcedureInput[] | TreatmentItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: TreatmentItemCreateOrConnectWithoutProcedureInput | TreatmentItemCreateOrConnectWithoutProcedureInput[]
    upsert?: TreatmentItemUpsertWithWhereUniqueWithoutProcedureInput | TreatmentItemUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: TreatmentItemCreateManyProcedureInputEnvelope
    set?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    disconnect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    delete?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    connect?: TreatmentItemWhereUniqueInput | TreatmentItemWhereUniqueInput[]
    update?: TreatmentItemUpdateWithWhereUniqueWithoutProcedureInput | TreatmentItemUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: TreatmentItemUpdateManyWithWhereWithoutProcedureInput | TreatmentItemUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: TreatmentItemScalarWhereInput | TreatmentItemScalarWhereInput[]
  }

  export type DentistCreateNestedOneWithoutDentistProceduresInput = {
    create?: XOR<DentistCreateWithoutDentistProceduresInput, DentistUncheckedCreateWithoutDentistProceduresInput>
    connectOrCreate?: DentistCreateOrConnectWithoutDentistProceduresInput
    connect?: DentistWhereUniqueInput
  }

  export type ProcedureCreateNestedOneWithoutDentistProceduresInput = {
    create?: XOR<ProcedureCreateWithoutDentistProceduresInput, ProcedureUncheckedCreateWithoutDentistProceduresInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutDentistProceduresInput
    connect?: ProcedureWhereUniqueInput
  }

  export type DentistUpdateOneRequiredWithoutDentistProceduresNestedInput = {
    create?: XOR<DentistCreateWithoutDentistProceduresInput, DentistUncheckedCreateWithoutDentistProceduresInput>
    connectOrCreate?: DentistCreateOrConnectWithoutDentistProceduresInput
    upsert?: DentistUpsertWithoutDentistProceduresInput
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutDentistProceduresInput, DentistUpdateWithoutDentistProceduresInput>, DentistUncheckedUpdateWithoutDentistProceduresInput>
  }

  export type ProcedureUpdateOneRequiredWithoutDentistProceduresNestedInput = {
    create?: XOR<ProcedureCreateWithoutDentistProceduresInput, ProcedureUncheckedCreateWithoutDentistProceduresInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutDentistProceduresInput
    upsert?: ProcedureUpsertWithoutDentistProceduresInput
    connect?: ProcedureWhereUniqueInput
    update?: XOR<XOR<ProcedureUpdateToOneWithWhereWithoutDentistProceduresInput, ProcedureUpdateWithoutDentistProceduresInput>, ProcedureUncheckedUpdateWithoutDentistProceduresInput>
  }

  export type DentistCreateNestedOneWithoutDentistSpecialtiesInput = {
    create?: XOR<DentistCreateWithoutDentistSpecialtiesInput, DentistUncheckedCreateWithoutDentistSpecialtiesInput>
    connectOrCreate?: DentistCreateOrConnectWithoutDentistSpecialtiesInput
    connect?: DentistWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutDentistSpecialtiesInput = {
    create?: XOR<SpecialtyCreateWithoutDentistSpecialtiesInput, SpecialtyUncheckedCreateWithoutDentistSpecialtiesInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDentistSpecialtiesInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type DentistUpdateOneRequiredWithoutDentistSpecialtiesNestedInput = {
    create?: XOR<DentistCreateWithoutDentistSpecialtiesInput, DentistUncheckedCreateWithoutDentistSpecialtiesInput>
    connectOrCreate?: DentistCreateOrConnectWithoutDentistSpecialtiesInput
    upsert?: DentistUpsertWithoutDentistSpecialtiesInput
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutDentistSpecialtiesInput, DentistUpdateWithoutDentistSpecialtiesInput>, DentistUncheckedUpdateWithoutDentistSpecialtiesInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutDentistSpecialtiesNestedInput = {
    create?: XOR<SpecialtyCreateWithoutDentistSpecialtiesInput, SpecialtyUncheckedCreateWithoutDentistSpecialtiesInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDentistSpecialtiesInput
    upsert?: SpecialtyUpsertWithoutDentistSpecialtiesInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<XOR<SpecialtyUpdateToOneWithWhereWithoutDentistSpecialtiesInput, SpecialtyUpdateWithoutDentistSpecialtiesInput>, SpecialtyUncheckedUpdateWithoutDentistSpecialtiesInput>
  }

  export type ClinicCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<ClinicCreateWithoutAttendancesInput, ClinicUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAttendancesInput
    connect?: ClinicWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<AppointmentCreateWithoutAttendanceInput, AppointmentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutAttendanceInput
    connect?: AppointmentWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<PatientCreateWithoutAttendancesInput, PatientUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAttendancesInput
    connect?: PatientWhereUniqueInput
  }

  export type DentistCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<DentistCreateWithoutAttendancesInput, DentistUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: DentistCreateOrConnectWithoutAttendancesInput
    connect?: DentistWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type AttendanceCIDCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<AttendanceCIDCreateWithoutAttendanceInput, AttendanceCIDUncheckedCreateWithoutAttendanceInput> | AttendanceCIDCreateWithoutAttendanceInput[] | AttendanceCIDUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceCIDCreateOrConnectWithoutAttendanceInput | AttendanceCIDCreateOrConnectWithoutAttendanceInput[]
    createMany?: AttendanceCIDCreateManyAttendanceInputEnvelope
    connect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
  }

  export type AttendanceProcedureCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<AttendanceProcedureCreateWithoutAttendanceInput, AttendanceProcedureUncheckedCreateWithoutAttendanceInput> | AttendanceProcedureCreateWithoutAttendanceInput[] | AttendanceProcedureUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutAttendanceInput | AttendanceProcedureCreateOrConnectWithoutAttendanceInput[]
    createMany?: AttendanceProcedureCreateManyAttendanceInputEnvelope
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
  }

  export type AttendanceOdontogramCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<AttendanceOdontogramCreateWithoutAttendanceInput, AttendanceOdontogramUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: AttendanceOdontogramCreateOrConnectWithoutAttendanceInput
    connect?: AttendanceOdontogramWhereUniqueInput
  }

  export type ClinicalDocumentCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<ClinicalDocumentCreateWithoutAttendanceInput, ClinicalDocumentUncheckedCreateWithoutAttendanceInput> | ClinicalDocumentCreateWithoutAttendanceInput[] | ClinicalDocumentUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: ClinicalDocumentCreateOrConnectWithoutAttendanceInput | ClinicalDocumentCreateOrConnectWithoutAttendanceInput[]
    createMany?: ClinicalDocumentCreateManyAttendanceInputEnvelope
    connect?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
  }

  export type RecordCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<RecordCreateWithoutAttendanceInput, RecordUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: RecordCreateOrConnectWithoutAttendanceInput
    connect?: RecordWhereUniqueInput
  }

  export type AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<AttendanceCIDCreateWithoutAttendanceInput, AttendanceCIDUncheckedCreateWithoutAttendanceInput> | AttendanceCIDCreateWithoutAttendanceInput[] | AttendanceCIDUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceCIDCreateOrConnectWithoutAttendanceInput | AttendanceCIDCreateOrConnectWithoutAttendanceInput[]
    createMany?: AttendanceCIDCreateManyAttendanceInputEnvelope
    connect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
  }

  export type AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<AttendanceProcedureCreateWithoutAttendanceInput, AttendanceProcedureUncheckedCreateWithoutAttendanceInput> | AttendanceProcedureCreateWithoutAttendanceInput[] | AttendanceProcedureUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutAttendanceInput | AttendanceProcedureCreateOrConnectWithoutAttendanceInput[]
    createMany?: AttendanceProcedureCreateManyAttendanceInputEnvelope
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
  }

  export type AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<AttendanceOdontogramCreateWithoutAttendanceInput, AttendanceOdontogramUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: AttendanceOdontogramCreateOrConnectWithoutAttendanceInput
    connect?: AttendanceOdontogramWhereUniqueInput
  }

  export type ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<ClinicalDocumentCreateWithoutAttendanceInput, ClinicalDocumentUncheckedCreateWithoutAttendanceInput> | ClinicalDocumentCreateWithoutAttendanceInput[] | ClinicalDocumentUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: ClinicalDocumentCreateOrConnectWithoutAttendanceInput | ClinicalDocumentCreateOrConnectWithoutAttendanceInput[]
    createMany?: ClinicalDocumentCreateManyAttendanceInputEnvelope
    connect?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
  }

  export type RecordUncheckedCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<RecordCreateWithoutAttendanceInput, RecordUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: RecordCreateOrConnectWithoutAttendanceInput
    connect?: RecordWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type ClinicUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<ClinicCreateWithoutAttendancesInput, ClinicUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutAttendancesInput
    upsert?: ClinicUpsertWithoutAttendancesInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutAttendancesInput, ClinicUpdateWithoutAttendancesInput>, ClinicUncheckedUpdateWithoutAttendancesInput>
  }

  export type AppointmentUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<AppointmentCreateWithoutAttendanceInput, AppointmentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutAttendanceInput
    upsert?: AppointmentUpsertWithoutAttendanceInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutAttendanceInput, AppointmentUpdateWithoutAttendanceInput>, AppointmentUncheckedUpdateWithoutAttendanceInput>
  }

  export type PatientUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<PatientCreateWithoutAttendancesInput, PatientUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAttendancesInput
    upsert?: PatientUpsertWithoutAttendancesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAttendancesInput, PatientUpdateWithoutAttendancesInput>, PatientUncheckedUpdateWithoutAttendancesInput>
  }

  export type DentistUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<DentistCreateWithoutAttendancesInput, DentistUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: DentistCreateOrConnectWithoutAttendancesInput
    upsert?: DentistUpsertWithoutAttendancesInput
    disconnect?: DentistWhereInput | boolean
    delete?: DentistWhereInput | boolean
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutAttendancesInput, DentistUpdateWithoutAttendancesInput>, DentistUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    upsert?: UserUpsertWithoutAttendancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendancesInput, UserUpdateWithoutAttendancesInput>, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type AttendanceCIDUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<AttendanceCIDCreateWithoutAttendanceInput, AttendanceCIDUncheckedCreateWithoutAttendanceInput> | AttendanceCIDCreateWithoutAttendanceInput[] | AttendanceCIDUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceCIDCreateOrConnectWithoutAttendanceInput | AttendanceCIDCreateOrConnectWithoutAttendanceInput[]
    upsert?: AttendanceCIDUpsertWithWhereUniqueWithoutAttendanceInput | AttendanceCIDUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: AttendanceCIDCreateManyAttendanceInputEnvelope
    set?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    disconnect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    delete?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    connect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    update?: AttendanceCIDUpdateWithWhereUniqueWithoutAttendanceInput | AttendanceCIDUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: AttendanceCIDUpdateManyWithWhereWithoutAttendanceInput | AttendanceCIDUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: AttendanceCIDScalarWhereInput | AttendanceCIDScalarWhereInput[]
  }

  export type AttendanceProcedureUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<AttendanceProcedureCreateWithoutAttendanceInput, AttendanceProcedureUncheckedCreateWithoutAttendanceInput> | AttendanceProcedureCreateWithoutAttendanceInput[] | AttendanceProcedureUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutAttendanceInput | AttendanceProcedureCreateOrConnectWithoutAttendanceInput[]
    upsert?: AttendanceProcedureUpsertWithWhereUniqueWithoutAttendanceInput | AttendanceProcedureUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: AttendanceProcedureCreateManyAttendanceInputEnvelope
    set?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    disconnect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    delete?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    update?: AttendanceProcedureUpdateWithWhereUniqueWithoutAttendanceInput | AttendanceProcedureUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: AttendanceProcedureUpdateManyWithWhereWithoutAttendanceInput | AttendanceProcedureUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: AttendanceProcedureScalarWhereInput | AttendanceProcedureScalarWhereInput[]
  }

  export type AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<AttendanceOdontogramCreateWithoutAttendanceInput, AttendanceOdontogramUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: AttendanceOdontogramCreateOrConnectWithoutAttendanceInput
    upsert?: AttendanceOdontogramUpsertWithoutAttendanceInput
    disconnect?: AttendanceOdontogramWhereInput | boolean
    delete?: AttendanceOdontogramWhereInput | boolean
    connect?: AttendanceOdontogramWhereUniqueInput
    update?: XOR<XOR<AttendanceOdontogramUpdateToOneWithWhereWithoutAttendanceInput, AttendanceOdontogramUpdateWithoutAttendanceInput>, AttendanceOdontogramUncheckedUpdateWithoutAttendanceInput>
  }

  export type ClinicalDocumentUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<ClinicalDocumentCreateWithoutAttendanceInput, ClinicalDocumentUncheckedCreateWithoutAttendanceInput> | ClinicalDocumentCreateWithoutAttendanceInput[] | ClinicalDocumentUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: ClinicalDocumentCreateOrConnectWithoutAttendanceInput | ClinicalDocumentCreateOrConnectWithoutAttendanceInput[]
    upsert?: ClinicalDocumentUpsertWithWhereUniqueWithoutAttendanceInput | ClinicalDocumentUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: ClinicalDocumentCreateManyAttendanceInputEnvelope
    set?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
    disconnect?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
    delete?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
    connect?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
    update?: ClinicalDocumentUpdateWithWhereUniqueWithoutAttendanceInput | ClinicalDocumentUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: ClinicalDocumentUpdateManyWithWhereWithoutAttendanceInput | ClinicalDocumentUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: ClinicalDocumentScalarWhereInput | ClinicalDocumentScalarWhereInput[]
  }

  export type RecordUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<RecordCreateWithoutAttendanceInput, RecordUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: RecordCreateOrConnectWithoutAttendanceInput
    upsert?: RecordUpsertWithoutAttendanceInput
    disconnect?: RecordWhereInput | boolean
    delete?: RecordWhereInput | boolean
    connect?: RecordWhereUniqueInput
    update?: XOR<XOR<RecordUpdateToOneWithWhereWithoutAttendanceInput, RecordUpdateWithoutAttendanceInput>, RecordUncheckedUpdateWithoutAttendanceInput>
  }

  export type AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<AttendanceCIDCreateWithoutAttendanceInput, AttendanceCIDUncheckedCreateWithoutAttendanceInput> | AttendanceCIDCreateWithoutAttendanceInput[] | AttendanceCIDUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceCIDCreateOrConnectWithoutAttendanceInput | AttendanceCIDCreateOrConnectWithoutAttendanceInput[]
    upsert?: AttendanceCIDUpsertWithWhereUniqueWithoutAttendanceInput | AttendanceCIDUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: AttendanceCIDCreateManyAttendanceInputEnvelope
    set?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    disconnect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    delete?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    connect?: AttendanceCIDWhereUniqueInput | AttendanceCIDWhereUniqueInput[]
    update?: AttendanceCIDUpdateWithWhereUniqueWithoutAttendanceInput | AttendanceCIDUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: AttendanceCIDUpdateManyWithWhereWithoutAttendanceInput | AttendanceCIDUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: AttendanceCIDScalarWhereInput | AttendanceCIDScalarWhereInput[]
  }

  export type AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<AttendanceProcedureCreateWithoutAttendanceInput, AttendanceProcedureUncheckedCreateWithoutAttendanceInput> | AttendanceProcedureCreateWithoutAttendanceInput[] | AttendanceProcedureUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceProcedureCreateOrConnectWithoutAttendanceInput | AttendanceProcedureCreateOrConnectWithoutAttendanceInput[]
    upsert?: AttendanceProcedureUpsertWithWhereUniqueWithoutAttendanceInput | AttendanceProcedureUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: AttendanceProcedureCreateManyAttendanceInputEnvelope
    set?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    disconnect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    delete?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    connect?: AttendanceProcedureWhereUniqueInput | AttendanceProcedureWhereUniqueInput[]
    update?: AttendanceProcedureUpdateWithWhereUniqueWithoutAttendanceInput | AttendanceProcedureUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: AttendanceProcedureUpdateManyWithWhereWithoutAttendanceInput | AttendanceProcedureUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: AttendanceProcedureScalarWhereInput | AttendanceProcedureScalarWhereInput[]
  }

  export type AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<AttendanceOdontogramCreateWithoutAttendanceInput, AttendanceOdontogramUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: AttendanceOdontogramCreateOrConnectWithoutAttendanceInput
    upsert?: AttendanceOdontogramUpsertWithoutAttendanceInput
    disconnect?: AttendanceOdontogramWhereInput | boolean
    delete?: AttendanceOdontogramWhereInput | boolean
    connect?: AttendanceOdontogramWhereUniqueInput
    update?: XOR<XOR<AttendanceOdontogramUpdateToOneWithWhereWithoutAttendanceInput, AttendanceOdontogramUpdateWithoutAttendanceInput>, AttendanceOdontogramUncheckedUpdateWithoutAttendanceInput>
  }

  export type ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<ClinicalDocumentCreateWithoutAttendanceInput, ClinicalDocumentUncheckedCreateWithoutAttendanceInput> | ClinicalDocumentCreateWithoutAttendanceInput[] | ClinicalDocumentUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: ClinicalDocumentCreateOrConnectWithoutAttendanceInput | ClinicalDocumentCreateOrConnectWithoutAttendanceInput[]
    upsert?: ClinicalDocumentUpsertWithWhereUniqueWithoutAttendanceInput | ClinicalDocumentUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: ClinicalDocumentCreateManyAttendanceInputEnvelope
    set?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
    disconnect?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
    delete?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
    connect?: ClinicalDocumentWhereUniqueInput | ClinicalDocumentWhereUniqueInput[]
    update?: ClinicalDocumentUpdateWithWhereUniqueWithoutAttendanceInput | ClinicalDocumentUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: ClinicalDocumentUpdateManyWithWhereWithoutAttendanceInput | ClinicalDocumentUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: ClinicalDocumentScalarWhereInput | ClinicalDocumentScalarWhereInput[]
  }

  export type RecordUncheckedUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<RecordCreateWithoutAttendanceInput, RecordUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: RecordCreateOrConnectWithoutAttendanceInput
    upsert?: RecordUpsertWithoutAttendanceInput
    disconnect?: RecordWhereInput | boolean
    delete?: RecordWhereInput | boolean
    connect?: RecordWhereUniqueInput
    update?: XOR<XOR<RecordUpdateToOneWithWhereWithoutAttendanceInput, RecordUpdateWithoutAttendanceInput>, RecordUncheckedUpdateWithoutAttendanceInput>
  }

  export type AttendanceCreateNestedOneWithoutCidsInput = {
    create?: XOR<AttendanceCreateWithoutCidsInput, AttendanceUncheckedCreateWithoutCidsInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutCidsInput
    connect?: AttendanceWhereUniqueInput
  }

  export type DentistCreateNestedOneWithoutAttendanceCidsInput = {
    create?: XOR<DentistCreateWithoutAttendanceCidsInput, DentistUncheckedCreateWithoutAttendanceCidsInput>
    connectOrCreate?: DentistCreateOrConnectWithoutAttendanceCidsInput
    connect?: DentistWhereUniqueInput
  }

  export type AttendanceUpdateOneRequiredWithoutCidsNestedInput = {
    create?: XOR<AttendanceCreateWithoutCidsInput, AttendanceUncheckedCreateWithoutCidsInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutCidsInput
    upsert?: AttendanceUpsertWithoutCidsInput
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutCidsInput, AttendanceUpdateWithoutCidsInput>, AttendanceUncheckedUpdateWithoutCidsInput>
  }

  export type DentistUpdateOneRequiredWithoutAttendanceCidsNestedInput = {
    create?: XOR<DentistCreateWithoutAttendanceCidsInput, DentistUncheckedCreateWithoutAttendanceCidsInput>
    connectOrCreate?: DentistCreateOrConnectWithoutAttendanceCidsInput
    upsert?: DentistUpsertWithoutAttendanceCidsInput
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutAttendanceCidsInput, DentistUpdateWithoutAttendanceCidsInput>, DentistUncheckedUpdateWithoutAttendanceCidsInput>
  }

  export type AttendanceProcedureCreatefacesInput = {
    set: string[]
  }

  export type AttendanceCreateNestedOneWithoutProceduresInput = {
    create?: XOR<AttendanceCreateWithoutProceduresInput, AttendanceUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutProceduresInput
    connect?: AttendanceWhereUniqueInput
  }

  export type ProcedureCreateNestedOneWithoutAttendanceProceduresInput = {
    create?: XOR<ProcedureCreateWithoutAttendanceProceduresInput, ProcedureUncheckedCreateWithoutAttendanceProceduresInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutAttendanceProceduresInput
    connect?: ProcedureWhereUniqueInput
  }

  export type DentistCreateNestedOneWithoutAttendanceProceduresInput = {
    create?: XOR<DentistCreateWithoutAttendanceProceduresInput, DentistUncheckedCreateWithoutAttendanceProceduresInput>
    connectOrCreate?: DentistCreateOrConnectWithoutAttendanceProceduresInput
    connect?: DentistWhereUniqueInput
  }

  export type AttendanceProcedureUpdatefacesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AttendanceUpdateOneRequiredWithoutProceduresNestedInput = {
    create?: XOR<AttendanceCreateWithoutProceduresInput, AttendanceUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutProceduresInput
    upsert?: AttendanceUpsertWithoutProceduresInput
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutProceduresInput, AttendanceUpdateWithoutProceduresInput>, AttendanceUncheckedUpdateWithoutProceduresInput>
  }

  export type ProcedureUpdateOneWithoutAttendanceProceduresNestedInput = {
    create?: XOR<ProcedureCreateWithoutAttendanceProceduresInput, ProcedureUncheckedCreateWithoutAttendanceProceduresInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutAttendanceProceduresInput
    upsert?: ProcedureUpsertWithoutAttendanceProceduresInput
    disconnect?: ProcedureWhereInput | boolean
    delete?: ProcedureWhereInput | boolean
    connect?: ProcedureWhereUniqueInput
    update?: XOR<XOR<ProcedureUpdateToOneWithWhereWithoutAttendanceProceduresInput, ProcedureUpdateWithoutAttendanceProceduresInput>, ProcedureUncheckedUpdateWithoutAttendanceProceduresInput>
  }

  export type DentistUpdateOneWithoutAttendanceProceduresNestedInput = {
    create?: XOR<DentistCreateWithoutAttendanceProceduresInput, DentistUncheckedCreateWithoutAttendanceProceduresInput>
    connectOrCreate?: DentistCreateOrConnectWithoutAttendanceProceduresInput
    upsert?: DentistUpsertWithoutAttendanceProceduresInput
    disconnect?: DentistWhereInput | boolean
    delete?: DentistWhereInput | boolean
    connect?: DentistWhereUniqueInput
    update?: XOR<XOR<DentistUpdateToOneWithWhereWithoutAttendanceProceduresInput, DentistUpdateWithoutAttendanceProceduresInput>, DentistUncheckedUpdateWithoutAttendanceProceduresInput>
  }

  export type AttendanceCreateNestedOneWithoutOdontogramInput = {
    create?: XOR<AttendanceCreateWithoutOdontogramInput, AttendanceUncheckedCreateWithoutOdontogramInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutOdontogramInput
    connect?: AttendanceWhereUniqueInput
  }

  export type AttendanceUpdateOneRequiredWithoutOdontogramNestedInput = {
    create?: XOR<AttendanceCreateWithoutOdontogramInput, AttendanceUncheckedCreateWithoutOdontogramInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutOdontogramInput
    upsert?: AttendanceUpsertWithoutOdontogramInput
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutOdontogramInput, AttendanceUpdateWithoutOdontogramInput>, AttendanceUncheckedUpdateWithoutOdontogramInput>
  }

  export type AttendanceCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AttendanceCreateWithoutDocumentsInput, AttendanceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutDocumentsInput
    connect?: AttendanceWhereUniqueInput
  }

  export type EnumClinicalDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClinicalDocumentType
  }

  export type AttendanceUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<AttendanceCreateWithoutDocumentsInput, AttendanceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutDocumentsInput
    upsert?: AttendanceUpsertWithoutDocumentsInput
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutDocumentsInput, AttendanceUpdateWithoutDocumentsInput>, AttendanceUncheckedUpdateWithoutDocumentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumTreatmentPlanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TreatmentPlanStatus | EnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TreatmentPlanStatus[] | ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreatmentPlanStatus[] | ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTreatmentPlanStatusFilter<$PrismaModel> | $Enums.TreatmentPlanStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumDiscountTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountTypeNullableFilter<$PrismaModel> | $Enums.DiscountType | null
  }

  export type NestedEnumTreatmentPlanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TreatmentPlanStatus | EnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TreatmentPlanStatus[] | ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreatmentPlanStatus[] | ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTreatmentPlanStatusWithAggregatesFilter<$PrismaModel> | $Enums.TreatmentPlanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTreatmentPlanStatusFilter<$PrismaModel>
    _max?: NestedEnumTreatmentPlanStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumInventoryMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMovementType | EnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryMovementTypeFilter<$PrismaModel> | $Enums.InventoryMovementType
  }

  export type NestedEnumInventoryMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMovementType | EnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.InventoryMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumInventoryMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumClinicalDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicalDocumentType | EnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicalDocumentType[] | ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicalDocumentType[] | ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicalDocumentTypeFilter<$PrismaModel> | $Enums.ClinicalDocumentType
  }

  export type NestedEnumClinicalDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicalDocumentType | EnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicalDocumentType[] | ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicalDocumentType[] | ListEnumClinicalDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicalDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClinicalDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClinicalDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumClinicalDocumentTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutClinicInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentist?: DentistCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutClinicInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentist?: DentistUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutClinicInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>
  }

  export type UserCreateManyClinicInputEnvelope = {
    data: UserCreateManyClinicInput | UserCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type DentistCreateWithoutClinicInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutClinicInput = {
    id?: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutClinicInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutClinicInput, DentistUncheckedCreateWithoutClinicInput>
  }

  export type DentistCreateManyClinicInputEnvelope = {
    data: DentistCreateManyClinicInput | DentistCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutClinicInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    records?: RecordCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    attendances?: AttendanceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutClinicInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    records?: RecordUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutClinicInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput>
  }

  export type PatientCreateManyClinicInputEnvelope = {
    data: PatientCreateManyClinicInput | PatientCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutClinicInput = {
    id?: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dentist: DentistCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    procedureRelation?: ProcedureCreateNestedOneWithoutAppointmentsInput
    record?: RecordCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutClinicInput = {
    id?: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    record?: RecordUncheckedCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutClinicInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput>
  }

  export type AppointmentCreateManyClinicInputEnvelope = {
    data: AppointmentCreateManyClinicInput | AppointmentCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type RecordCreateWithoutClinicInput = {
    id?: string
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRecordsInput
    dentist: DentistCreateNestedOneWithoutRecordsInput
    appointment?: AppointmentCreateNestedOneWithoutRecordInput
    attendance?: AttendanceCreateNestedOneWithoutRecordInput
  }

  export type RecordUncheckedCreateWithoutClinicInput = {
    id?: string
    patientId: string
    dentistId: string
    appointmentId?: string | null
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordCreateOrConnectWithoutClinicInput = {
    where: RecordWhereUniqueInput
    create: XOR<RecordCreateWithoutClinicInput, RecordUncheckedCreateWithoutClinicInput>
  }

  export type RecordCreateManyClinicInputEnvelope = {
    data: RecordCreateManyClinicInput | RecordCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentPlanCreateWithoutClinicInput = {
    id?: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTreatmentPlansInput
    dentist: DentistCreateNestedOneWithoutTreatmentPlansInput
    items?: TreatmentItemCreateNestedManyWithoutPlanInput
    paymentTreatmentPlans?: PaymentTreatmentPlanCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanUncheckedCreateWithoutClinicInput = {
    id?: string
    patientId: string
    dentistId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TreatmentItemUncheckedCreateNestedManyWithoutPlanInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanCreateOrConnectWithoutClinicInput = {
    where: TreatmentPlanWhereUniqueInput
    create: XOR<TreatmentPlanCreateWithoutClinicInput, TreatmentPlanUncheckedCreateWithoutClinicInput>
  }

  export type TreatmentPlanCreateManyClinicInputEnvelope = {
    data: TreatmentPlanCreateManyClinicInput | TreatmentPlanCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutClinicInput = {
    id?: string
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
    patient?: PatientCreateNestedOneWithoutPaymentsInput
    paymentTreatmentPlans?: PaymentTreatmentPlanCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutClinicInput = {
    id?: string
    patientId?: string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutClinicInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutClinicInput, PaymentUncheckedCreateWithoutClinicInput>
  }

  export type PaymentCreateManyClinicInputEnvelope = {
    data: PaymentCreateManyClinicInput | PaymentCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutClinicInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutClinicInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutClinicInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
  }

  export type AuditLogCreateWithoutClinicInput = {
    id?: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutClinicInput = {
    id?: string
    userId: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutClinicInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput>
  }

  export type AuditLogCreateManyClinicInputEnvelope = {
    data: AuditLogCreateManyClinicInput | AuditLogCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutClinicInput = {
    id?: string
    name: string
    description?: string | null
    unit: string
    currentQuantity?: number
    minQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutClinicInput = {
    id?: string
    name: string
    description?: string | null
    unit: string
    currentQuantity?: number
    minQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutClinicInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutClinicInput, InventoryItemUncheckedCreateWithoutClinicInput>
  }

  export type InventoryItemCreateManyClinicInputEnvelope = {
    data: InventoryItemCreateManyClinicInput | InventoryItemCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutClinicInput = {
    id?: string
    type: $Enums.InventoryMovementType
    quantity: number
    notes?: string | null
    createdAt?: Date | string
    item: InventoryItemCreateNestedOneWithoutMovementsInput
    appointment?: AppointmentCreateNestedOneWithoutInventoryMovementsInput
    createdBy: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutClinicInput = {
    id?: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutClinicInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutClinicInput, InventoryMovementUncheckedCreateWithoutClinicInput>
  }

  export type InventoryMovementCreateManyClinicInputEnvelope = {
    data: InventoryMovementCreateManyClinicInput | InventoryMovementCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureCreateWithoutClinicInput = {
    id?: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specialty: SpecialtyCreateNestedOneWithoutProceduresInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutClinicInput = {
    id?: string
    specialtyId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutClinicInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutClinicInput, ProcedureUncheckedCreateWithoutClinicInput>
  }

  export type ProcedureCreateManyClinicInputEnvelope = {
    data: ProcedureCreateManyClinicInput | ProcedureCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutClinicInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutClinicInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutClinicInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutClinicInput, AttendanceUncheckedCreateWithoutClinicInput>
  }

  export type AttendanceCreateManyClinicInputEnvelope = {
    data: AttendanceCreateManyClinicInput | AttendanceCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutClinicInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutClinicInput, UserUncheckedUpdateWithoutClinicInput>
    create: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>
  }

  export type UserUpdateWithWhereUniqueWithoutClinicInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutClinicInput, UserUncheckedUpdateWithoutClinicInput>
  }

  export type UserUpdateManyWithWhereWithoutClinicInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClinicInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    clinicId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type DentistUpsertWithWhereUniqueWithoutClinicInput = {
    where: DentistWhereUniqueInput
    update: XOR<DentistUpdateWithoutClinicInput, DentistUncheckedUpdateWithoutClinicInput>
    create: XOR<DentistCreateWithoutClinicInput, DentistUncheckedCreateWithoutClinicInput>
  }

  export type DentistUpdateWithWhereUniqueWithoutClinicInput = {
    where: DentistWhereUniqueInput
    data: XOR<DentistUpdateWithoutClinicInput, DentistUncheckedUpdateWithoutClinicInput>
  }

  export type DentistUpdateManyWithWhereWithoutClinicInput = {
    where: DentistScalarWhereInput
    data: XOR<DentistUpdateManyMutationInput, DentistUncheckedUpdateManyWithoutClinicInput>
  }

  export type DentistScalarWhereInput = {
    AND?: DentistScalarWhereInput | DentistScalarWhereInput[]
    OR?: DentistScalarWhereInput[]
    NOT?: DentistScalarWhereInput | DentistScalarWhereInput[]
    id?: StringFilter<"Dentist"> | string
    clinicId?: StringFilter<"Dentist"> | string
    userId?: StringFilter<"Dentist"> | string
    cro?: StringFilter<"Dentist"> | string
    specialty?: StringNullableFilter<"Dentist"> | string | null
    workingHours?: JsonNullableFilter<"Dentist">
    bankInfo?: JsonNullableFilter<"Dentist">
    contactInfo?: JsonNullableFilter<"Dentist">
    personalInfo?: JsonNullableFilter<"Dentist">
    commission?: DecimalNullableFilter<"Dentist"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Dentist"> | Date | string
    updatedAt?: DateTimeFilter<"Dentist"> | Date | string
  }

  export type PatientUpsertWithWhereUniqueWithoutClinicInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutClinicInput, PatientUncheckedUpdateWithoutClinicInput>
    create: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutClinicInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutClinicInput, PatientUncheckedUpdateWithoutClinicInput>
  }

  export type PatientUpdateManyWithWhereWithoutClinicInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutClinicInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    clinicId?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    cpf?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutClinicInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutClinicInput, AppointmentUncheckedUpdateWithoutClinicInput>
    create: XOR<AppointmentCreateWithoutClinicInput, AppointmentUncheckedCreateWithoutClinicInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutClinicInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutClinicInput, AppointmentUncheckedUpdateWithoutClinicInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutClinicInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutClinicInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    clinicId?: StringFilter<"Appointment"> | string
    dentistId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    date?: DateTimeFilter<"Appointment"> | Date | string
    durationMinutes?: IntFilter<"Appointment"> | number
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    procedure?: StringNullableFilter<"Appointment"> | string | null
    procedureId?: StringNullableFilter<"Appointment"> | string | null
    procedureSnapshot?: JsonNullableFilter<"Appointment">
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type RecordUpsertWithWhereUniqueWithoutClinicInput = {
    where: RecordWhereUniqueInput
    update: XOR<RecordUpdateWithoutClinicInput, RecordUncheckedUpdateWithoutClinicInput>
    create: XOR<RecordCreateWithoutClinicInput, RecordUncheckedCreateWithoutClinicInput>
  }

  export type RecordUpdateWithWhereUniqueWithoutClinicInput = {
    where: RecordWhereUniqueInput
    data: XOR<RecordUpdateWithoutClinicInput, RecordUncheckedUpdateWithoutClinicInput>
  }

  export type RecordUpdateManyWithWhereWithoutClinicInput = {
    where: RecordScalarWhereInput
    data: XOR<RecordUpdateManyMutationInput, RecordUncheckedUpdateManyWithoutClinicInput>
  }

  export type RecordScalarWhereInput = {
    AND?: RecordScalarWhereInput | RecordScalarWhereInput[]
    OR?: RecordScalarWhereInput[]
    NOT?: RecordScalarWhereInput | RecordScalarWhereInput[]
    id?: StringFilter<"Record"> | string
    clinicId?: StringFilter<"Record"> | string
    patientId?: StringFilter<"Record"> | string
    dentistId?: StringFilter<"Record"> | string
    appointmentId?: StringNullableFilter<"Record"> | string | null
    attendanceId?: StringNullableFilter<"Record"> | string | null
    description?: StringFilter<"Record"> | string
    procedures?: JsonNullableFilter<"Record">
    odontogram?: JsonNullableFilter<"Record">
    createdAt?: DateTimeFilter<"Record"> | Date | string
    updatedAt?: DateTimeFilter<"Record"> | Date | string
  }

  export type TreatmentPlanUpsertWithWhereUniqueWithoutClinicInput = {
    where: TreatmentPlanWhereUniqueInput
    update: XOR<TreatmentPlanUpdateWithoutClinicInput, TreatmentPlanUncheckedUpdateWithoutClinicInput>
    create: XOR<TreatmentPlanCreateWithoutClinicInput, TreatmentPlanUncheckedCreateWithoutClinicInput>
  }

  export type TreatmentPlanUpdateWithWhereUniqueWithoutClinicInput = {
    where: TreatmentPlanWhereUniqueInput
    data: XOR<TreatmentPlanUpdateWithoutClinicInput, TreatmentPlanUncheckedUpdateWithoutClinicInput>
  }

  export type TreatmentPlanUpdateManyWithWhereWithoutClinicInput = {
    where: TreatmentPlanScalarWhereInput
    data: XOR<TreatmentPlanUpdateManyMutationInput, TreatmentPlanUncheckedUpdateManyWithoutClinicInput>
  }

  export type TreatmentPlanScalarWhereInput = {
    AND?: TreatmentPlanScalarWhereInput | TreatmentPlanScalarWhereInput[]
    OR?: TreatmentPlanScalarWhereInput[]
    NOT?: TreatmentPlanScalarWhereInput | TreatmentPlanScalarWhereInput[]
    id?: StringFilter<"TreatmentPlan"> | string
    clinicId?: StringFilter<"TreatmentPlan"> | string
    patientId?: StringFilter<"TreatmentPlan"> | string
    dentistId?: StringFilter<"TreatmentPlan"> | string
    status?: EnumTreatmentPlanStatusFilter<"TreatmentPlan"> | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string
    discountType?: EnumDiscountTypeNullableFilter<"TreatmentPlan"> | $Enums.DiscountType | null
    discountValue?: DecimalNullableFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string | null
    finalAmount?: DecimalNullableFilter<"TreatmentPlan"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"TreatmentPlan"> | string | null
    createdAt?: DateTimeFilter<"TreatmentPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TreatmentPlan"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutClinicInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutClinicInput, PaymentUncheckedUpdateWithoutClinicInput>
    create: XOR<PaymentCreateWithoutClinicInput, PaymentUncheckedCreateWithoutClinicInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutClinicInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutClinicInput, PaymentUncheckedUpdateWithoutClinicInput>
  }

  export type PaymentUpdateManyWithWhereWithoutClinicInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutClinicInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    clinicId?: StringFilter<"Payment"> | string
    patientId?: StringNullableFilter<"Payment"> | string | null
    originalAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    discountType?: EnumDiscountTypeNullableFilter<"Payment"> | $Enums.DiscountType | null
    discountValue?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type SubscriptionUpsertWithoutClinicInput = {
    update: XOR<SubscriptionUpdateWithoutClinicInput, SubscriptionUncheckedUpdateWithoutClinicInput>
    create: XOR<SubscriptionCreateWithoutClinicInput, SubscriptionUncheckedCreateWithoutClinicInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutClinicInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutClinicInput, SubscriptionUncheckedUpdateWithoutClinicInput>
  }

  export type SubscriptionUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutClinicInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutClinicInput, AuditLogUncheckedUpdateWithoutClinicInput>
    create: XOR<AuditLogCreateWithoutClinicInput, AuditLogUncheckedCreateWithoutClinicInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutClinicInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutClinicInput, AuditLogUncheckedUpdateWithoutClinicInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutClinicInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutClinicInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    clinicId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    targetType?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutClinicInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutClinicInput, InventoryItemUncheckedUpdateWithoutClinicInput>
    create: XOR<InventoryItemCreateWithoutClinicInput, InventoryItemUncheckedCreateWithoutClinicInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutClinicInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutClinicInput, InventoryItemUncheckedUpdateWithoutClinicInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutClinicInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutClinicInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    clinicId?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    currentQuantity?: IntFilter<"InventoryItem"> | number
    minQuantity?: IntNullableFilter<"InventoryItem"> | number | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutClinicInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutClinicInput, InventoryMovementUncheckedUpdateWithoutClinicInput>
    create: XOR<InventoryMovementCreateWithoutClinicInput, InventoryMovementUncheckedCreateWithoutClinicInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutClinicInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutClinicInput, InventoryMovementUncheckedUpdateWithoutClinicInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutClinicInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutClinicInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    clinicId?: StringFilter<"InventoryMovement"> | string
    itemId?: StringFilter<"InventoryMovement"> | string
    type?: EnumInventoryMovementTypeFilter<"InventoryMovement"> | $Enums.InventoryMovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    appointmentId?: StringNullableFilter<"InventoryMovement"> | string | null
    createdById?: StringFilter<"InventoryMovement"> | string
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
  }

  export type ProcedureUpsertWithWhereUniqueWithoutClinicInput = {
    where: ProcedureWhereUniqueInput
    update: XOR<ProcedureUpdateWithoutClinicInput, ProcedureUncheckedUpdateWithoutClinicInput>
    create: XOR<ProcedureCreateWithoutClinicInput, ProcedureUncheckedCreateWithoutClinicInput>
  }

  export type ProcedureUpdateWithWhereUniqueWithoutClinicInput = {
    where: ProcedureWhereUniqueInput
    data: XOR<ProcedureUpdateWithoutClinicInput, ProcedureUncheckedUpdateWithoutClinicInput>
  }

  export type ProcedureUpdateManyWithWhereWithoutClinicInput = {
    where: ProcedureScalarWhereInput
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyWithoutClinicInput>
  }

  export type ProcedureScalarWhereInput = {
    AND?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
    OR?: ProcedureScalarWhereInput[]
    NOT?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
    id?: StringFilter<"Procedure"> | string
    clinicId?: StringFilter<"Procedure"> | string
    specialtyId?: StringFilter<"Procedure"> | string
    name?: StringFilter<"Procedure"> | string
    description?: StringNullableFilter<"Procedure"> | string | null
    baseValue?: DecimalFilter<"Procedure"> | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFilter<"Procedure"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Procedure"> | boolean
    createdAt?: DateTimeFilter<"Procedure"> | Date | string
    updatedAt?: DateTimeFilter<"Procedure"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutClinicInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutClinicInput, AttendanceUncheckedUpdateWithoutClinicInput>
    create: XOR<AttendanceCreateWithoutClinicInput, AttendanceUncheckedCreateWithoutClinicInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutClinicInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutClinicInput, AttendanceUncheckedUpdateWithoutClinicInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutClinicInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutClinicInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    clinicId?: StringFilter<"Attendance"> | string
    appointmentId?: StringNullableFilter<"Attendance"> | string | null
    patientId?: StringFilter<"Attendance"> | string
    dentistId?: StringNullableFilter<"Attendance"> | string | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFilter<"Attendance"> | Date | string
    startedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdByRole?: EnumUserRoleFilter<"Attendance"> | $Enums.UserRole
    createdById?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type ClinicCreateWithoutUsersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutUsersInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>
  }

  export type DentistCreateWithoutUserInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutUserInput = {
    id?: string
    clinicId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutUserInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutUserInput, DentistUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    clinicId: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.InventoryMovementType
    quantity: number
    notes?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutInventoryMovementsInput
    item: InventoryItemCreateNestedOneWithoutMovementsInput
    appointment?: AppointmentCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutCreatedByInput = {
    id?: string
    clinicId: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutCreatedByInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutCreatedByInput, InventoryMovementUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryMovementCreateManyCreatedByInputEnvelope = {
    data: InventoryMovementCreateManyCreatedByInput | InventoryMovementCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutCreatedByInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutCreatedByInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutCreatedByInput, AttendanceUncheckedCreateWithoutCreatedByInput>
  }

  export type AttendanceCreateManyCreatedByInputEnvelope = {
    data: AttendanceCreateManyCreatedByInput | AttendanceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutUsersInput = {
    update: XOR<ClinicUpdateWithoutUsersInput, ClinicUncheckedUpdateWithoutUsersInput>
    create: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutUsersInput, ClinicUncheckedUpdateWithoutUsersInput>
  }

  export type ClinicUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type DentistUpsertWithoutUserInput = {
    update: XOR<DentistUpdateWithoutUserInput, DentistUncheckedUpdateWithoutUserInput>
    create: XOR<DentistCreateWithoutUserInput, DentistUncheckedCreateWithoutUserInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutUserInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutUserInput, DentistUncheckedUpdateWithoutUserInput>
  }

  export type DentistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutCreatedByInput, InventoryMovementUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InventoryMovementCreateWithoutCreatedByInput, InventoryMovementUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutCreatedByInput, InventoryMovementUncheckedUpdateWithoutCreatedByInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutCreatedByInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutCreatedByInput, AttendanceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AttendanceCreateWithoutCreatedByInput, AttendanceUncheckedCreateWithoutCreatedByInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutCreatedByInput, AttendanceUncheckedUpdateWithoutCreatedByInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutCreatedByInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ClinicCreateWithoutDentistsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutDentistsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutDentistsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutDentistsInput, ClinicUncheckedCreateWithoutDentistsInput>
  }

  export type UserCreateWithoutDentistInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutDentistInput = {
    id?: string
    clinicId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutDentistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDentistInput, UserUncheckedCreateWithoutDentistInput>
  }

  export type AppointmentCreateWithoutDentistInput = {
    id?: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    procedureRelation?: ProcedureCreateNestedOneWithoutAppointmentsInput
    record?: RecordCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDentistInput = {
    id?: string
    clinicId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    record?: RecordUncheckedCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDentistInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDentistInput, AppointmentUncheckedCreateWithoutDentistInput>
  }

  export type AppointmentCreateManyDentistInputEnvelope = {
    data: AppointmentCreateManyDentistInput | AppointmentCreateManyDentistInput[]
    skipDuplicates?: boolean
  }

  export type RecordCreateWithoutDentistInput = {
    id?: string
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutRecordsInput
    patient: PatientCreateNestedOneWithoutRecordsInput
    appointment?: AppointmentCreateNestedOneWithoutRecordInput
    attendance?: AttendanceCreateNestedOneWithoutRecordInput
  }

  export type RecordUncheckedCreateWithoutDentistInput = {
    id?: string
    clinicId: string
    patientId: string
    appointmentId?: string | null
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordCreateOrConnectWithoutDentistInput = {
    where: RecordWhereUniqueInput
    create: XOR<RecordCreateWithoutDentistInput, RecordUncheckedCreateWithoutDentistInput>
  }

  export type RecordCreateManyDentistInputEnvelope = {
    data: RecordCreateManyDentistInput | RecordCreateManyDentistInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentPlanCreateWithoutDentistInput = {
    id?: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutTreatmentPlansInput
    patient: PatientCreateNestedOneWithoutTreatmentPlansInput
    items?: TreatmentItemCreateNestedManyWithoutPlanInput
    paymentTreatmentPlans?: PaymentTreatmentPlanCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanUncheckedCreateWithoutDentistInput = {
    id?: string
    clinicId: string
    patientId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TreatmentItemUncheckedCreateNestedManyWithoutPlanInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanCreateOrConnectWithoutDentistInput = {
    where: TreatmentPlanWhereUniqueInput
    create: XOR<TreatmentPlanCreateWithoutDentistInput, TreatmentPlanUncheckedCreateWithoutDentistInput>
  }

  export type TreatmentPlanCreateManyDentistInputEnvelope = {
    data: TreatmentPlanCreateManyDentistInput | TreatmentPlanCreateManyDentistInput[]
    skipDuplicates?: boolean
  }

  export type DentistProcedureCreateWithoutDentistInput = {
    id?: string
    createdAt?: Date | string
    procedure: ProcedureCreateNestedOneWithoutDentistProceduresInput
  }

  export type DentistProcedureUncheckedCreateWithoutDentistInput = {
    id?: string
    procedureId: string
    createdAt?: Date | string
  }

  export type DentistProcedureCreateOrConnectWithoutDentistInput = {
    where: DentistProcedureWhereUniqueInput
    create: XOR<DentistProcedureCreateWithoutDentistInput, DentistProcedureUncheckedCreateWithoutDentistInput>
  }

  export type DentistProcedureCreateManyDentistInputEnvelope = {
    data: DentistProcedureCreateManyDentistInput | DentistProcedureCreateManyDentistInput[]
    skipDuplicates?: boolean
  }

  export type DentistSpecialtyCreateWithoutDentistInput = {
    id?: string
    createdAt?: Date | string
    specialty: SpecialtyCreateNestedOneWithoutDentistSpecialtiesInput
  }

  export type DentistSpecialtyUncheckedCreateWithoutDentistInput = {
    id?: string
    specialtyId: string
    createdAt?: Date | string
  }

  export type DentistSpecialtyCreateOrConnectWithoutDentistInput = {
    where: DentistSpecialtyWhereUniqueInput
    create: XOR<DentistSpecialtyCreateWithoutDentistInput, DentistSpecialtyUncheckedCreateWithoutDentistInput>
  }

  export type DentistSpecialtyCreateManyDentistInputEnvelope = {
    data: DentistSpecialtyCreateManyDentistInput | DentistSpecialtyCreateManyDentistInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutDentistInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutDentistInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutDentistInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutDentistInput, AttendanceUncheckedCreateWithoutDentistInput>
  }

  export type AttendanceCreateManyDentistInputEnvelope = {
    data: AttendanceCreateManyDentistInput | AttendanceCreateManyDentistInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCIDCreateWithoutCreatedByInput = {
    id?: string
    cidCode: string
    description: string
    observation?: string | null
    attendance: AttendanceCreateNestedOneWithoutCidsInput
  }

  export type AttendanceCIDUncheckedCreateWithoutCreatedByInput = {
    id?: string
    attendanceId: string
    cidCode: string
    description: string
    observation?: string | null
  }

  export type AttendanceCIDCreateOrConnectWithoutCreatedByInput = {
    where: AttendanceCIDWhereUniqueInput
    create: XOR<AttendanceCIDCreateWithoutCreatedByInput, AttendanceCIDUncheckedCreateWithoutCreatedByInput>
  }

  export type AttendanceCIDCreateManyCreatedByInputEnvelope = {
    data: AttendanceCIDCreateManyCreatedByInput | AttendanceCIDCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceProcedureCreateWithoutDentistInput = {
    id?: string
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance: AttendanceCreateNestedOneWithoutProceduresInput
    procedure?: ProcedureCreateNestedOneWithoutAttendanceProceduresInput
  }

  export type AttendanceProcedureUncheckedCreateWithoutDentistInput = {
    id?: string
    attendanceId: string
    procedureId?: string | null
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceProcedureCreateOrConnectWithoutDentistInput = {
    where: AttendanceProcedureWhereUniqueInput
    create: XOR<AttendanceProcedureCreateWithoutDentistInput, AttendanceProcedureUncheckedCreateWithoutDentistInput>
  }

  export type AttendanceProcedureCreateManyDentistInputEnvelope = {
    data: AttendanceProcedureCreateManyDentistInput | AttendanceProcedureCreateManyDentistInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutDentistsInput = {
    update: XOR<ClinicUpdateWithoutDentistsInput, ClinicUncheckedUpdateWithoutDentistsInput>
    create: XOR<ClinicCreateWithoutDentistsInput, ClinicUncheckedCreateWithoutDentistsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutDentistsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutDentistsInput, ClinicUncheckedUpdateWithoutDentistsInput>
  }

  export type ClinicUpdateWithoutDentistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutDentistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type UserUpsertWithoutDentistInput = {
    update: XOR<UserUpdateWithoutDentistInput, UserUncheckedUpdateWithoutDentistInput>
    create: XOR<UserCreateWithoutDentistInput, UserUncheckedCreateWithoutDentistInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDentistInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDentistInput, UserUncheckedUpdateWithoutDentistInput>
  }

  export type UserUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDentistInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDentistInput, AppointmentUncheckedUpdateWithoutDentistInput>
    create: XOR<AppointmentCreateWithoutDentistInput, AppointmentUncheckedCreateWithoutDentistInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDentistInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDentistInput, AppointmentUncheckedUpdateWithoutDentistInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDentistInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDentistInput>
  }

  export type RecordUpsertWithWhereUniqueWithoutDentistInput = {
    where: RecordWhereUniqueInput
    update: XOR<RecordUpdateWithoutDentistInput, RecordUncheckedUpdateWithoutDentistInput>
    create: XOR<RecordCreateWithoutDentistInput, RecordUncheckedCreateWithoutDentistInput>
  }

  export type RecordUpdateWithWhereUniqueWithoutDentistInput = {
    where: RecordWhereUniqueInput
    data: XOR<RecordUpdateWithoutDentistInput, RecordUncheckedUpdateWithoutDentistInput>
  }

  export type RecordUpdateManyWithWhereWithoutDentistInput = {
    where: RecordScalarWhereInput
    data: XOR<RecordUpdateManyMutationInput, RecordUncheckedUpdateManyWithoutDentistInput>
  }

  export type TreatmentPlanUpsertWithWhereUniqueWithoutDentistInput = {
    where: TreatmentPlanWhereUniqueInput
    update: XOR<TreatmentPlanUpdateWithoutDentistInput, TreatmentPlanUncheckedUpdateWithoutDentistInput>
    create: XOR<TreatmentPlanCreateWithoutDentistInput, TreatmentPlanUncheckedCreateWithoutDentistInput>
  }

  export type TreatmentPlanUpdateWithWhereUniqueWithoutDentistInput = {
    where: TreatmentPlanWhereUniqueInput
    data: XOR<TreatmentPlanUpdateWithoutDentistInput, TreatmentPlanUncheckedUpdateWithoutDentistInput>
  }

  export type TreatmentPlanUpdateManyWithWhereWithoutDentistInput = {
    where: TreatmentPlanScalarWhereInput
    data: XOR<TreatmentPlanUpdateManyMutationInput, TreatmentPlanUncheckedUpdateManyWithoutDentistInput>
  }

  export type DentistProcedureUpsertWithWhereUniqueWithoutDentistInput = {
    where: DentistProcedureWhereUniqueInput
    update: XOR<DentistProcedureUpdateWithoutDentistInput, DentistProcedureUncheckedUpdateWithoutDentistInput>
    create: XOR<DentistProcedureCreateWithoutDentistInput, DentistProcedureUncheckedCreateWithoutDentistInput>
  }

  export type DentistProcedureUpdateWithWhereUniqueWithoutDentistInput = {
    where: DentistProcedureWhereUniqueInput
    data: XOR<DentistProcedureUpdateWithoutDentistInput, DentistProcedureUncheckedUpdateWithoutDentistInput>
  }

  export type DentistProcedureUpdateManyWithWhereWithoutDentistInput = {
    where: DentistProcedureScalarWhereInput
    data: XOR<DentistProcedureUpdateManyMutationInput, DentistProcedureUncheckedUpdateManyWithoutDentistInput>
  }

  export type DentistProcedureScalarWhereInput = {
    AND?: DentistProcedureScalarWhereInput | DentistProcedureScalarWhereInput[]
    OR?: DentistProcedureScalarWhereInput[]
    NOT?: DentistProcedureScalarWhereInput | DentistProcedureScalarWhereInput[]
    id?: StringFilter<"DentistProcedure"> | string
    dentistId?: StringFilter<"DentistProcedure"> | string
    procedureId?: StringFilter<"DentistProcedure"> | string
    createdAt?: DateTimeFilter<"DentistProcedure"> | Date | string
  }

  export type DentistSpecialtyUpsertWithWhereUniqueWithoutDentistInput = {
    where: DentistSpecialtyWhereUniqueInput
    update: XOR<DentistSpecialtyUpdateWithoutDentistInput, DentistSpecialtyUncheckedUpdateWithoutDentistInput>
    create: XOR<DentistSpecialtyCreateWithoutDentistInput, DentistSpecialtyUncheckedCreateWithoutDentistInput>
  }

  export type DentistSpecialtyUpdateWithWhereUniqueWithoutDentistInput = {
    where: DentistSpecialtyWhereUniqueInput
    data: XOR<DentistSpecialtyUpdateWithoutDentistInput, DentistSpecialtyUncheckedUpdateWithoutDentistInput>
  }

  export type DentistSpecialtyUpdateManyWithWhereWithoutDentistInput = {
    where: DentistSpecialtyScalarWhereInput
    data: XOR<DentistSpecialtyUpdateManyMutationInput, DentistSpecialtyUncheckedUpdateManyWithoutDentistInput>
  }

  export type DentistSpecialtyScalarWhereInput = {
    AND?: DentistSpecialtyScalarWhereInput | DentistSpecialtyScalarWhereInput[]
    OR?: DentistSpecialtyScalarWhereInput[]
    NOT?: DentistSpecialtyScalarWhereInput | DentistSpecialtyScalarWhereInput[]
    id?: StringFilter<"DentistSpecialty"> | string
    dentistId?: StringFilter<"DentistSpecialty"> | string
    specialtyId?: StringFilter<"DentistSpecialty"> | string
    createdAt?: DateTimeFilter<"DentistSpecialty"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutDentistInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutDentistInput, AttendanceUncheckedUpdateWithoutDentistInput>
    create: XOR<AttendanceCreateWithoutDentistInput, AttendanceUncheckedCreateWithoutDentistInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutDentistInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutDentistInput, AttendanceUncheckedUpdateWithoutDentistInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutDentistInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutDentistInput>
  }

  export type AttendanceCIDUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AttendanceCIDWhereUniqueInput
    update: XOR<AttendanceCIDUpdateWithoutCreatedByInput, AttendanceCIDUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AttendanceCIDCreateWithoutCreatedByInput, AttendanceCIDUncheckedCreateWithoutCreatedByInput>
  }

  export type AttendanceCIDUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AttendanceCIDWhereUniqueInput
    data: XOR<AttendanceCIDUpdateWithoutCreatedByInput, AttendanceCIDUncheckedUpdateWithoutCreatedByInput>
  }

  export type AttendanceCIDUpdateManyWithWhereWithoutCreatedByInput = {
    where: AttendanceCIDScalarWhereInput
    data: XOR<AttendanceCIDUpdateManyMutationInput, AttendanceCIDUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AttendanceCIDScalarWhereInput = {
    AND?: AttendanceCIDScalarWhereInput | AttendanceCIDScalarWhereInput[]
    OR?: AttendanceCIDScalarWhereInput[]
    NOT?: AttendanceCIDScalarWhereInput | AttendanceCIDScalarWhereInput[]
    id?: StringFilter<"AttendanceCID"> | string
    attendanceId?: StringFilter<"AttendanceCID"> | string
    cidCode?: StringFilter<"AttendanceCID"> | string
    description?: StringFilter<"AttendanceCID"> | string
    observation?: StringNullableFilter<"AttendanceCID"> | string | null
    createdByDentistId?: StringFilter<"AttendanceCID"> | string
  }

  export type AttendanceProcedureUpsertWithWhereUniqueWithoutDentistInput = {
    where: AttendanceProcedureWhereUniqueInput
    update: XOR<AttendanceProcedureUpdateWithoutDentistInput, AttendanceProcedureUncheckedUpdateWithoutDentistInput>
    create: XOR<AttendanceProcedureCreateWithoutDentistInput, AttendanceProcedureUncheckedCreateWithoutDentistInput>
  }

  export type AttendanceProcedureUpdateWithWhereUniqueWithoutDentistInput = {
    where: AttendanceProcedureWhereUniqueInput
    data: XOR<AttendanceProcedureUpdateWithoutDentistInput, AttendanceProcedureUncheckedUpdateWithoutDentistInput>
  }

  export type AttendanceProcedureUpdateManyWithWhereWithoutDentistInput = {
    where: AttendanceProcedureScalarWhereInput
    data: XOR<AttendanceProcedureUpdateManyMutationInput, AttendanceProcedureUncheckedUpdateManyWithoutDentistInput>
  }

  export type AttendanceProcedureScalarWhereInput = {
    AND?: AttendanceProcedureScalarWhereInput | AttendanceProcedureScalarWhereInput[]
    OR?: AttendanceProcedureScalarWhereInput[]
    NOT?: AttendanceProcedureScalarWhereInput | AttendanceProcedureScalarWhereInput[]
    id?: StringFilter<"AttendanceProcedure"> | string
    attendanceId?: StringFilter<"AttendanceProcedure"> | string
    procedureId?: StringNullableFilter<"AttendanceProcedure"> | string | null
    procedureCode?: StringNullableFilter<"AttendanceProcedure"> | string | null
    description?: StringFilter<"AttendanceProcedure"> | string
    tooth?: StringNullableFilter<"AttendanceProcedure"> | string | null
    surface?: StringNullableFilter<"AttendanceProcedure"> | string | null
    faces?: StringNullableListFilter<"AttendanceProcedure">
    quantity?: IntFilter<"AttendanceProcedure"> | number
    clinicalStatus?: StringNullableFilter<"AttendanceProcedure"> | string | null
    price?: DecimalNullableFilter<"AttendanceProcedure"> | Decimal | DecimalJsLike | number | string | null
    dentistId?: StringNullableFilter<"AttendanceProcedure"> | string | null
    observations?: StringNullableFilter<"AttendanceProcedure"> | string | null
    createdAt?: DateTimeFilter<"AttendanceProcedure"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceProcedure"> | Date | string
  }

  export type ClinicCreateWithoutPatientsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutPatientsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutPatientsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAppointmentsInput
    dentist: DentistCreateNestedOneWithoutAppointmentsInput
    procedureRelation?: ProcedureCreateNestedOneWithoutAppointmentsInput
    record?: RecordCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId: string
    dentistId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    record?: RecordUncheckedCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RecordCreateWithoutPatientInput = {
    id?: string
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutRecordsInput
    dentist: DentistCreateNestedOneWithoutRecordsInput
    appointment?: AppointmentCreateNestedOneWithoutRecordInput
    attendance?: AttendanceCreateNestedOneWithoutRecordInput
  }

  export type RecordUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId: string
    dentistId: string
    appointmentId?: string | null
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordCreateOrConnectWithoutPatientInput = {
    where: RecordWhereUniqueInput
    create: XOR<RecordCreateWithoutPatientInput, RecordUncheckedCreateWithoutPatientInput>
  }

  export type RecordCreateManyPatientInputEnvelope = {
    data: RecordCreateManyPatientInput | RecordCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentPlanCreateWithoutPatientInput = {
    id?: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutTreatmentPlansInput
    dentist: DentistCreateNestedOneWithoutTreatmentPlansInput
    items?: TreatmentItemCreateNestedManyWithoutPlanInput
    paymentTreatmentPlans?: PaymentTreatmentPlanCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId: string
    dentistId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TreatmentItemUncheckedCreateNestedManyWithoutPlanInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanCreateOrConnectWithoutPatientInput = {
    where: TreatmentPlanWhereUniqueInput
    create: XOR<TreatmentPlanCreateWithoutPatientInput, TreatmentPlanUncheckedCreateWithoutPatientInput>
  }

  export type TreatmentPlanCreateManyPatientInputEnvelope = {
    data: TreatmentPlanCreateManyPatientInput | TreatmentPlanCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPatientInput = {
    id?: string
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPaymentsInput
    paymentTreatmentPlans?: PaymentTreatmentPlanCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId: string
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput>
  }

  export type PaymentCreateManyPatientInputEnvelope = {
    data: PaymentCreateManyPatientInput | PaymentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutPatientInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutPatientInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutPatientInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutPatientInput, AttendanceUncheckedCreateWithoutPatientInput>
  }

  export type AttendanceCreateManyPatientInputEnvelope = {
    data: AttendanceCreateManyPatientInput | AttendanceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutPatientsInput = {
    update: XOR<ClinicUpdateWithoutPatientsInput, ClinicUncheckedUpdateWithoutPatientsInput>
    create: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutPatientsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutPatientsInput, ClinicUncheckedUpdateWithoutPatientsInput>
  }

  export type ClinicUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type RecordUpsertWithWhereUniqueWithoutPatientInput = {
    where: RecordWhereUniqueInput
    update: XOR<RecordUpdateWithoutPatientInput, RecordUncheckedUpdateWithoutPatientInput>
    create: XOR<RecordCreateWithoutPatientInput, RecordUncheckedCreateWithoutPatientInput>
  }

  export type RecordUpdateWithWhereUniqueWithoutPatientInput = {
    where: RecordWhereUniqueInput
    data: XOR<RecordUpdateWithoutPatientInput, RecordUncheckedUpdateWithoutPatientInput>
  }

  export type RecordUpdateManyWithWhereWithoutPatientInput = {
    where: RecordScalarWhereInput
    data: XOR<RecordUpdateManyMutationInput, RecordUncheckedUpdateManyWithoutPatientInput>
  }

  export type TreatmentPlanUpsertWithWhereUniqueWithoutPatientInput = {
    where: TreatmentPlanWhereUniqueInput
    update: XOR<TreatmentPlanUpdateWithoutPatientInput, TreatmentPlanUncheckedUpdateWithoutPatientInput>
    create: XOR<TreatmentPlanCreateWithoutPatientInput, TreatmentPlanUncheckedCreateWithoutPatientInput>
  }

  export type TreatmentPlanUpdateWithWhereUniqueWithoutPatientInput = {
    where: TreatmentPlanWhereUniqueInput
    data: XOR<TreatmentPlanUpdateWithoutPatientInput, TreatmentPlanUncheckedUpdateWithoutPatientInput>
  }

  export type TreatmentPlanUpdateManyWithWhereWithoutPatientInput = {
    where: TreatmentPlanScalarWhereInput
    data: XOR<TreatmentPlanUpdateManyMutationInput, TreatmentPlanUncheckedUpdateManyWithoutPatientInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPatientInput, PaymentUncheckedUpdateWithoutPatientInput>
    create: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPatientInput, PaymentUncheckedUpdateWithoutPatientInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPatientInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPatientInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutPatientInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutPatientInput, AttendanceUncheckedUpdateWithoutPatientInput>
    create: XOR<AttendanceCreateWithoutPatientInput, AttendanceUncheckedCreateWithoutPatientInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutPatientInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutPatientInput, AttendanceUncheckedUpdateWithoutPatientInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutPatientInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutPatientInput>
  }

  export type ClinicCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutAppointmentsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutAppointmentsInput, ClinicUncheckedCreateWithoutAppointmentsInput>
  }

  export type DentistCreateWithoutAppointmentsInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutAppointmentsInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutAppointmentsInput, DentistUncheckedCreateWithoutAppointmentsInput>
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    records?: RecordCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    attendances?: AttendanceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    clinicId: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: RecordUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type ProcedureCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutProceduresInput
    specialty: SpecialtyCreateNestedOneWithoutProceduresInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutProcedureInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    clinicId: string
    specialtyId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutProcedureInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutAppointmentsInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutAppointmentsInput, ProcedureUncheckedCreateWithoutAppointmentsInput>
  }

  export type RecordCreateWithoutAppointmentInput = {
    id?: string
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutRecordsInput
    patient: PatientCreateNestedOneWithoutRecordsInput
    dentist: DentistCreateNestedOneWithoutRecordsInput
    attendance?: AttendanceCreateNestedOneWithoutRecordInput
  }

  export type RecordUncheckedCreateWithoutAppointmentInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId: string
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordCreateOrConnectWithoutAppointmentInput = {
    where: RecordWhereUniqueInput
    create: XOR<RecordCreateWithoutAppointmentInput, RecordUncheckedCreateWithoutAppointmentInput>
  }

  export type InventoryMovementCreateWithoutAppointmentInput = {
    id?: string
    type: $Enums.InventoryMovementType
    quantity: number
    notes?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutInventoryMovementsInput
    item: InventoryItemCreateNestedOneWithoutMovementsInput
    createdBy: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutAppointmentInput = {
    id?: string
    clinicId: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    createdById: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutAppointmentInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutAppointmentInput, InventoryMovementUncheckedCreateWithoutAppointmentInput>
  }

  export type InventoryMovementCreateManyAppointmentInputEnvelope = {
    data: InventoryMovementCreateManyAppointmentInput | InventoryMovementCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutAppointmentInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutAppointmentInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutAppointmentInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutAppointmentInput, AttendanceUncheckedCreateWithoutAppointmentInput>
  }

  export type ClinicUpsertWithoutAppointmentsInput = {
    update: XOR<ClinicUpdateWithoutAppointmentsInput, ClinicUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ClinicCreateWithoutAppointmentsInput, ClinicUncheckedCreateWithoutAppointmentsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutAppointmentsInput, ClinicUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClinicUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type DentistUpsertWithoutAppointmentsInput = {
    update: XOR<DentistUpdateWithoutAppointmentsInput, DentistUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DentistCreateWithoutAppointmentsInput, DentistUncheckedCreateWithoutAppointmentsInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutAppointmentsInput, DentistUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DentistUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    records?: RecordUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: RecordUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ProcedureUpsertWithoutAppointmentsInput = {
    update: XOR<ProcedureUpdateWithoutAppointmentsInput, ProcedureUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ProcedureCreateWithoutAppointmentsInput, ProcedureUncheckedCreateWithoutAppointmentsInput>
    where?: ProcedureWhereInput
  }

  export type ProcedureUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ProcedureWhereInput
    data: XOR<ProcedureUpdateWithoutAppointmentsInput, ProcedureUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ProcedureUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutProceduresNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutProceduresNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutProcedureNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type RecordUpsertWithoutAppointmentInput = {
    update: XOR<RecordUpdateWithoutAppointmentInput, RecordUncheckedUpdateWithoutAppointmentInput>
    create: XOR<RecordCreateWithoutAppointmentInput, RecordUncheckedCreateWithoutAppointmentInput>
    where?: RecordWhereInput
  }

  export type RecordUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: RecordWhereInput
    data: XOR<RecordUpdateWithoutAppointmentInput, RecordUncheckedUpdateWithoutAppointmentInput>
  }

  export type RecordUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutRecordsNestedInput
    patient?: PatientUpdateOneRequiredWithoutRecordsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutRecordsNestedInput
    attendance?: AttendanceUpdateOneWithoutRecordNestedInput
  }

  export type RecordUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutAppointmentInput, InventoryMovementUncheckedUpdateWithoutAppointmentInput>
    create: XOR<InventoryMovementCreateWithoutAppointmentInput, InventoryMovementUncheckedCreateWithoutAppointmentInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutAppointmentInput, InventoryMovementUncheckedUpdateWithoutAppointmentInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutAppointmentInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type AttendanceUpsertWithoutAppointmentInput = {
    update: XOR<AttendanceUpdateWithoutAppointmentInput, AttendanceUncheckedUpdateWithoutAppointmentInput>
    create: XOR<AttendanceCreateWithoutAppointmentInput, AttendanceUncheckedCreateWithoutAppointmentInput>
    where?: AttendanceWhereInput
  }

  export type AttendanceUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: AttendanceWhereInput
    data: XOR<AttendanceUpdateWithoutAppointmentInput, AttendanceUncheckedUpdateWithoutAppointmentInput>
  }

  export type AttendanceUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type ClinicCreateWithoutRecordsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutRecordsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutRecordsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutRecordsInput, ClinicUncheckedCreateWithoutRecordsInput>
  }

  export type PatientCreateWithoutRecordsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    attendances?: AttendanceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutRecordsInput = {
    id?: string
    clinicId: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRecordsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRecordsInput, PatientUncheckedCreateWithoutRecordsInput>
  }

  export type DentistCreateWithoutRecordsInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutRecordsInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutRecordsInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutRecordsInput, DentistUncheckedCreateWithoutRecordsInput>
  }

  export type AppointmentCreateWithoutRecordInput = {
    id?: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAppointmentsInput
    dentist: DentistCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    procedureRelation?: ProcedureCreateNestedOneWithoutAppointmentsInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutRecordInput = {
    id?: string
    clinicId: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutRecordInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutRecordInput, AppointmentUncheckedCreateWithoutRecordInput>
  }

  export type AttendanceCreateWithoutRecordInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutRecordInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutRecordInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutRecordInput, AttendanceUncheckedCreateWithoutRecordInput>
  }

  export type ClinicUpsertWithoutRecordsInput = {
    update: XOR<ClinicUpdateWithoutRecordsInput, ClinicUncheckedUpdateWithoutRecordsInput>
    create: XOR<ClinicCreateWithoutRecordsInput, ClinicUncheckedCreateWithoutRecordsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutRecordsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutRecordsInput, ClinicUncheckedUpdateWithoutRecordsInput>
  }

  export type ClinicUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutRecordsInput = {
    update: XOR<PatientUpdateWithoutRecordsInput, PatientUncheckedUpdateWithoutRecordsInput>
    create: XOR<PatientCreateWithoutRecordsInput, PatientUncheckedCreateWithoutRecordsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRecordsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRecordsInput, PatientUncheckedUpdateWithoutRecordsInput>
  }

  export type PatientUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DentistUpsertWithoutRecordsInput = {
    update: XOR<DentistUpdateWithoutRecordsInput, DentistUncheckedUpdateWithoutRecordsInput>
    create: XOR<DentistCreateWithoutRecordsInput, DentistUncheckedCreateWithoutRecordsInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutRecordsInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutRecordsInput, DentistUncheckedUpdateWithoutRecordsInput>
  }

  export type DentistUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type AppointmentUpsertWithoutRecordInput = {
    update: XOR<AppointmentUpdateWithoutRecordInput, AppointmentUncheckedUpdateWithoutRecordInput>
    create: XOR<AppointmentCreateWithoutRecordInput, AppointmentUncheckedCreateWithoutRecordInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutRecordInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutRecordInput, AppointmentUncheckedUpdateWithoutRecordInput>
  }

  export type AppointmentUpdateWithoutRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAppointmentsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    procedureRelation?: ProcedureUpdateOneWithoutAppointmentsNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AttendanceUpsertWithoutRecordInput = {
    update: XOR<AttendanceUpdateWithoutRecordInput, AttendanceUncheckedUpdateWithoutRecordInput>
    create: XOR<AttendanceCreateWithoutRecordInput, AttendanceUncheckedCreateWithoutRecordInput>
    where?: AttendanceWhereInput
  }

  export type AttendanceUpdateToOneWithWhereWithoutRecordInput = {
    where?: AttendanceWhereInput
    data: XOR<AttendanceUpdateWithoutRecordInput, AttendanceUncheckedUpdateWithoutRecordInput>
  }

  export type AttendanceUpdateWithoutRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
  }

  export type ClinicCreateWithoutTreatmentPlansInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutTreatmentPlansInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutTreatmentPlansInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutTreatmentPlansInput, ClinicUncheckedCreateWithoutTreatmentPlansInput>
  }

  export type PatientCreateWithoutTreatmentPlansInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    records?: RecordCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    attendances?: AttendanceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTreatmentPlansInput = {
    id?: string
    clinicId: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    records?: RecordUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTreatmentPlansInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTreatmentPlansInput, PatientUncheckedCreateWithoutTreatmentPlansInput>
  }

  export type DentistCreateWithoutTreatmentPlansInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutTreatmentPlansInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutTreatmentPlansInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutTreatmentPlansInput, DentistUncheckedCreateWithoutTreatmentPlansInput>
  }

  export type TreatmentItemCreateWithoutPlanInput = {
    id?: string
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
    procedure?: ProcedureCreateNestedOneWithoutTreatmentItemsInput
  }

  export type TreatmentItemUncheckedCreateWithoutPlanInput = {
    id?: string
    procedureId?: string | null
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TreatmentItemCreateOrConnectWithoutPlanInput = {
    where: TreatmentItemWhereUniqueInput
    create: XOR<TreatmentItemCreateWithoutPlanInput, TreatmentItemUncheckedCreateWithoutPlanInput>
  }

  export type TreatmentItemCreateManyPlanInputEnvelope = {
    data: TreatmentItemCreateManyPlanInput | TreatmentItemCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PaymentTreatmentPlanCreateWithoutTreatmentPlanInput = {
    id?: string
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutPaymentTreatmentPlansInput
  }

  export type PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput = {
    id?: string
    paymentId: string
    createdAt?: Date | string
  }

  export type PaymentTreatmentPlanCreateOrConnectWithoutTreatmentPlanInput = {
    where: PaymentTreatmentPlanWhereUniqueInput
    create: XOR<PaymentTreatmentPlanCreateWithoutTreatmentPlanInput, PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput>
  }

  export type PaymentTreatmentPlanCreateManyTreatmentPlanInputEnvelope = {
    data: PaymentTreatmentPlanCreateManyTreatmentPlanInput | PaymentTreatmentPlanCreateManyTreatmentPlanInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutTreatmentPlansInput = {
    update: XOR<ClinicUpdateWithoutTreatmentPlansInput, ClinicUncheckedUpdateWithoutTreatmentPlansInput>
    create: XOR<ClinicCreateWithoutTreatmentPlansInput, ClinicUncheckedCreateWithoutTreatmentPlansInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutTreatmentPlansInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutTreatmentPlansInput, ClinicUncheckedUpdateWithoutTreatmentPlansInput>
  }

  export type ClinicUpdateWithoutTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutTreatmentPlansInput = {
    update: XOR<PatientUpdateWithoutTreatmentPlansInput, PatientUncheckedUpdateWithoutTreatmentPlansInput>
    create: XOR<PatientCreateWithoutTreatmentPlansInput, PatientUncheckedCreateWithoutTreatmentPlansInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutTreatmentPlansInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutTreatmentPlansInput, PatientUncheckedUpdateWithoutTreatmentPlansInput>
  }

  export type PatientUpdateWithoutTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    records?: RecordUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    records?: RecordUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DentistUpsertWithoutTreatmentPlansInput = {
    update: XOR<DentistUpdateWithoutTreatmentPlansInput, DentistUncheckedUpdateWithoutTreatmentPlansInput>
    create: XOR<DentistCreateWithoutTreatmentPlansInput, DentistUncheckedCreateWithoutTreatmentPlansInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutTreatmentPlansInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutTreatmentPlansInput, DentistUncheckedUpdateWithoutTreatmentPlansInput>
  }

  export type DentistUpdateWithoutTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type TreatmentItemUpsertWithWhereUniqueWithoutPlanInput = {
    where: TreatmentItemWhereUniqueInput
    update: XOR<TreatmentItemUpdateWithoutPlanInput, TreatmentItemUncheckedUpdateWithoutPlanInput>
    create: XOR<TreatmentItemCreateWithoutPlanInput, TreatmentItemUncheckedCreateWithoutPlanInput>
  }

  export type TreatmentItemUpdateWithWhereUniqueWithoutPlanInput = {
    where: TreatmentItemWhereUniqueInput
    data: XOR<TreatmentItemUpdateWithoutPlanInput, TreatmentItemUncheckedUpdateWithoutPlanInput>
  }

  export type TreatmentItemUpdateManyWithWhereWithoutPlanInput = {
    where: TreatmentItemScalarWhereInput
    data: XOR<TreatmentItemUpdateManyMutationInput, TreatmentItemUncheckedUpdateManyWithoutPlanInput>
  }

  export type TreatmentItemScalarWhereInput = {
    AND?: TreatmentItemScalarWhereInput | TreatmentItemScalarWhereInput[]
    OR?: TreatmentItemScalarWhereInput[]
    NOT?: TreatmentItemScalarWhereInput | TreatmentItemScalarWhereInput[]
    id?: StringFilter<"TreatmentItem"> | string
    planId?: StringFilter<"TreatmentItem"> | string
    procedureId?: StringNullableFilter<"TreatmentItem"> | string | null
    description?: StringFilter<"TreatmentItem"> | string
    tooth?: StringNullableFilter<"TreatmentItem"> | string | null
    value?: DecimalFilter<"TreatmentItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"TreatmentItem"> | number
  }

  export type PaymentTreatmentPlanUpsertWithWhereUniqueWithoutTreatmentPlanInput = {
    where: PaymentTreatmentPlanWhereUniqueInput
    update: XOR<PaymentTreatmentPlanUpdateWithoutTreatmentPlanInput, PaymentTreatmentPlanUncheckedUpdateWithoutTreatmentPlanInput>
    create: XOR<PaymentTreatmentPlanCreateWithoutTreatmentPlanInput, PaymentTreatmentPlanUncheckedCreateWithoutTreatmentPlanInput>
  }

  export type PaymentTreatmentPlanUpdateWithWhereUniqueWithoutTreatmentPlanInput = {
    where: PaymentTreatmentPlanWhereUniqueInput
    data: XOR<PaymentTreatmentPlanUpdateWithoutTreatmentPlanInput, PaymentTreatmentPlanUncheckedUpdateWithoutTreatmentPlanInput>
  }

  export type PaymentTreatmentPlanUpdateManyWithWhereWithoutTreatmentPlanInput = {
    where: PaymentTreatmentPlanScalarWhereInput
    data: XOR<PaymentTreatmentPlanUpdateManyMutationInput, PaymentTreatmentPlanUncheckedUpdateManyWithoutTreatmentPlanInput>
  }

  export type PaymentTreatmentPlanScalarWhereInput = {
    AND?: PaymentTreatmentPlanScalarWhereInput | PaymentTreatmentPlanScalarWhereInput[]
    OR?: PaymentTreatmentPlanScalarWhereInput[]
    NOT?: PaymentTreatmentPlanScalarWhereInput | PaymentTreatmentPlanScalarWhereInput[]
    id?: StringFilter<"PaymentTreatmentPlan"> | string
    paymentId?: StringFilter<"PaymentTreatmentPlan"> | string
    treatmentPlanId?: StringFilter<"PaymentTreatmentPlan"> | string
    createdAt?: DateTimeFilter<"PaymentTreatmentPlan"> | Date | string
  }

  export type TreatmentPlanCreateWithoutItemsInput = {
    id?: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutTreatmentPlansInput
    patient: PatientCreateNestedOneWithoutTreatmentPlansInput
    dentist: DentistCreateNestedOneWithoutTreatmentPlansInput
    paymentTreatmentPlans?: PaymentTreatmentPlanCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanUncheckedCreateWithoutItemsInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedCreateNestedManyWithoutTreatmentPlanInput
  }

  export type TreatmentPlanCreateOrConnectWithoutItemsInput = {
    where: TreatmentPlanWhereUniqueInput
    create: XOR<TreatmentPlanCreateWithoutItemsInput, TreatmentPlanUncheckedCreateWithoutItemsInput>
  }

  export type ProcedureCreateWithoutTreatmentItemsInput = {
    id?: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutProceduresInput
    specialty: SpecialtyCreateNestedOneWithoutProceduresInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutTreatmentItemsInput = {
    id?: string
    clinicId: string
    specialtyId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutTreatmentItemsInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutTreatmentItemsInput, ProcedureUncheckedCreateWithoutTreatmentItemsInput>
  }

  export type TreatmentPlanUpsertWithoutItemsInput = {
    update: XOR<TreatmentPlanUpdateWithoutItemsInput, TreatmentPlanUncheckedUpdateWithoutItemsInput>
    create: XOR<TreatmentPlanCreateWithoutItemsInput, TreatmentPlanUncheckedCreateWithoutItemsInput>
    where?: TreatmentPlanWhereInput
  }

  export type TreatmentPlanUpdateToOneWithWhereWithoutItemsInput = {
    where?: TreatmentPlanWhereInput
    data: XOR<TreatmentPlanUpdateWithoutItemsInput, TreatmentPlanUncheckedUpdateWithoutItemsInput>
  }

  export type TreatmentPlanUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutTreatmentPlansNestedInput
    patient?: PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput
    dentist?: DentistUpdateOneRequiredWithoutTreatmentPlansNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type ProcedureUpsertWithoutTreatmentItemsInput = {
    update: XOR<ProcedureUpdateWithoutTreatmentItemsInput, ProcedureUncheckedUpdateWithoutTreatmentItemsInput>
    create: XOR<ProcedureCreateWithoutTreatmentItemsInput, ProcedureUncheckedCreateWithoutTreatmentItemsInput>
    where?: ProcedureWhereInput
  }

  export type ProcedureUpdateToOneWithWhereWithoutTreatmentItemsInput = {
    where?: ProcedureWhereInput
    data: XOR<ProcedureUpdateWithoutTreatmentItemsInput, ProcedureUncheckedUpdateWithoutTreatmentItemsInput>
  }

  export type ProcedureUpdateWithoutTreatmentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutProceduresNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutProceduresNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutTreatmentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ClinicCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutPaymentsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutPaymentsInput, ClinicUncheckedCreateWithoutPaymentsInput>
  }

  export type PatientCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    records?: RecordCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutPatientInput
    attendances?: AttendanceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPaymentsInput = {
    id?: string
    clinicId: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    records?: RecordUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutPatientInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPaymentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentTreatmentPlanCreateWithoutPaymentInput = {
    id?: string
    createdAt?: Date | string
    treatmentPlan: TreatmentPlanCreateNestedOneWithoutPaymentTreatmentPlansInput
  }

  export type PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput = {
    id?: string
    treatmentPlanId: string
    createdAt?: Date | string
  }

  export type PaymentTreatmentPlanCreateOrConnectWithoutPaymentInput = {
    where: PaymentTreatmentPlanWhereUniqueInput
    create: XOR<PaymentTreatmentPlanCreateWithoutPaymentInput, PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentTreatmentPlanCreateManyPaymentInputEnvelope = {
    data: PaymentTreatmentPlanCreateManyPaymentInput | PaymentTreatmentPlanCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutPaymentsInput = {
    update: XOR<ClinicUpdateWithoutPaymentsInput, ClinicUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ClinicCreateWithoutPaymentsInput, ClinicUncheckedCreateWithoutPaymentsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutPaymentsInput, ClinicUncheckedUpdateWithoutPaymentsInput>
  }

  export type ClinicUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutPaymentsInput = {
    update: XOR<PatientUpdateWithoutPaymentsInput, PatientUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPaymentsInput, PatientUncheckedUpdateWithoutPaymentsInput>
  }

  export type PatientUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    records?: RecordUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    records?: RecordUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PaymentTreatmentPlanUpsertWithWhereUniqueWithoutPaymentInput = {
    where: PaymentTreatmentPlanWhereUniqueInput
    update: XOR<PaymentTreatmentPlanUpdateWithoutPaymentInput, PaymentTreatmentPlanUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentTreatmentPlanCreateWithoutPaymentInput, PaymentTreatmentPlanUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentTreatmentPlanUpdateWithWhereUniqueWithoutPaymentInput = {
    where: PaymentTreatmentPlanWhereUniqueInput
    data: XOR<PaymentTreatmentPlanUpdateWithoutPaymentInput, PaymentTreatmentPlanUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentTreatmentPlanUpdateManyWithWhereWithoutPaymentInput = {
    where: PaymentTreatmentPlanScalarWhereInput
    data: XOR<PaymentTreatmentPlanUpdateManyMutationInput, PaymentTreatmentPlanUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentCreateWithoutPaymentTreatmentPlansInput = {
    id?: string
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPaymentsInput
    patient?: PatientCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutPaymentTreatmentPlansInput = {
    id?: string
    clinicId: string
    patientId?: string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutPaymentTreatmentPlansInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaymentTreatmentPlansInput, PaymentUncheckedCreateWithoutPaymentTreatmentPlansInput>
  }

  export type TreatmentPlanCreateWithoutPaymentTreatmentPlansInput = {
    id?: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutTreatmentPlansInput
    patient: PatientCreateNestedOneWithoutTreatmentPlansInput
    dentist: DentistCreateNestedOneWithoutTreatmentPlansInput
    items?: TreatmentItemCreateNestedManyWithoutPlanInput
  }

  export type TreatmentPlanUncheckedCreateWithoutPaymentTreatmentPlansInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TreatmentItemUncheckedCreateNestedManyWithoutPlanInput
  }

  export type TreatmentPlanCreateOrConnectWithoutPaymentTreatmentPlansInput = {
    where: TreatmentPlanWhereUniqueInput
    create: XOR<TreatmentPlanCreateWithoutPaymentTreatmentPlansInput, TreatmentPlanUncheckedCreateWithoutPaymentTreatmentPlansInput>
  }

  export type PaymentUpsertWithoutPaymentTreatmentPlansInput = {
    update: XOR<PaymentUpdateWithoutPaymentTreatmentPlansInput, PaymentUncheckedUpdateWithoutPaymentTreatmentPlansInput>
    create: XOR<PaymentCreateWithoutPaymentTreatmentPlansInput, PaymentUncheckedCreateWithoutPaymentTreatmentPlansInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutPaymentTreatmentPlansInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutPaymentTreatmentPlansInput, PaymentUncheckedUpdateWithoutPaymentTreatmentPlansInput>
  }

  export type PaymentUpdateWithoutPaymentTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPaymentsNestedInput
    patient?: PatientUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPaymentTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentPlanUpsertWithoutPaymentTreatmentPlansInput = {
    update: XOR<TreatmentPlanUpdateWithoutPaymentTreatmentPlansInput, TreatmentPlanUncheckedUpdateWithoutPaymentTreatmentPlansInput>
    create: XOR<TreatmentPlanCreateWithoutPaymentTreatmentPlansInput, TreatmentPlanUncheckedCreateWithoutPaymentTreatmentPlansInput>
    where?: TreatmentPlanWhereInput
  }

  export type TreatmentPlanUpdateToOneWithWhereWithoutPaymentTreatmentPlansInput = {
    where?: TreatmentPlanWhereInput
    data: XOR<TreatmentPlanUpdateWithoutPaymentTreatmentPlansInput, TreatmentPlanUncheckedUpdateWithoutPaymentTreatmentPlansInput>
  }

  export type TreatmentPlanUpdateWithoutPaymentTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutTreatmentPlansNestedInput
    patient?: PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput
    dentist?: DentistUpdateOneRequiredWithoutTreatmentPlansNestedInput
    items?: TreatmentItemUpdateManyWithoutPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateWithoutPaymentTreatmentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TreatmentItemUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ClinicCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutSubscriptionInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutSubscriptionInput, ClinicUncheckedCreateWithoutSubscriptionInput>
  }

  export type ClinicUpsertWithoutSubscriptionInput = {
    update: XOR<ClinicUpdateWithoutSubscriptionInput, ClinicUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<ClinicCreateWithoutSubscriptionInput, ClinicUncheckedCreateWithoutSubscriptionInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutSubscriptionInput, ClinicUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ClinicUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutAuditLogsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutAuditLogsInput, ClinicUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutUsersInput
    dentist?: DentistCreateNestedOneWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    clinicId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentist?: DentistUncheckedCreateNestedOneWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type ClinicUpsertWithoutAuditLogsInput = {
    update: XOR<ClinicUpdateWithoutAuditLogsInput, ClinicUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ClinicCreateWithoutAuditLogsInput, ClinicUncheckedCreateWithoutAuditLogsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutAuditLogsInput, ClinicUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ClinicUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutUsersNestedInput
    dentist?: DentistUpdateOneWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUncheckedUpdateOneWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ClinicCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutInventoryItemsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutInventoryItemsInput, ClinicUncheckedCreateWithoutInventoryItemsInput>
  }

  export type InventoryMovementCreateWithoutItemInput = {
    id?: string
    type: $Enums.InventoryMovementType
    quantity: number
    notes?: string | null
    createdAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutInventoryMovementsInput
    appointment?: AppointmentCreateNestedOneWithoutInventoryMovementsInput
    createdBy: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutItemInput = {
    id?: string
    clinicId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput>
  }

  export type InventoryMovementCreateManyItemInputEnvelope = {
    data: InventoryMovementCreateManyItemInput | InventoryMovementCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutInventoryItemsInput = {
    update: XOR<ClinicUpdateWithoutInventoryItemsInput, ClinicUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ClinicCreateWithoutInventoryItemsInput, ClinicUncheckedCreateWithoutInventoryItemsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutInventoryItemsInput, ClinicUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ClinicUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutItemInput, InventoryMovementUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutItemInput, InventoryMovementUncheckedUpdateWithoutItemInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutItemInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutItemInput>
  }

  export type ClinicCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutInventoryMovementsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutInventoryMovementsInput, ClinicUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type InventoryItemCreateWithoutMovementsInput = {
    id?: string
    name: string
    description?: string | null
    unit: string
    currentQuantity?: number
    minQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutMovementsInput = {
    id?: string
    clinicId: string
    name: string
    description?: string | null
    unit: string
    currentQuantity?: number
    minQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutMovementsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutMovementsInput, InventoryItemUncheckedCreateWithoutMovementsInput>
  }

  export type AppointmentCreateWithoutInventoryMovementsInput = {
    id?: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAppointmentsInput
    dentist: DentistCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    procedureRelation?: ProcedureCreateNestedOneWithoutAppointmentsInput
    record?: RecordCreateNestedOneWithoutAppointmentInput
    attendance?: AttendanceCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    clinicId: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    record?: RecordUncheckedCreateNestedOneWithoutAppointmentInput
    attendance?: AttendanceUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutInventoryMovementsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutInventoryMovementsInput, AppointmentUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type UserCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutUsersInput
    dentist?: DentistCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    clinicId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentist?: DentistUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutInventoryMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type ClinicUpsertWithoutInventoryMovementsInput = {
    update: XOR<ClinicUpdateWithoutInventoryMovementsInput, ClinicUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<ClinicCreateWithoutInventoryMovementsInput, ClinicUncheckedCreateWithoutInventoryMovementsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutInventoryMovementsInput, ClinicUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type ClinicUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type InventoryItemUpsertWithoutMovementsInput = {
    update: XOR<InventoryItemUpdateWithoutMovementsInput, InventoryItemUncheckedUpdateWithoutMovementsInput>
    create: XOR<InventoryItemCreateWithoutMovementsInput, InventoryItemUncheckedCreateWithoutMovementsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutMovementsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutMovementsInput, InventoryItemUncheckedUpdateWithoutMovementsInput>
  }

  export type InventoryItemUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpsertWithoutInventoryMovementsInput = {
    update: XOR<AppointmentUpdateWithoutInventoryMovementsInput, AppointmentUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<AppointmentCreateWithoutInventoryMovementsInput, AppointmentUncheckedCreateWithoutInventoryMovementsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutInventoryMovementsInput, AppointmentUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type AppointmentUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAppointmentsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    procedureRelation?: ProcedureUpdateOneWithoutAppointmentsNestedInput
    record?: RecordUpdateOneWithoutAppointmentNestedInput
    attendance?: AttendanceUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record?: RecordUncheckedUpdateOneWithoutAppointmentNestedInput
    attendance?: AttendanceUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type UserUpsertWithoutInventoryMovementsInput = {
    update: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type UserUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutUsersNestedInput
    dentist?: DentistUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProcedureCreateWithoutSpecialtyInput = {
    id?: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutProceduresInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    clinicId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutSpecialtyInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutSpecialtyInput, ProcedureUncheckedCreateWithoutSpecialtyInput>
  }

  export type ProcedureCreateManySpecialtyInputEnvelope = {
    data: ProcedureCreateManySpecialtyInput | ProcedureCreateManySpecialtyInput[]
    skipDuplicates?: boolean
  }

  export type DentistSpecialtyCreateWithoutSpecialtyInput = {
    id?: string
    createdAt?: Date | string
    dentist: DentistCreateNestedOneWithoutDentistSpecialtiesInput
  }

  export type DentistSpecialtyUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    dentistId: string
    createdAt?: Date | string
  }

  export type DentistSpecialtyCreateOrConnectWithoutSpecialtyInput = {
    where: DentistSpecialtyWhereUniqueInput
    create: XOR<DentistSpecialtyCreateWithoutSpecialtyInput, DentistSpecialtyUncheckedCreateWithoutSpecialtyInput>
  }

  export type DentistSpecialtyCreateManySpecialtyInputEnvelope = {
    data: DentistSpecialtyCreateManySpecialtyInput | DentistSpecialtyCreateManySpecialtyInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: ProcedureWhereUniqueInput
    update: XOR<ProcedureUpdateWithoutSpecialtyInput, ProcedureUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<ProcedureCreateWithoutSpecialtyInput, ProcedureUncheckedCreateWithoutSpecialtyInput>
  }

  export type ProcedureUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: ProcedureWhereUniqueInput
    data: XOR<ProcedureUpdateWithoutSpecialtyInput, ProcedureUncheckedUpdateWithoutSpecialtyInput>
  }

  export type ProcedureUpdateManyWithWhereWithoutSpecialtyInput = {
    where: ProcedureScalarWhereInput
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyWithoutSpecialtyInput>
  }

  export type DentistSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: DentistSpecialtyWhereUniqueInput
    update: XOR<DentistSpecialtyUpdateWithoutSpecialtyInput, DentistSpecialtyUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<DentistSpecialtyCreateWithoutSpecialtyInput, DentistSpecialtyUncheckedCreateWithoutSpecialtyInput>
  }

  export type DentistSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: DentistSpecialtyWhereUniqueInput
    data: XOR<DentistSpecialtyUpdateWithoutSpecialtyInput, DentistSpecialtyUncheckedUpdateWithoutSpecialtyInput>
  }

  export type DentistSpecialtyUpdateManyWithWhereWithoutSpecialtyInput = {
    where: DentistSpecialtyScalarWhereInput
    data: XOR<DentistSpecialtyUpdateManyMutationInput, DentistSpecialtyUncheckedUpdateManyWithoutSpecialtyInput>
  }

  export type ClinicCreateWithoutProceduresInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    attendances?: AttendanceCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutProceduresInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutProceduresInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutProceduresInput, ClinicUncheckedCreateWithoutProceduresInput>
  }

  export type SpecialtyCreateWithoutProceduresInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutProceduresInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutProceduresInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutProceduresInput, SpecialtyUncheckedCreateWithoutProceduresInput>
  }

  export type DentistProcedureCreateWithoutProcedureInput = {
    id?: string
    createdAt?: Date | string
    dentist: DentistCreateNestedOneWithoutDentistProceduresInput
  }

  export type DentistProcedureUncheckedCreateWithoutProcedureInput = {
    id?: string
    dentistId: string
    createdAt?: Date | string
  }

  export type DentistProcedureCreateOrConnectWithoutProcedureInput = {
    where: DentistProcedureWhereUniqueInput
    create: XOR<DentistProcedureCreateWithoutProcedureInput, DentistProcedureUncheckedCreateWithoutProcedureInput>
  }

  export type DentistProcedureCreateManyProcedureInputEnvelope = {
    data: DentistProcedureCreateManyProcedureInput | DentistProcedureCreateManyProcedureInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutProcedureRelationInput = {
    id?: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAppointmentsInput
    dentist: DentistCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    record?: RecordCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutProcedureRelationInput = {
    id?: string
    clinicId: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    record?: RecordUncheckedCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutAppointmentInput
    attendance?: AttendanceUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutProcedureRelationInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutProcedureRelationInput, AppointmentUncheckedCreateWithoutProcedureRelationInput>
  }

  export type AppointmentCreateManyProcedureRelationInputEnvelope = {
    data: AppointmentCreateManyProcedureRelationInput | AppointmentCreateManyProcedureRelationInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceProcedureCreateWithoutProcedureInput = {
    id?: string
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance: AttendanceCreateNestedOneWithoutProceduresInput
    dentist?: DentistCreateNestedOneWithoutAttendanceProceduresInput
  }

  export type AttendanceProcedureUncheckedCreateWithoutProcedureInput = {
    id?: string
    attendanceId: string
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    dentistId?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceProcedureCreateOrConnectWithoutProcedureInput = {
    where: AttendanceProcedureWhereUniqueInput
    create: XOR<AttendanceProcedureCreateWithoutProcedureInput, AttendanceProcedureUncheckedCreateWithoutProcedureInput>
  }

  export type AttendanceProcedureCreateManyProcedureInputEnvelope = {
    data: AttendanceProcedureCreateManyProcedureInput | AttendanceProcedureCreateManyProcedureInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentItemCreateWithoutProcedureInput = {
    id?: string
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
    plan: TreatmentPlanCreateNestedOneWithoutItemsInput
  }

  export type TreatmentItemUncheckedCreateWithoutProcedureInput = {
    id?: string
    planId: string
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TreatmentItemCreateOrConnectWithoutProcedureInput = {
    where: TreatmentItemWhereUniqueInput
    create: XOR<TreatmentItemCreateWithoutProcedureInput, TreatmentItemUncheckedCreateWithoutProcedureInput>
  }

  export type TreatmentItemCreateManyProcedureInputEnvelope = {
    data: TreatmentItemCreateManyProcedureInput | TreatmentItemCreateManyProcedureInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutProceduresInput = {
    update: XOR<ClinicUpdateWithoutProceduresInput, ClinicUncheckedUpdateWithoutProceduresInput>
    create: XOR<ClinicCreateWithoutProceduresInput, ClinicUncheckedCreateWithoutProceduresInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutProceduresInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutProceduresInput, ClinicUncheckedUpdateWithoutProceduresInput>
  }

  export type ClinicUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type SpecialtyUpsertWithoutProceduresInput = {
    update: XOR<SpecialtyUpdateWithoutProceduresInput, SpecialtyUncheckedUpdateWithoutProceduresInput>
    create: XOR<SpecialtyCreateWithoutProceduresInput, SpecialtyUncheckedCreateWithoutProceduresInput>
    where?: SpecialtyWhereInput
  }

  export type SpecialtyUpdateToOneWithWhereWithoutProceduresInput = {
    where?: SpecialtyWhereInput
    data: XOR<SpecialtyUpdateWithoutProceduresInput, SpecialtyUncheckedUpdateWithoutProceduresInput>
  }

  export type SpecialtyUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type DentistProcedureUpsertWithWhereUniqueWithoutProcedureInput = {
    where: DentistProcedureWhereUniqueInput
    update: XOR<DentistProcedureUpdateWithoutProcedureInput, DentistProcedureUncheckedUpdateWithoutProcedureInput>
    create: XOR<DentistProcedureCreateWithoutProcedureInput, DentistProcedureUncheckedCreateWithoutProcedureInput>
  }

  export type DentistProcedureUpdateWithWhereUniqueWithoutProcedureInput = {
    where: DentistProcedureWhereUniqueInput
    data: XOR<DentistProcedureUpdateWithoutProcedureInput, DentistProcedureUncheckedUpdateWithoutProcedureInput>
  }

  export type DentistProcedureUpdateManyWithWhereWithoutProcedureInput = {
    where: DentistProcedureScalarWhereInput
    data: XOR<DentistProcedureUpdateManyMutationInput, DentistProcedureUncheckedUpdateManyWithoutProcedureInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutProcedureRelationInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutProcedureRelationInput, AppointmentUncheckedUpdateWithoutProcedureRelationInput>
    create: XOR<AppointmentCreateWithoutProcedureRelationInput, AppointmentUncheckedCreateWithoutProcedureRelationInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutProcedureRelationInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutProcedureRelationInput, AppointmentUncheckedUpdateWithoutProcedureRelationInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutProcedureRelationInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutProcedureRelationInput>
  }

  export type AttendanceProcedureUpsertWithWhereUniqueWithoutProcedureInput = {
    where: AttendanceProcedureWhereUniqueInput
    update: XOR<AttendanceProcedureUpdateWithoutProcedureInput, AttendanceProcedureUncheckedUpdateWithoutProcedureInput>
    create: XOR<AttendanceProcedureCreateWithoutProcedureInput, AttendanceProcedureUncheckedCreateWithoutProcedureInput>
  }

  export type AttendanceProcedureUpdateWithWhereUniqueWithoutProcedureInput = {
    where: AttendanceProcedureWhereUniqueInput
    data: XOR<AttendanceProcedureUpdateWithoutProcedureInput, AttendanceProcedureUncheckedUpdateWithoutProcedureInput>
  }

  export type AttendanceProcedureUpdateManyWithWhereWithoutProcedureInput = {
    where: AttendanceProcedureScalarWhereInput
    data: XOR<AttendanceProcedureUpdateManyMutationInput, AttendanceProcedureUncheckedUpdateManyWithoutProcedureInput>
  }

  export type TreatmentItemUpsertWithWhereUniqueWithoutProcedureInput = {
    where: TreatmentItemWhereUniqueInput
    update: XOR<TreatmentItemUpdateWithoutProcedureInput, TreatmentItemUncheckedUpdateWithoutProcedureInput>
    create: XOR<TreatmentItemCreateWithoutProcedureInput, TreatmentItemUncheckedCreateWithoutProcedureInput>
  }

  export type TreatmentItemUpdateWithWhereUniqueWithoutProcedureInput = {
    where: TreatmentItemWhereUniqueInput
    data: XOR<TreatmentItemUpdateWithoutProcedureInput, TreatmentItemUncheckedUpdateWithoutProcedureInput>
  }

  export type TreatmentItemUpdateManyWithWhereWithoutProcedureInput = {
    where: TreatmentItemScalarWhereInput
    data: XOR<TreatmentItemUpdateManyMutationInput, TreatmentItemUncheckedUpdateManyWithoutProcedureInput>
  }

  export type DentistCreateWithoutDentistProceduresInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutDentistProceduresInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutDentistProceduresInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutDentistProceduresInput, DentistUncheckedCreateWithoutDentistProceduresInput>
  }

  export type ProcedureCreateWithoutDentistProceduresInput = {
    id?: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutProceduresInput
    specialty: SpecialtyCreateNestedOneWithoutProceduresInput
    appointments?: AppointmentCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutDentistProceduresInput = {
    id?: string
    clinicId: string
    specialtyId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProcedureRelationInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutProcedureInput
    treatmentItems?: TreatmentItemUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutDentistProceduresInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutDentistProceduresInput, ProcedureUncheckedCreateWithoutDentistProceduresInput>
  }

  export type DentistUpsertWithoutDentistProceduresInput = {
    update: XOR<DentistUpdateWithoutDentistProceduresInput, DentistUncheckedUpdateWithoutDentistProceduresInput>
    create: XOR<DentistCreateWithoutDentistProceduresInput, DentistUncheckedCreateWithoutDentistProceduresInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutDentistProceduresInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutDentistProceduresInput, DentistUncheckedUpdateWithoutDentistProceduresInput>
  }

  export type DentistUpdateWithoutDentistProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutDentistProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type ProcedureUpsertWithoutDentistProceduresInput = {
    update: XOR<ProcedureUpdateWithoutDentistProceduresInput, ProcedureUncheckedUpdateWithoutDentistProceduresInput>
    create: XOR<ProcedureCreateWithoutDentistProceduresInput, ProcedureUncheckedCreateWithoutDentistProceduresInput>
    where?: ProcedureWhereInput
  }

  export type ProcedureUpdateToOneWithWhereWithoutDentistProceduresInput = {
    where?: ProcedureWhereInput
    data: XOR<ProcedureUpdateWithoutDentistProceduresInput, ProcedureUncheckedUpdateWithoutDentistProceduresInput>
  }

  export type ProcedureUpdateWithoutDentistProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutProceduresNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutProceduresNestedInput
    appointments?: AppointmentUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutDentistProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type DentistCreateWithoutDentistSpecialtiesInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutDentistSpecialtiesInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutDentistSpecialtiesInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutDentistSpecialtiesInput, DentistUncheckedCreateWithoutDentistSpecialtiesInput>
  }

  export type SpecialtyCreateWithoutDentistSpecialtiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutDentistSpecialtiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutDentistSpecialtiesInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutDentistSpecialtiesInput, SpecialtyUncheckedCreateWithoutDentistSpecialtiesInput>
  }

  export type DentistUpsertWithoutDentistSpecialtiesInput = {
    update: XOR<DentistUpdateWithoutDentistSpecialtiesInput, DentistUncheckedUpdateWithoutDentistSpecialtiesInput>
    create: XOR<DentistCreateWithoutDentistSpecialtiesInput, DentistUncheckedCreateWithoutDentistSpecialtiesInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutDentistSpecialtiesInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutDentistSpecialtiesInput, DentistUncheckedUpdateWithoutDentistSpecialtiesInput>
  }

  export type DentistUpdateWithoutDentistSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutDentistSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type SpecialtyUpsertWithoutDentistSpecialtiesInput = {
    update: XOR<SpecialtyUpdateWithoutDentistSpecialtiesInput, SpecialtyUncheckedUpdateWithoutDentistSpecialtiesInput>
    create: XOR<SpecialtyCreateWithoutDentistSpecialtiesInput, SpecialtyUncheckedCreateWithoutDentistSpecialtiesInput>
    where?: SpecialtyWhereInput
  }

  export type SpecialtyUpdateToOneWithWhereWithoutDentistSpecialtiesInput = {
    where?: SpecialtyWhereInput
    data: XOR<SpecialtyUpdateWithoutDentistSpecialtiesInput, SpecialtyUncheckedUpdateWithoutDentistSpecialtiesInput>
  }

  export type SpecialtyUpdateWithoutDentistSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutDentistSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type ClinicCreateWithoutAttendancesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    dentists?: DentistCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    appointments?: AppointmentCreateNestedManyWithoutClinicInput
    records?: RecordCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutClinicInput
    payments?: PaymentCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutClinicInput
    procedures?: ProcedureCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutAttendancesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    dentists?: DentistUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClinicInput
    records?: RecordUncheckedCreateNestedManyWithoutClinicInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutClinicInput
    payments?: PaymentUncheckedCreateNestedManyWithoutClinicInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutClinicInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutClinicInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutClinicInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutClinicInput
    procedures?: ProcedureUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutAttendancesInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutAttendancesInput, ClinicUncheckedCreateWithoutAttendancesInput>
  }

  export type AppointmentCreateWithoutAttendanceInput = {
    id?: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAppointmentsInput
    dentist: DentistCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    procedureRelation?: ProcedureCreateNestedOneWithoutAppointmentsInput
    record?: RecordCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutAttendanceInput = {
    id?: string
    clinicId: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    record?: RecordUncheckedCreateNestedOneWithoutAppointmentInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutAttendanceInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutAttendanceInput, AppointmentUncheckedCreateWithoutAttendanceInput>
  }

  export type PatientCreateWithoutAttendancesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    records?: RecordCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAttendancesInput = {
    id?: string
    clinicId: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    records?: RecordUncheckedCreateNestedManyWithoutPatientInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAttendancesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAttendancesInput, PatientUncheckedCreateWithoutAttendancesInput>
  }

  export type DentistCreateWithoutAttendancesInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutAttendancesInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutAttendancesInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutAttendancesInput, DentistUncheckedCreateWithoutAttendancesInput>
  }

  export type UserCreateWithoutAttendancesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutUsersInput
    dentist?: DentistCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAttendancesInput = {
    id?: string
    clinicId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentist?: DentistUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
  }

  export type AttendanceCIDCreateWithoutAttendanceInput = {
    id?: string
    cidCode: string
    description: string
    observation?: string | null
    createdBy: DentistCreateNestedOneWithoutAttendanceCidsInput
  }

  export type AttendanceCIDUncheckedCreateWithoutAttendanceInput = {
    id?: string
    cidCode: string
    description: string
    observation?: string | null
    createdByDentistId: string
  }

  export type AttendanceCIDCreateOrConnectWithoutAttendanceInput = {
    where: AttendanceCIDWhereUniqueInput
    create: XOR<AttendanceCIDCreateWithoutAttendanceInput, AttendanceCIDUncheckedCreateWithoutAttendanceInput>
  }

  export type AttendanceCIDCreateManyAttendanceInputEnvelope = {
    data: AttendanceCIDCreateManyAttendanceInput | AttendanceCIDCreateManyAttendanceInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceProcedureCreateWithoutAttendanceInput = {
    id?: string
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    procedure?: ProcedureCreateNestedOneWithoutAttendanceProceduresInput
    dentist?: DentistCreateNestedOneWithoutAttendanceProceduresInput
  }

  export type AttendanceProcedureUncheckedCreateWithoutAttendanceInput = {
    id?: string
    procedureId?: string | null
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    dentistId?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceProcedureCreateOrConnectWithoutAttendanceInput = {
    where: AttendanceProcedureWhereUniqueInput
    create: XOR<AttendanceProcedureCreateWithoutAttendanceInput, AttendanceProcedureUncheckedCreateWithoutAttendanceInput>
  }

  export type AttendanceProcedureCreateManyAttendanceInputEnvelope = {
    data: AttendanceProcedureCreateManyAttendanceInput | AttendanceProcedureCreateManyAttendanceInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceOdontogramCreateWithoutAttendanceInput = {
    data: JsonNullValueInput | InputJsonValue
  }

  export type AttendanceOdontogramUncheckedCreateWithoutAttendanceInput = {
    data: JsonNullValueInput | InputJsonValue
  }

  export type AttendanceOdontogramCreateOrConnectWithoutAttendanceInput = {
    where: AttendanceOdontogramWhereUniqueInput
    create: XOR<AttendanceOdontogramCreateWithoutAttendanceInput, AttendanceOdontogramUncheckedCreateWithoutAttendanceInput>
  }

  export type ClinicalDocumentCreateWithoutAttendanceInput = {
    id?: string
    type: $Enums.ClinicalDocumentType
    payload: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type ClinicalDocumentUncheckedCreateWithoutAttendanceInput = {
    id?: string
    type: $Enums.ClinicalDocumentType
    payload: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type ClinicalDocumentCreateOrConnectWithoutAttendanceInput = {
    where: ClinicalDocumentWhereUniqueInput
    create: XOR<ClinicalDocumentCreateWithoutAttendanceInput, ClinicalDocumentUncheckedCreateWithoutAttendanceInput>
  }

  export type ClinicalDocumentCreateManyAttendanceInputEnvelope = {
    data: ClinicalDocumentCreateManyAttendanceInput | ClinicalDocumentCreateManyAttendanceInput[]
    skipDuplicates?: boolean
  }

  export type RecordCreateWithoutAttendanceInput = {
    id?: string
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutRecordsInput
    patient: PatientCreateNestedOneWithoutRecordsInput
    dentist: DentistCreateNestedOneWithoutRecordsInput
    appointment?: AppointmentCreateNestedOneWithoutRecordInput
  }

  export type RecordUncheckedCreateWithoutAttendanceInput = {
    id?: string
    clinicId: string
    patientId: string
    dentistId: string
    appointmentId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordCreateOrConnectWithoutAttendanceInput = {
    where: RecordWhereUniqueInput
    create: XOR<RecordCreateWithoutAttendanceInput, RecordUncheckedCreateWithoutAttendanceInput>
  }

  export type ClinicUpsertWithoutAttendancesInput = {
    update: XOR<ClinicUpdateWithoutAttendancesInput, ClinicUncheckedUpdateWithoutAttendancesInput>
    create: XOR<ClinicCreateWithoutAttendancesInput, ClinicUncheckedCreateWithoutAttendancesInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutAttendancesInput, ClinicUncheckedUpdateWithoutAttendancesInput>
  }

  export type ClinicUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    dentists?: DentistUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUpdateManyWithoutClinicNestedInput
    records?: RecordUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutClinicNestedInput
    payments?: PaymentUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    dentists?: DentistUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClinicNestedInput
    records?: RecordUncheckedUpdateManyWithoutClinicNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutClinicNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutClinicNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutClinicNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutClinicNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutClinicNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutClinicNestedInput
    procedures?: ProcedureUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type AppointmentUpsertWithoutAttendanceInput = {
    update: XOR<AppointmentUpdateWithoutAttendanceInput, AppointmentUncheckedUpdateWithoutAttendanceInput>
    create: XOR<AppointmentCreateWithoutAttendanceInput, AppointmentUncheckedCreateWithoutAttendanceInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutAttendanceInput, AppointmentUncheckedUpdateWithoutAttendanceInput>
  }

  export type AppointmentUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAppointmentsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    procedureRelation?: ProcedureUpdateOneWithoutAppointmentsNestedInput
    record?: RecordUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record?: RecordUncheckedUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type PatientUpsertWithoutAttendancesInput = {
    update: XOR<PatientUpdateWithoutAttendancesInput, PatientUncheckedUpdateWithoutAttendancesInput>
    create: XOR<PatientCreateWithoutAttendancesInput, PatientUncheckedCreateWithoutAttendancesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAttendancesInput, PatientUncheckedUpdateWithoutAttendancesInput>
  }

  export type PatientUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    records?: RecordUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    records?: RecordUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DentistUpsertWithoutAttendancesInput = {
    update: XOR<DentistUpdateWithoutAttendancesInput, DentistUncheckedUpdateWithoutAttendancesInput>
    create: XOR<DentistCreateWithoutAttendancesInput, DentistUncheckedCreateWithoutAttendancesInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutAttendancesInput, DentistUncheckedUpdateWithoutAttendancesInput>
  }

  export type DentistUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type UserUpsertWithoutAttendancesInput = {
    update: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutUsersNestedInput
    dentist?: DentistUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AttendanceCIDUpsertWithWhereUniqueWithoutAttendanceInput = {
    where: AttendanceCIDWhereUniqueInput
    update: XOR<AttendanceCIDUpdateWithoutAttendanceInput, AttendanceCIDUncheckedUpdateWithoutAttendanceInput>
    create: XOR<AttendanceCIDCreateWithoutAttendanceInput, AttendanceCIDUncheckedCreateWithoutAttendanceInput>
  }

  export type AttendanceCIDUpdateWithWhereUniqueWithoutAttendanceInput = {
    where: AttendanceCIDWhereUniqueInput
    data: XOR<AttendanceCIDUpdateWithoutAttendanceInput, AttendanceCIDUncheckedUpdateWithoutAttendanceInput>
  }

  export type AttendanceCIDUpdateManyWithWhereWithoutAttendanceInput = {
    where: AttendanceCIDScalarWhereInput
    data: XOR<AttendanceCIDUpdateManyMutationInput, AttendanceCIDUncheckedUpdateManyWithoutAttendanceInput>
  }

  export type AttendanceProcedureUpsertWithWhereUniqueWithoutAttendanceInput = {
    where: AttendanceProcedureWhereUniqueInput
    update: XOR<AttendanceProcedureUpdateWithoutAttendanceInput, AttendanceProcedureUncheckedUpdateWithoutAttendanceInput>
    create: XOR<AttendanceProcedureCreateWithoutAttendanceInput, AttendanceProcedureUncheckedCreateWithoutAttendanceInput>
  }

  export type AttendanceProcedureUpdateWithWhereUniqueWithoutAttendanceInput = {
    where: AttendanceProcedureWhereUniqueInput
    data: XOR<AttendanceProcedureUpdateWithoutAttendanceInput, AttendanceProcedureUncheckedUpdateWithoutAttendanceInput>
  }

  export type AttendanceProcedureUpdateManyWithWhereWithoutAttendanceInput = {
    where: AttendanceProcedureScalarWhereInput
    data: XOR<AttendanceProcedureUpdateManyMutationInput, AttendanceProcedureUncheckedUpdateManyWithoutAttendanceInput>
  }

  export type AttendanceOdontogramUpsertWithoutAttendanceInput = {
    update: XOR<AttendanceOdontogramUpdateWithoutAttendanceInput, AttendanceOdontogramUncheckedUpdateWithoutAttendanceInput>
    create: XOR<AttendanceOdontogramCreateWithoutAttendanceInput, AttendanceOdontogramUncheckedCreateWithoutAttendanceInput>
    where?: AttendanceOdontogramWhereInput
  }

  export type AttendanceOdontogramUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: AttendanceOdontogramWhereInput
    data: XOR<AttendanceOdontogramUpdateWithoutAttendanceInput, AttendanceOdontogramUncheckedUpdateWithoutAttendanceInput>
  }

  export type AttendanceOdontogramUpdateWithoutAttendanceInput = {
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AttendanceOdontogramUncheckedUpdateWithoutAttendanceInput = {
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ClinicalDocumentUpsertWithWhereUniqueWithoutAttendanceInput = {
    where: ClinicalDocumentWhereUniqueInput
    update: XOR<ClinicalDocumentUpdateWithoutAttendanceInput, ClinicalDocumentUncheckedUpdateWithoutAttendanceInput>
    create: XOR<ClinicalDocumentCreateWithoutAttendanceInput, ClinicalDocumentUncheckedCreateWithoutAttendanceInput>
  }

  export type ClinicalDocumentUpdateWithWhereUniqueWithoutAttendanceInput = {
    where: ClinicalDocumentWhereUniqueInput
    data: XOR<ClinicalDocumentUpdateWithoutAttendanceInput, ClinicalDocumentUncheckedUpdateWithoutAttendanceInput>
  }

  export type ClinicalDocumentUpdateManyWithWhereWithoutAttendanceInput = {
    where: ClinicalDocumentScalarWhereInput
    data: XOR<ClinicalDocumentUpdateManyMutationInput, ClinicalDocumentUncheckedUpdateManyWithoutAttendanceInput>
  }

  export type ClinicalDocumentScalarWhereInput = {
    AND?: ClinicalDocumentScalarWhereInput | ClinicalDocumentScalarWhereInput[]
    OR?: ClinicalDocumentScalarWhereInput[]
    NOT?: ClinicalDocumentScalarWhereInput | ClinicalDocumentScalarWhereInput[]
    id?: StringFilter<"ClinicalDocument"> | string
    attendanceId?: StringFilter<"ClinicalDocument"> | string
    type?: EnumClinicalDocumentTypeFilter<"ClinicalDocument"> | $Enums.ClinicalDocumentType
    payload?: JsonFilter<"ClinicalDocument">
    generatedBy?: StringFilter<"ClinicalDocument"> | string
    generatedAt?: DateTimeFilter<"ClinicalDocument"> | Date | string
  }

  export type RecordUpsertWithoutAttendanceInput = {
    update: XOR<RecordUpdateWithoutAttendanceInput, RecordUncheckedUpdateWithoutAttendanceInput>
    create: XOR<RecordCreateWithoutAttendanceInput, RecordUncheckedCreateWithoutAttendanceInput>
    where?: RecordWhereInput
  }

  export type RecordUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: RecordWhereInput
    data: XOR<RecordUpdateWithoutAttendanceInput, RecordUncheckedUpdateWithoutAttendanceInput>
  }

  export type RecordUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutRecordsNestedInput
    patient?: PatientUpdateOneRequiredWithoutRecordsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutRecordsNestedInput
    appointment?: AppointmentUpdateOneWithoutRecordNestedInput
  }

  export type RecordUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateWithoutCidsInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutCidsInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutCidsInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutCidsInput, AttendanceUncheckedCreateWithoutCidsInput>
  }

  export type DentistCreateWithoutAttendanceCidsInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceProcedures?: AttendanceProcedureCreateNestedManyWithoutDentistInput
  }

  export type DentistUncheckedCreateWithoutAttendanceCidsInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceProcedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutDentistInput
  }

  export type DentistCreateOrConnectWithoutAttendanceCidsInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutAttendanceCidsInput, DentistUncheckedCreateWithoutAttendanceCidsInput>
  }

  export type AttendanceUpsertWithoutCidsInput = {
    update: XOR<AttendanceUpdateWithoutCidsInput, AttendanceUncheckedUpdateWithoutCidsInput>
    create: XOR<AttendanceCreateWithoutCidsInput, AttendanceUncheckedCreateWithoutCidsInput>
    where?: AttendanceWhereInput
  }

  export type AttendanceUpdateToOneWithWhereWithoutCidsInput = {
    where?: AttendanceWhereInput
    data: XOR<AttendanceUpdateWithoutCidsInput, AttendanceUncheckedUpdateWithoutCidsInput>
  }

  export type AttendanceUpdateWithoutCidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutCidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type DentistUpsertWithoutAttendanceCidsInput = {
    update: XOR<DentistUpdateWithoutAttendanceCidsInput, DentistUncheckedUpdateWithoutAttendanceCidsInput>
    create: XOR<DentistCreateWithoutAttendanceCidsInput, DentistUncheckedCreateWithoutAttendanceCidsInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutAttendanceCidsInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutAttendanceCidsInput, DentistUncheckedUpdateWithoutAttendanceCidsInput>
  }

  export type DentistUpdateWithoutAttendanceCidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutAttendanceCidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type AttendanceCreateWithoutProceduresInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutProceduresInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutProceduresInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutProceduresInput, AttendanceUncheckedCreateWithoutProceduresInput>
  }

  export type ProcedureCreateWithoutAttendanceProceduresInput = {
    id?: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutProceduresInput
    specialty: SpecialtyCreateNestedOneWithoutProceduresInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentCreateNestedManyWithoutProcedureRelationInput
    treatmentItems?: TreatmentItemCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutAttendanceProceduresInput = {
    id?: string
    clinicId: string
    specialtyId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutProcedureInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProcedureRelationInput
    treatmentItems?: TreatmentItemUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutAttendanceProceduresInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutAttendanceProceduresInput, ProcedureUncheckedCreateWithoutAttendanceProceduresInput>
  }

  export type DentistCreateWithoutAttendanceProceduresInput = {
    id?: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutDentistsInput
    user: UserCreateNestedOneWithoutDentistInput
    appointments?: AppointmentCreateNestedManyWithoutDentistInput
    records?: RecordCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyCreateNestedManyWithoutDentistInput
    attendances?: AttendanceCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDCreateNestedManyWithoutCreatedByInput
  }

  export type DentistUncheckedCreateWithoutAttendanceProceduresInput = {
    id?: string
    clinicId: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDentistInput
    records?: RecordUncheckedCreateNestedManyWithoutDentistInput
    treatmentPlans?: TreatmentPlanUncheckedCreateNestedManyWithoutDentistInput
    dentistProcedures?: DentistProcedureUncheckedCreateNestedManyWithoutDentistInput
    dentistSpecialties?: DentistSpecialtyUncheckedCreateNestedManyWithoutDentistInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutDentistInput
    attendanceCids?: AttendanceCIDUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type DentistCreateOrConnectWithoutAttendanceProceduresInput = {
    where: DentistWhereUniqueInput
    create: XOR<DentistCreateWithoutAttendanceProceduresInput, DentistUncheckedCreateWithoutAttendanceProceduresInput>
  }

  export type AttendanceUpsertWithoutProceduresInput = {
    update: XOR<AttendanceUpdateWithoutProceduresInput, AttendanceUncheckedUpdateWithoutProceduresInput>
    create: XOR<AttendanceCreateWithoutProceduresInput, AttendanceUncheckedCreateWithoutProceduresInput>
    where?: AttendanceWhereInput
  }

  export type AttendanceUpdateToOneWithWhereWithoutProceduresInput = {
    where?: AttendanceWhereInput
    data: XOR<AttendanceUpdateWithoutProceduresInput, AttendanceUncheckedUpdateWithoutProceduresInput>
  }

  export type AttendanceUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type ProcedureUpsertWithoutAttendanceProceduresInput = {
    update: XOR<ProcedureUpdateWithoutAttendanceProceduresInput, ProcedureUncheckedUpdateWithoutAttendanceProceduresInput>
    create: XOR<ProcedureCreateWithoutAttendanceProceduresInput, ProcedureUncheckedCreateWithoutAttendanceProceduresInput>
    where?: ProcedureWhereInput
  }

  export type ProcedureUpdateToOneWithWhereWithoutAttendanceProceduresInput = {
    where?: ProcedureWhereInput
    data: XOR<ProcedureUpdateWithoutAttendanceProceduresInput, ProcedureUncheckedUpdateWithoutAttendanceProceduresInput>
  }

  export type ProcedureUpdateWithoutAttendanceProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutProceduresNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutProceduresNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUpdateManyWithoutProcedureRelationNestedInput
    treatmentItems?: TreatmentItemUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutAttendanceProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProcedureRelationNestedInput
    treatmentItems?: TreatmentItemUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type DentistUpsertWithoutAttendanceProceduresInput = {
    update: XOR<DentistUpdateWithoutAttendanceProceduresInput, DentistUncheckedUpdateWithoutAttendanceProceduresInput>
    create: XOR<DentistCreateWithoutAttendanceProceduresInput, DentistUncheckedCreateWithoutAttendanceProceduresInput>
    where?: DentistWhereInput
  }

  export type DentistUpdateToOneWithWhereWithoutAttendanceProceduresInput = {
    where?: DentistWhereInput
    data: XOR<DentistUpdateWithoutAttendanceProceduresInput, DentistUncheckedUpdateWithoutAttendanceProceduresInput>
  }

  export type DentistUpdateWithoutAttendanceProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutDentistsNestedInput
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
  }

  export type DentistUncheckedUpdateWithoutAttendanceProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AttendanceCreateWithoutOdontogramInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    documents?: ClinicalDocumentCreateNestedManyWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutOdontogramInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    documents?: ClinicalDocumentUncheckedCreateNestedManyWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutOdontogramInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutOdontogramInput, AttendanceUncheckedCreateWithoutOdontogramInput>
  }

  export type AttendanceUpsertWithoutOdontogramInput = {
    update: XOR<AttendanceUpdateWithoutOdontogramInput, AttendanceUncheckedUpdateWithoutOdontogramInput>
    create: XOR<AttendanceCreateWithoutOdontogramInput, AttendanceUncheckedCreateWithoutOdontogramInput>
    where?: AttendanceWhereInput
  }

  export type AttendanceUpdateToOneWithWhereWithoutOdontogramInput = {
    where?: AttendanceWhereInput
    data: XOR<AttendanceUpdateWithoutOdontogramInput, AttendanceUncheckedUpdateWithoutOdontogramInput>
  }

  export type AttendanceUpdateWithoutOdontogramInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutOdontogramInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceCreateWithoutDocumentsInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutAttendancesInput
    appointment?: AppointmentCreateNestedOneWithoutAttendanceInput
    patient: PatientCreateNestedOneWithoutAttendancesInput
    dentist?: DentistCreateNestedOneWithoutAttendancesInput
    createdBy: UserCreateNestedOneWithoutAttendancesInput
    cids?: AttendanceCIDCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramCreateNestedOneWithoutAttendanceInput
    record?: RecordCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutDocumentsInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cids?: AttendanceCIDUncheckedCreateNestedManyWithoutAttendanceInput
    procedures?: AttendanceProcedureUncheckedCreateNestedManyWithoutAttendanceInput
    odontogram?: AttendanceOdontogramUncheckedCreateNestedOneWithoutAttendanceInput
    record?: RecordUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutDocumentsInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutDocumentsInput, AttendanceUncheckedCreateWithoutDocumentsInput>
  }

  export type AttendanceUpsertWithoutDocumentsInput = {
    update: XOR<AttendanceUpdateWithoutDocumentsInput, AttendanceUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AttendanceCreateWithoutDocumentsInput, AttendanceUncheckedCreateWithoutDocumentsInput>
    where?: AttendanceWhereInput
  }

  export type AttendanceUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: AttendanceWhereInput
    data: XOR<AttendanceUpdateWithoutDocumentsInput, AttendanceUncheckedUpdateWithoutDocumentsInput>
  }

  export type AttendanceUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type UserCreateManyClinicInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DentistCreateManyClinicInput = {
    id?: string
    userId: string
    cro: string
    specialty?: string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyClinicInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyClinicInput = {
    id?: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordCreateManyClinicInput = {
    id?: string
    patientId: string
    dentistId: string
    appointmentId?: string | null
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentPlanCreateManyClinicInput = {
    id?: string
    patientId: string
    dentistId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyClinicInput = {
    id?: string
    patientId?: string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyClinicInput = {
    id?: string
    userId: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type InventoryItemCreateManyClinicInput = {
    id?: string
    name: string
    description?: string | null
    unit: string
    currentQuantity?: number
    minQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryMovementCreateManyClinicInput = {
    id?: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProcedureCreateManyClinicInput = {
    id?: string
    specialtyId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyClinicInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDentistNestedInput
    appointments?: AppointmentUpdateManyWithoutDentistNestedInput
    records?: RecordUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDentistNestedInput
    records?: RecordUncheckedUpdateManyWithoutDentistNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutDentistNestedInput
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutDentistNestedInput
    dentistSpecialties?: DentistSpecialtyUncheckedUpdateManyWithoutDentistNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutDentistNestedInput
    attendanceCids?: AttendanceCIDUncheckedUpdateManyWithoutCreatedByNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutDentistNestedInput
  }

  export type DentistUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cro?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    bankInfo?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    records?: RecordUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    records?: RecordUncheckedUpdateManyWithoutPatientNestedInput
    treatmentPlans?: TreatmentPlanUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    procedureRelation?: ProcedureUpdateOneWithoutAppointmentsNestedInput
    record?: RecordUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record?: RecordUncheckedUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRecordsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutRecordsNestedInput
    appointment?: AppointmentUpdateOneWithoutRecordNestedInput
    attendance?: AttendanceUpdateOneWithoutRecordNestedInput
  }

  export type RecordUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentPlanUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput
    dentist?: DentistUpdateOneRequiredWithoutTreatmentPlansNestedInput
    items?: TreatmentItemUpdateManyWithoutPlanNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TreatmentItemUncheckedUpdateManyWithoutPlanNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneWithoutPaymentsNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutMovementsNestedInput
    appointment?: AppointmentUpdateOneWithoutInventoryMovementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialty?: SpecialtyUpdateOneRequiredWithoutProceduresNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    clinicId: string
    action: string
    targetId?: string | null
    targetType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateManyCreatedByInput = {
    id?: string
    clinicId: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyCreatedByInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutInventoryMovementsNestedInput
    item?: InventoryItemUpdateOneRequiredWithoutMovementsNestedInput
    appointment?: AppointmentUpdateOneWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyDentistInput = {
    id?: string
    clinicId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordCreateManyDentistInput = {
    id?: string
    clinicId: string
    patientId: string
    appointmentId?: string | null
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentPlanCreateManyDentistInput = {
    id?: string
    clinicId: string
    patientId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DentistProcedureCreateManyDentistInput = {
    id?: string
    procedureId: string
    createdAt?: Date | string
  }

  export type DentistSpecialtyCreateManyDentistInput = {
    id?: string
    specialtyId: string
    createdAt?: Date | string
  }

  export type AttendanceCreateManyDentistInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    patientId: string
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCIDCreateManyCreatedByInput = {
    id?: string
    attendanceId: string
    cidCode: string
    description: string
    observation?: string | null
  }

  export type AttendanceProcedureCreateManyDentistInput = {
    id?: string
    attendanceId: string
    procedureId?: string | null
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    procedureRelation?: ProcedureUpdateOneWithoutAppointmentsNestedInput
    record?: RecordUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record?: RecordUncheckedUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutRecordsNestedInput
    patient?: PatientUpdateOneRequiredWithoutRecordsNestedInput
    appointment?: AppointmentUpdateOneWithoutRecordNestedInput
    attendance?: AttendanceUpdateOneWithoutRecordNestedInput
  }

  export type RecordUncheckedUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordUncheckedUpdateManyWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentPlanUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutTreatmentPlansNestedInput
    patient?: PatientUpdateOneRequiredWithoutTreatmentPlansNestedInput
    items?: TreatmentItemUpdateManyWithoutPlanNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TreatmentItemUncheckedUpdateManyWithoutPlanNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateManyWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistProcedureUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedure?: ProcedureUpdateOneRequiredWithoutDentistProceduresNestedInput
  }

  export type DentistProcedureUncheckedUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistProcedureUncheckedUpdateManyWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistSpecialtyUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialty?: SpecialtyUpdateOneRequiredWithoutDentistSpecialtiesNestedInput
  }

  export type DentistSpecialtyUncheckedUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistSpecialtyUncheckedUpdateManyWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    patient?: PatientUpdateOneRequiredWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateManyWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCIDUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateOneRequiredWithoutCidsNestedInput
  }

  export type AttendanceCIDUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceCIDUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceProcedureUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateOneRequiredWithoutProceduresNestedInput
    procedure?: ProcedureUpdateOneWithoutAttendanceProceduresNestedInput
  }

  export type AttendanceProcedureUncheckedUpdateWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceProcedureUncheckedUpdateManyWithoutDentistInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    clinicId: string
    dentistId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureId?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecordCreateManyPatientInput = {
    id?: string
    clinicId: string
    dentistId: string
    appointmentId?: string | null
    attendanceId?: string | null
    description: string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentPlanCreateManyPatientInput = {
    id?: string
    clinicId: string
    dentistId: string
    status?: $Enums.TreatmentPlanStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyPatientInput = {
    id?: string
    clinicId: string
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    discountType?: $Enums.DiscountType | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    description?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyPatientInput = {
    id?: string
    clinicId: string
    appointmentId?: string | null
    dentistId?: string | null
    status?: $Enums.AttendanceStatus
    arrivalAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByRole: $Enums.UserRole
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAppointmentsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutAppointmentsNestedInput
    procedureRelation?: ProcedureUpdateOneWithoutAppointmentsNestedInput
    record?: RecordUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record?: RecordUncheckedUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutRecordsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutRecordsNestedInput
    appointment?: AppointmentUpdateOneWithoutRecordNestedInput
    attendance?: AttendanceUpdateOneWithoutRecordNestedInput
  }

  export type RecordUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecordUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    procedures?: NullableJsonNullValueInput | InputJsonValue
    odontogram?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentPlanUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutTreatmentPlansNestedInput
    dentist?: DentistUpdateOneRequiredWithoutTreatmentPlansNestedInput
    items?: TreatmentItemUpdateManyWithoutPlanNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TreatmentItemUncheckedUpdateManyWithoutPlanNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedUpdateManyWithoutTreatmentPlanNestedInput
  }

  export type TreatmentPlanUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    status?: EnumTreatmentPlanStatusFieldUpdateOperationsInput | $Enums.TreatmentPlanStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPaymentsNestedInput
    paymentTreatmentPlans?: PaymentTreatmentPlanUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTreatmentPlans?: PaymentTreatmentPlanUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountType?: NullableEnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAttendancesNestedInput
    appointment?: AppointmentUpdateOneWithoutAttendanceNestedInput
    dentist?: DentistUpdateOneWithoutAttendancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    cids?: AttendanceCIDUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUpdateManyWithoutAttendanceNestedInput
    record?: RecordUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cids?: AttendanceCIDUncheckedUpdateManyWithoutAttendanceNestedInput
    procedures?: AttendanceProcedureUncheckedUpdateManyWithoutAttendanceNestedInput
    odontogram?: AttendanceOdontogramUncheckedUpdateOneWithoutAttendanceNestedInput
    documents?: ClinicalDocumentUncheckedUpdateManyWithoutAttendanceNestedInput
    record?: RecordUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    arrivalAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyAppointmentInput = {
    id?: string
    clinicId: string
    itemId: string
    type: $Enums.InventoryMovementType
    quantity: number
    createdById: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutInventoryMovementsNestedInput
    item?: InventoryItemUpdateOneRequiredWithoutMovementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentItemCreateManyPlanInput = {
    id?: string
    procedureId?: string | null
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type PaymentTreatmentPlanCreateManyTreatmentPlanInput = {
    id?: string
    paymentId: string
    createdAt?: Date | string
  }

  export type TreatmentItemUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    procedure?: ProcedureUpdateOneWithoutTreatmentItemsNestedInput
  }

  export type TreatmentItemUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TreatmentItemUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentTreatmentPlanUpdateWithoutTreatmentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutPaymentTreatmentPlansNestedInput
  }

  export type PaymentTreatmentPlanUncheckedUpdateWithoutTreatmentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTreatmentPlanUncheckedUpdateManyWithoutTreatmentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTreatmentPlanCreateManyPaymentInput = {
    id?: string
    treatmentPlanId: string
    createdAt?: Date | string
  }

  export type PaymentTreatmentPlanUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treatmentPlan?: TreatmentPlanUpdateOneRequiredWithoutPaymentTreatmentPlansNestedInput
  }

  export type PaymentTreatmentPlanUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatmentPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTreatmentPlanUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatmentPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyItemInput = {
    id?: string
    clinicId: string
    type: $Enums.InventoryMovementType
    quantity: number
    appointmentId?: string | null
    createdById: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutInventoryMovementsNestedInput
    appointment?: AppointmentUpdateOneWithoutInventoryMovementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureCreateManySpecialtyInput = {
    id?: string
    clinicId: string
    name: string
    description?: string | null
    baseValue: Decimal | DecimalJsLike | number | string
    commissionPercentage: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DentistSpecialtyCreateManySpecialtyInput = {
    id?: string
    dentistId: string
    createdAt?: Date | string
  }

  export type ProcedureUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutProceduresNestedInput
    dentistProcedures?: DentistProcedureUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentistProcedures?: DentistProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProcedureRelationNestedInput
    attendanceProcedures?: AttendanceProcedureUncheckedUpdateManyWithoutProcedureNestedInput
    treatmentItems?: TreatmentItemUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateManyWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commissionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistSpecialtyUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUpdateOneRequiredWithoutDentistSpecialtiesNestedInput
  }

  export type DentistSpecialtyUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistSpecialtyUncheckedUpdateManyWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistProcedureCreateManyProcedureInput = {
    id?: string
    dentistId: string
    createdAt?: Date | string
  }

  export type AppointmentCreateManyProcedureRelationInput = {
    id?: string
    clinicId: string
    dentistId: string
    patientId: string
    date: Date | string
    durationMinutes?: number
    status?: $Enums.AppointmentStatus
    procedure?: string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceProcedureCreateManyProcedureInput = {
    id?: string
    attendanceId: string
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    dentistId?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentItemCreateManyProcedureInput = {
    id?: string
    planId: string
    description: string
    tooth?: string | null
    value: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type DentistProcedureUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dentist?: DentistUpdateOneRequiredWithoutDentistProceduresNestedInput
  }

  export type DentistProcedureUncheckedUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DentistProcedureUncheckedUpdateManyWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutProcedureRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutAppointmentsNestedInput
    dentist?: DentistUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    record?: RecordUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutProcedureRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record?: RecordUncheckedUpdateOneWithoutAppointmentNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutAppointmentNestedInput
    attendance?: AttendanceUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutProcedureRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    dentistId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    procedure?: NullableStringFieldUpdateOperationsInput | string | null
    procedureSnapshot?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceProcedureUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateOneRequiredWithoutProceduresNestedInput
    dentist?: DentistUpdateOneWithoutAttendanceProceduresNestedInput
  }

  export type AttendanceProcedureUncheckedUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceProcedureUncheckedUpdateManyWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: StringFieldUpdateOperationsInput | string
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentItemUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    plan?: TreatmentPlanUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TreatmentItemUncheckedUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TreatmentItemUncheckedUpdateManyWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type AttendanceCIDCreateManyAttendanceInput = {
    id?: string
    cidCode: string
    description: string
    observation?: string | null
    createdByDentistId: string
  }

  export type AttendanceProcedureCreateManyAttendanceInput = {
    id?: string
    procedureId?: string | null
    procedureCode?: string | null
    description: string
    tooth?: string | null
    surface?: string | null
    faces?: AttendanceProcedureCreatefacesInput | string[]
    quantity?: number
    clinicalStatus?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    dentistId?: string | null
    observations?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalDocumentCreateManyAttendanceInput = {
    id?: string
    type: $Enums.ClinicalDocumentType
    payload: JsonNullValueInput | InputJsonValue
    generatedBy: string
    generatedAt?: Date | string
  }

  export type AttendanceCIDUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: DentistUpdateOneRequiredWithoutAttendanceCidsNestedInput
  }

  export type AttendanceCIDUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    createdByDentistId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceCIDUncheckedUpdateManyWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    createdByDentistId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceProcedureUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedure?: ProcedureUpdateOneWithoutAttendanceProceduresNestedInput
    dentist?: DentistUpdateOneWithoutAttendanceProceduresNestedInput
  }

  export type AttendanceProcedureUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceProcedureUncheckedUpdateManyWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: NullableStringFieldUpdateOperationsInput | string | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    tooth?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableStringFieldUpdateOperationsInput | string | null
    faces?: AttendanceProcedureUpdatefacesInput | string[]
    quantity?: IntFieldUpdateOperationsInput | number
    clinicalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dentistId?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalDocumentUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumClinicalDocumentTypeFieldUpdateOperationsInput | $Enums.ClinicalDocumentType
    payload?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalDocumentUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumClinicalDocumentTypeFieldUpdateOperationsInput | $Enums.ClinicalDocumentType
    payload?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalDocumentUncheckedUpdateManyWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumClinicalDocumentTypeFieldUpdateOperationsInput | $Enums.ClinicalDocumentType
    payload?: JsonNullValueInput | InputJsonValue
    generatedBy?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}